:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/GSpace.e',60).
% translate: unskipped  File: /pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e.lps 
:-include(library('ec_planner/ec_test_incl')).
:-expects_dialect(lps).
% translate: begining  File: /pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e.lps 
% Wed, 07 Oct 2020 20:48:54 GMT File: <stream>(0x55afadce6000)


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/GSpace.e',60).
%;
%; Copyright (c) 2005 IBM Corporation and others.
%; All rights reserved. This program and the accompanying materials
%; are made available under the terms of the Common Public License v1.0
%; which accompanies this distribution, and is available at
%; http://www.eclipse.org/legal/cpl-v10.html
%;
%; Contributors:
%; IBM - Initial implementation
%;
%; DEV-MUC3-0060
%; Arson
%;
%; @article{Mueller:2004c,
%;   author = "Erik T. Mueller",
%;   year = "2004",
%;   title = "Understanding script-based stories using commonsense reasoning",
%;   journal = "Cognitive Systems Research",
%;   volume = "5",
%;   number = "4",
%;   pages = "307--340",
%; }
%;

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',25).
% ignore SkyOf, GroundOf, Near, Inside, WalkFromTo, RunFromTo

 /*  axiom(ignore(skyOf),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',25).
ignore(skyOf).

 /*  axiom(ignore(groundOf),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',25).
ignore(groundOf).

 /*  axiom(ignore(near),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',25).
ignore(near).

 /*  axiom(ignore(inside),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',25).
ignore(inside).

 /*  axiom(ignore(walkFromTo),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',25).
ignore(walkFromTo).

 /*  axiom(ignore(runFromTo),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',25).
ignore(runFromTo).

% ignore RollAlong, Diameter, Move, HoldSome, PutInside

 /*  axiom(ignore(rollAlong),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',25).
ignore(rollAlong).

 /*  axiom(ignore(diameter),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',25).
ignore(diameter).

 /*  axiom(ignore(move),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',25).
ignore(move).

 /*  axiom(ignore(holdSome),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',25).
ignore(holdSome).

 /*  axiom(ignore(putInside),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',25).
ignore(putInside).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',27).
% ignore TakeOutOf, On, DoorUnlock, DoorLock, WalkThroughDoor12

 /*  axiom(ignore(takeOutOf),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',27).
ignore(takeOutOf).

 /*  axiom(ignore(on),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',27).
ignore(on).

 /*  axiom(ignore(doorUnlock),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',27).
ignore(doorUnlock).

 /*  axiom(ignore(doorLock),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',27).
ignore(doorLock).

 /*  axiom(ignore(walkThroughDoor12),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',27).
ignore(walkThroughDoor12).

% ignore WalkThroughDoor21, WalkDownStaircase, WalkUpStaircase

 /*  axiom(ignore(walkThroughDoor21),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',27).
ignore(walkThroughDoor21).

 /*  axiom(ignore(walkDownStaircase),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',27).
ignore(walkDownStaircase).

 /*  axiom(ignore(walkUpStaircase),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',27).
ignore(walkUpStaircase).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',30).
% ignore ThreatenedBy

 /*  axiom(ignore(threatenedBy),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',30).
ignore(threatenedBy).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',32).
% load foundations/Root.e
:- if(is_e_toplevel).
:- cond_convert_e(changed, 'foundations/Root.e').
:- endif.

% load foundations/EC.e
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',32).
:- if(is_e_toplevel).
:- cond_convert_e(changed, 'foundations/EC.e').
:- endif.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',34).
% load answers/Mueller2003/Ontology.e
:- if(is_e_toplevel).
:- cond_convert_e(changed, 'answers/Mueller2003/Ontology.e').
 %  loading(changed,'/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e').
%;
%; Copyright (c) 2005 IBM Corporation and others.
%; All rights reserved. This program and the accompanying materials
%; are made available under the terms of the Common Public License v1.0
%; which accompanies this distribution, and is available at
%; http://www.eclipse.org/legal/cpl-v10.html
%;
%; Contributors:
%; IBM - Initial implementation
%;
%; integer
%;

% sort diameter: integer
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',14).
subsort(diameter,integer).
%; object

% sort object
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',18).
sort(object).

% sort agent: object
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',20).
subsort(agent,object).

% sort physobj: object
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',22).
subsort(physobj,object).

% sort bed: physobj
subsort(bed,physobj).

% sort snowflake: physobj
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',24).
subsort(snowflake,physobj).

% sort sky: physobj
subsort(sky,physobj).

% sort stuff: physobj
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',27).
subsort(stuff,physobj).

% sort surface: physobj
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',29).
subsort(surface,physobj).

% sort ground: surface
subsort(ground,surface).

% sort snow: stuff
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',32).
subsort(snow,stuff).

% sort ball
sort(ball).

% sort food: physobj
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',35).
subsort(food,physobj).

% sort fruit: food
subsort(fruit,food).

% sort orange: fruit
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',37).
subsort(orange,fruit).

% sort salad: food
subsort(salad,food).

% sort clothing: physobj
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',40).
subsort(clothing,physobj).

% sort scarf: clothing
subsort(scarf,clothing).

% sort hat: clothing
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',42).
subsort(hat,clothing).

% sort vegetablematter: physobj
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',44).
subsort(vegetablematter,physobj).

% sort coal: vegetablematter
subsort(coal,vegetablematter).

% sort bodypart: physobj
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',47).
subsort(bodypart,physobj).

% sort hand: bodypart
subsort(hand,bodypart).

% sort papertowels: physobj
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',50).
subsort(papertowels,physobj).

% sort device: physobj
subsort(device,physobj).

% sort electronicdevice: device
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',52).
subsort(electronicdevice,device).

% sort lamp: electronicdevice
subsort(lamp,electronicdevice).

% sort cat: physobj
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',55).
subsort(cat,physobj).

% sort horse: physobj
subsort(horse,physobj).

% sort weapon: physobj
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',58).
subsort(weapon,physobj).

% sort gun: weapon
subsort(gun,weapon).

% sort bomb: weapon
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',60).
subsort(bomb,weapon).

% sort bullet: weapon
subsort(bullet,weapon).
%; location

% sort location
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',65).
sort(location).

% sort room: location, outside: location
subsort(room,location).
subsort(outside,location).
%; portal

% sort portal
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',70).
sort(portal).

% sort door: portal, staircase: portal
subsort(door,portal).
subsort(staircase,portal).

% sort street: portal
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',72).
subsort(street,portal).

% sort track: portal
subsort(track,portal).

% sort building
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',75).
sort(building).

% sort fire: object
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',77).
subsort(fire,object).

% sort smoke: physobj
subsort(smoke,physobj).

% sort furniture: physobj
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',80).
subsort(furniture,physobj).

% sort chair: furniture
subsort(chair,furniture).

% sort table: furniture
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',82).
subsort(table,furniture).

% sort bill: physobj
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',84).
subsort(bill,physobj).

% sort ticket: physobj
subsort(ticket,physobj).

% sort envelope: physobj
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',86).
subsort(envelope,physobj).

% sort text: physobj
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',88).
subsort(text,physobj).

% sort book: text
subsort(book,text).

% sort letter: text
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',90).
subsort(letter,text).

% sort menu: text
subsort(menu,text).

% sort paper: physobj
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',93).
subsort(paper,physobj).

% sort content
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',95).
sort(content).

% sort script
sort(script).

% sort container: physobj
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',98).
subsort(container,physobj).

% sort cigarette: physobj
subsort(cigarette,physobj).

% sort ashtray: physobj
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',100).
subsort(ashtray,physobj).

% sort umbrella: physobj
subsort(umbrella,physobj).

% sort pen: physobj
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',103).
subsort(pen,physobj).
%; End of file.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',105).
:- endif.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',35).
% load answers/Mueller2004c/OTSpaceM.e
:- if(is_e_toplevel).
:- cond_convert_e(changed, 'answers/Mueller2004c/OTSpaceM.e').
 %  loading(changed,'/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e').
%;
%; Copyright (c) 2005 IBM Corporation and others.
%; All rights reserved. This program and the accompanying materials
%; are made available under the terms of the Common Public License v1.0
%; which accompanies this distribution, and is available at
%; http://www.eclipse.org/legal/cpl-v10.html
%;
%; Contributors:
%; IBM - Initial implementation
%;
%; OTSpace: object-scale topological space
%;
%; The OTSpace representation deals with topological space at
%; the scale of objects such as agents (humans and animals)
%; and physical objects.
%;
%; PartOf
%; physobj is a part of object.

% predicate PartOf(physobj,object)
 %  predicate(partOf(physobj,object)).
 %  predicate(partOf(physobj,object)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',20).
predicates([partOf/2]).
mpred_prop(partOf(physobj,object),predicate).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',23).
%; A state constraint says that if a physical object
%; is part of an object, the location of the
%; physical object is the same as the location of the object:
% [physobj,object,location,time]
% PartOf(physobj,object) &
% HoldsAt(At(object,location),time) ->
% HoldsAt(At(physobj,location),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',26).

 /*  (   partOf(Physobj, Object),
       holds_at(at(Object, Location), Time)
   ->  holds_at(at(Physobj, Location), Time)
   ).
 */
if partOf(Physobj, Object), loc_at(Object, Location)at Time then loc_at(Physobj, Location)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',26).

 /*  reactive_rule([ partOf(Physobj,Object),
   		holds(loc_at(Object,Location),Time)
   	      ],
   	      [holds(loc_at(Physobj,Location),Time)]).
 */


%; rolling a snowball bigger
%; agent rolls stuff1 along stuff2.

% event RollAlong(agent,stuff,stuff)
 %  event(rollAlong(agent,stuff,stuff)).
 %  event(rollAlong(agent,stuff,stuff)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',33).
actions([rollAlong/3]).
mpred_prop(rollAlong(agent,stuff,stuff),event).


%; The diameter of ball is diameter.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',36).
% fluent Diameter(ball,diameter)
 %  fluent(diameter(ball,diameter)).
 %  fluent(diameter(ball,diameter)).
fluents([diameter/2]).
mpred_prop(diameter(ball,diameter),fluent).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',38).
%; A state constraint says that a ball has a unique diameter:
% [ball,diameter1,diameter2,time]
% HoldsAt(Diameter(ball,diameter1),time) &
% HoldsAt(Diameter(ball,diameter2),time) ->
% diameter1=diameter2.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',40).

 /*  (   holds_at(diameter(Ball, Diameter1), Time),
       holds_at(diameter(Ball, Diameter2), Time)
   ->  equals(Diameter1, Diameter2)
   ).
 */
if diameter(Ball, Diameter1)at Time, diameter(Ball, Diameter2)at Time then equals(Diameter1, Diameter2).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',40).

 /*  reactive_rule([ holds(diameter(Ball,Diameter1),Time),
   		holds(diameter(Ball,Diameter2),Time)
   	      ],
   	      [equals(Diameter1,Diameter2)]).
 */


%; Effect axiom state that if an agent rolls some snow along
%; some other snow, the diameter of the first snow will increase:
% [agent,snow1,snow2,diameter1,diameter2,time]
% HoldsAt(Diameter(snow1,diameter1),time) &
% diameter2 = diameter1+1 ->
% Initiates(RollAlong(agent,snow1,snow2),
%           Diameter(snow1,diameter2),
%           time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',46).

 /*  axiom(initiates(rollAlong(Agent, Snow1, Snow2), diameter(Snow1, Diameter2), Time),
       [ diameter(Snow1, Diameter1),
         '+Pred'(Diameter1, 1, Diameter2)
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',46).

 /*  (   diameter(A, Diameter),
       '+Pred'(Diameter, 1, Pred)
   ->  initiates(rollAlong(RollalongP_Num3_V, A, Rollalong),
                 diameter(A, Pred),
                 Initiates)
   ).
 */
if diameter(A, Diameter), '+Pred'(Diameter, 1, Pred)then initiates(rollAlong(RollalongP_Num3_V, A, Rollalong), diameter(A, Pred)at Initiates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',46).

 /*  reactive_rule([ holds(diameter(A,Diameter),Holds),
   		'+Pred'(Diameter,1,Pred)
   	      ],
   	      [ initiates(rollAlong(RollalongP_Num3_V,
   				    A,
   				    Rollalong),
   			  at(diameter(A,Pred),
   			     Initiates),
   			  Initiates12)
   	      ]).
 */


% [agent,snow1,snow2,diameter1,time]
% HoldsAt(Diameter(snow1,diameter1),time) ->
% Terminates(RollAlong(agent,snow1,snow2),
%            Diameter(snow1,diameter1),
%            time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',54).

 /*  axiom(terminates(rollAlong(Agent, Snow1, Snow2), diameter(Snow1, Diameter1), Time),
       [diameter(Snow1, Diameter1)]).
 */

 /*  diameter(A, Diameter) ->
       terminates(rollAlong(RollalongP_Num3_V, A, Rollalong),
                  diameter(A, Diameter),
                  Terminates).
 */
if diameter(A, Diameter)then terminates(rollAlong(RollalongP_Num3_V, A, Rollalong), diameter(A, Diameter)at Terminates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',54).

 /*  reactive_rule([holds(diameter(A,Diameter),Holds)],
   	      [ terminates(rollAlong(RollalongP_Num3_V,
   				     A,
   				     Rollalong),
   			   at(diameter(A,Diameter),
   			      Terminates),
   			   Terminates10)
   	      ]).
 */


%; A precondition axiom states that
%; for an agent to roll some snow along some other snow,
%; there must be a location such that
%; the agent is at the location,
%; the first snow is at the location, and
%; the second snow is at the location:
%;[agent,snow1,snow2,time]
%;Happens(RollAlong(agent,snow1,snow2),time) ->
%;{location}
%;HoldsAt(At(agent,location),time) &
%;HoldsAt(At(snow1,location),time) &
%;HoldsAt(At(snow2,location),time).
%; motion
%; object moves (in place).

% event Move(object)
 %  event(move(object)).
 %  event(move(object)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',74).
events([move/1]).
mpred_prop(move(object),event).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',77).
%; Holding
%; agent is holding physobj.

% fluent Holding(agent,physobj)
 %  fluent(holding(agent,physobj)).
 %  fluent(holding(agent,physobj)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',79).
fluents([holding/2]).
mpred_prop(holding(agent,physobj),fluent).


%; agent holds or picks up physobj.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',82).
% event Hold(agent,physobj)
 %  event(hold(agent,physobj)).
 %  event(hold(agent,physobj)).
actions([hold/2]).
mpred_prop(hold(agent,physobj),event).


%; agent picks up some stuff1 from stuff2.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',84).
% event HoldSome(agent,stuff,stuff)
 %  event(holdSome(agent,stuff,stuff)).
 %  event(holdSome(agent,stuff,stuff)).
actions([holdSome/3]).
mpred_prop(holdSome(agent,stuff,stuff),event).


%; agent releases or lets go of physobj.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',86).
% event LetGoOf(agent,physobj)
 %  event(letGoOf(agent,physobj)).
 %  event(letGoOf(agent,physobj)).
actions([letGoOf/2]).
mpred_prop(letGoOf(agent,physobj),event).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',88).
%; An effect axiom states that if an agent holds
%; a physical object, the agent will be holding the
%; physical object:
% [agent,physobj,time]
% Initiates(Hold(agent,physobj),Holding(agent,physobj),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',91).

 /*  axiom(initiates(hold(Agent, Physobj), holding(Agent, Physobj), Time),
       []).
 */

 /*  initiates(hold(A,Hold),
   	  holding(A,Hold),
   	  Initiates).
 */
hold(A, Hold)initiates holding(A, Hold).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',91).

 /*  initiated(happens(hold(A,Hold),
   		  Time_From,
   		  Time_Until),
   	  holding(A,Hold),
   	  []).
 */


%; A precondition axiom states that
%; for an agent to hold a physical object,
%; there must be a location such that
%; the agent is at the location and
%; the physical object is at the location:
%;[agent,physobj,time]
%;Happens(Hold(agent,physobj),time) ->
%;{location}
%;  HoldsAt(At(agent,location),time) &
%;  HoldsAt(At(physobj,location),time).
%; An effect axiom states that if an agent
%; lets go of a physical object, the agent is no longer holding
%; the physical object:
% [agent,physobj,time]
% Terminates(LetGoOf(agent,physobj),Holding(agent,physobj),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',108).

 /*  axiom(terminates(letGoOf(Agent, Physobj), holding(Agent, Physobj), Time),
       []).
 */

 /*  terminates(letGoOf(A,Letgoof),
   	   holding(A,Letgoof),
   	   Terminates).
 */
letGoOf(A, Letgoof)terminates holding(A, Letgoof).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',108).

 /*  terminated(happens(letGoOf(A,Letgoof),
   		   Time_From,
   		   Time_Until),
   	   holding(A,Letgoof),
   	   []).
 */


%; A precondition axiom states that
%; for an agent to let go of a physical object,
%; the agent must be holding the physical object:
% [agent,physobj,time]
% Happens(LetGoOf(agent,physobj),time) ->
% HoldsAt(Holding(agent,physobj),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',114).

 /*  happens(letGoOf(Agent, Physobj), Time) ->
       holds_at(holding(Agent, Physobj), Time).
 */
if happens(letGoOf(Agent, Physobj), Time)then holding(Agent, Physobj)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',114).

 /*  reactive_rule([happens(letGoOf(Agent,Physobj),Time)],
   	      [holds(holding(Agent,Physobj),Time)]).
 */


%; A releases axiom states that if an agent holds
%; a physical object,
%; the physical object's location will be released
%; from inertia:
% [agent,physobj,location,time]
% Releases(Hold(agent,physobj),At(physobj,location),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',122).

 /*  axiom(releases(hold(Agent, Physobj), at(Physobj, Location), Time),
       []).
 */

 /*  releases(hold(_,Hold),
   	 at(Hold,Tloc),
   	 Releases).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',122).
releases(hold(_,Hold),
	 loc_at(Hold,Tloc),
	 Releases).


%; A state constraint says that if an agent is holding
%; a physical object and the agent is at a location,
%; the physical object is also at the location:
% [agent,physobj,location,time]
% HoldsAt(Holding(agent,physobj),time) &
% HoldsAt(At(agent,location),time) ->
% HoldsAt(At(physobj,location),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',128).

 /*  (   holds_at(holding(Agent, Physobj), Time),
       holds_at(at(Agent, Location), Time)
   ->  holds_at(at(Physobj, Location), Time)
   ).
 */
if holding(Agent, Physobj)at Time, loc_at(Agent, Location)at Time then loc_at(Physobj, Location)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',128).

 /*  reactive_rule([ holds(holding(Agent,Physobj),Time),
   		holds(loc_at(Agent,Location),Time)
   	      ],
   	      [holds(loc_at(Physobj,Location),Time)]).
 */


%; A releases axiom states that if an agent holds
%; a physical object,
%; the locations of the parts of the physical object
%; will be released from inertia:
% [agent,physobj1,physobj2,location,time]
% PartOf(physobj1,physobj2) ->
% Releases(Hold(agent,physobj2),At(physobj1,location),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',137).

 /*  axiom(releases(hold(Agent, Physobj2), at(Physobj1, Location), Time),
       [partOf(Physobj1, Physobj2)]).
 */

 /*  partOf(A, Partof) ->
       releases(hold(_, Partof), at(A, Tloc), Releases).
 */
if partOf(A, Partof)then releases(hold(_, Partof), loc_at(A, Tloc), Releases).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',137).

 /*  reactive_rule([partOf(A,Partof)],
   	      [ releases(hold(_,Partof),
   			 loc_at(A,Tloc),
   			 Releases)
   	      ]).
 */


%; Further, if an agent holds a physical object,
%; the locations of the physical objects of which
%; the physical object is a part
%; will be released from inertia:
% [agent,physobj1,physobj2,location,time]
% PartOf(physobj1,physobj2) ->
% Releases(Hold(agent,physobj1),At(physobj2,location),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',145).

 /*  axiom(releases(hold(Agent, Physobj1), at(Physobj2, Location), Time),
       [partOf(Physobj1, Physobj2)]).
 */

 /*  partOf(Hold, Partof) ->
       releases(hold(_, Hold),
                at(Partof, Tloc),
                Releases).
 */
if partOf(Hold, Partof)then releases(hold(_, Hold), loc_at(Partof, Tloc), Releases).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',145).

 /*  reactive_rule([partOf(Hold,Partof)],
   	      [ releases(hold(_,Hold),
   			 loc_at(Partof,Tloc),
   			 Releases)
   	      ]).
 */


%;[agent,physobj,location1,location2,time]
%;(!{object} PartOf(physobj,object)) &
%;HoldsAt(At(agent,location1),time) &
%;location1 != location2 ->
%;Terminates(LetGoOf(agent,physobj),At(physobj,location2),time).
% [agent,physobj,location,time]
% (!{object} PartOf(physobj,object)) &
% HoldsAt(At(agent,location),time) ->
% Initiates(LetGoOf(agent,physobj),At(physobj,location),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',155).

 /*  axiom(initiates(letGoOf(Agent, Physobj), at(Physobj, Location), Time),
       [not(partOf(Physobj, Object)), at(Agent, Location)]).
 */

 /*  (   not(partOf(Letgoof, Partof)),
       at(A, Tloc)
   ->  initiates(letGoOf(A, Letgoof),
                 at(Letgoof, Tloc),
                 Initiates)
   ).
 */
if not partOf(Letgoof, Partof), loc_at(A, Tloc)then initiates(letGoOf(A, Letgoof), loc_at(Letgoof, Tloc)at Initiates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',155).

 /*  reactive_rule([ not(partOf(Letgoof,Partof)),
   		holds(loc_at(A,Tloc),Holds)
   	      ],
   	      [ initiates(letGoOf(A,Letgoof),
   			  at(loc_at(Letgoof,Tloc),
   			     Initiates),
   			  Initiates10)
   	      ]).
 */


%;[agent,physobj1,physobj2,location1,location2,time]
%;PartOf(physobj1,physobj2) &
%;(!{object} PartOf(physobj2,object)) &
%;HoldsAt(At(agent,location1),time) &
%;location1 != location2 ->
%;Terminates(LetGoOf(agent,physobj1),At(physobj2,location2),time).
% [agent,physobj1,physobj2,location,time]
% PartOf(physobj1,physobj2) &
% (!{object} PartOf(physobj2,object)) &
% HoldsAt(At(agent,location),time) ->
% Initiates(LetGoOf(agent,physobj1),At(physobj2,location),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',167).

 /*  axiom(initiates(letGoOf(Agent, Physobj1), at(Physobj2, Location), Time),
       [ partOf(Physobj1, Physobj2),
         not(partOf(Physobj2, Object)),
         at(Agent, Location)
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',167).

 /*  (   partOf(Letgoof, Partof),
       not(partOf(Partof, Partof8)),
       at(A, Tloc)
   ->  initiates(letGoOf(A, Letgoof),
                 at(Partof, Tloc),
                 Initiates)
   ).
 */
if partOf(Letgoof, Partof), not partOf(Partof, Partof8), loc_at(A, Tloc)then initiates(letGoOf(A, Letgoof), loc_at(Partof, Tloc)at Initiates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',167).

 /*  reactive_rule([ partOf(Letgoof,Partof),
   		not(partOf(Partof,Partof8)),
   		holds(loc_at(A,Tloc),Holds)
   	      ],
   	      [ initiates(letGoOf(A,Letgoof),
   			  at(loc_at(Partof,Tloc),
   			     Initiates),
   			  Initiates12)
   	      ]).
 */


%; An effect axiom states that if an agent is at a location
%; and lets go of a physical object, the physical object
%; will be at the location:
% [agent,physobj,location,time]
% HoldsAt(At(agent,location),time) ->
% Initiates(LetGoOf(agent,physobj),At(physobj,location),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',176).

 /*  axiom(initiates(letGoOf(Agent, Physobj), at(Physobj, Location), Time),
       [at(Agent, Location)]).
 */

 /*  at(A, Tloc) ->
       initiates(letGoOf(A, Letgoof),
                 at(Letgoof, Tloc),
                 Initiates).
 */
if loc_at(A, Tloc)then initiates(letGoOf(A, Letgoof), loc_at(Letgoof, Tloc)at Initiates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',176).

 /*  reactive_rule([holds(loc_at(A,Tloc),Holds)],
   	      [ initiates(letGoOf(A,Letgoof),
   			  at(loc_at(Letgoof,Tloc),
   			     Initiates),
   			  Initiates8)
   	      ]).
 */


%; An effect axiom states that if an agent picks up
%; some stuff out of some other stuff, the agent will
%; be holding the first stuff:
% [agent,stuff1,stuff2,time]
% Initiates(HoldSome(agent,stuff1,stuff2),
%           Holding(agent,stuff1),
%           time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',183).

 /*  axiom(initiates(holdSome(Agent, Stuff1, Stuff2), holding(Agent, Stuff1), Time),
       []).
 */

 /*  initiates(holdSome(HoldsomeP_Num3_V,Holding,Holdsome),
   	  holding(HoldsomeP_Num3_V,Holding),
   	  Initiates).
 */
holdSome(HoldsomeP_Num3_V, Holding, Holdsome)initiates holding(HoldsomeP_Num3_V, Holding).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',183).

 /*  initiated(happens(holdSome(HoldsomeP_Num3_V,
   			   Holding,
   			   Holdsome),
   		  Time_From,
   		  Time_Until),
   	  holding(HoldsomeP_Num3_V,Holding),
   	  []).
 */


%; A precondition axiom states that
%; for an agent to pick up some stuff out of some other stuff,
%; the first stuff must be a part of the second stuff and
%; there must be a location such that the agent is at the location,
%; the first stuff is at the location, and the second stuff is
%; at the location:
% [agent,stuff1,stuff2,time]
% Happens(HoldSome(agent,stuff1,stuff2),time) ->
% PartOf(stuff1,stuff2) &
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',194).
% {location}% 
%   HoldsAt(At(agent,location),time) &
%   HoldsAt(At(stuff1,location),time) &
%   HoldsAt(At(stuff2,location),time).
 %  clausify_pnf=exists([Location],  (happens(holdSome(Agent, Stuff1, Stuff2), Time)->partOf(Stuff1, Stuff2), holds_at(at(Agent, Location), Time), holds_at(at(Stuff1, Location), Time), holds_at(at(Stuff2, Location), Time))).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',197).

 /*  not(happens(holdSome(Agent, Stuff1, Stuff2), Time)) :-
       (   not(partOf(Stuff1, Stuff2))
       ;   not(holds_at(at(Agent, Exists_Location), Time))
       ;   not(holds_at(at(Stuff1, Exists_Location), Time))
       ;   not(holds_at(at(Stuff2, Exists_Location), Time))
       ),
       some(Exists_Location,
            '$kolem_Fn_65'(Agent, Stuff1, Stuff2, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',197).

 /*  fix_axiom_head(Time) ->
       [ not(happens(holdSome(Agent, Stuff1, Stuff2), Time)),
          (->),
         not(holdSome(Agent, Stuff1, Stuff2))
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',197).

 /*  axiom(not(holdSome(Agent, Stuff1, Stuff2)),
       [  (not(partOf(Stuff1, Stuff2));not(at(Agent, Exists_Location));not(at(Stuff1, Exists_Location));not(at(Stuff2, Exists_Location))),
         some(Exists_Location,
              '$kolem_Fn_65'(Agent, Stuff1, Stuff2, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',197).

 /*  (   (   not(partOf(A, Partof))
       ;   not(at(Kolem_Fn_65P_Num4_V, Tloc))
       ;   not(at(A, Tloc))
       ;   not(at(Partof, Tloc))
       ),
       some(Tloc,
            '$kolem_Fn_65'(Kolem_Fn_65P_Num4_V,
                           A,
                           Partof,
                           Kolem_Fn_65))
   ->  not(holdSome(Kolem_Fn_65P_Num4_V, A, Partof))
   ).
 */
if (not partOf(A, Partof);not loc_at(Kolem_Fn_65P_Num4_V, Tloc);not loc_at(A, Tloc);not loc_at(Partof, Tloc)), some(Tloc, '$kolem_Fn_65'(Kolem_Fn_65P_Num4_V, A, Partof, Kolem_Fn_65))then not holdSome(Kolem_Fn_65P_Num4_V, A, Partof).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',197).

 /*   reactive_rule([  (not(partOf(A, Partof));not(loc_at(Kolem_Fn_65P_Num4_V, Tloc));not(loc_at(A, Tloc));not(loc_at(Partof, Tloc))),
                      some(Tloc,
                           '$kolem_Fn_65'(Kolem_Fn_65P_Num4_V,
                                          A,
                                          Partof,
                                          Kolem_Fn_65))
                    ],
                    [ not(holdSome(Kolem_Fn_65P_Num4_V,
                                   A,
                                   Partof))
                    ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',197).

 /*  partOf(Stuff1, Stuff2) :-
       happens(holdSome(Agent, Stuff1, Stuff2), Time),
       some(Exists_Location,
            '$kolem_Fn_65'(Agent, Stuff1, Stuff2, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',197).

 /*  fix_axiom_head(Time) ->
       [ happens(holdSome(Agent, Stuff1, Stuff2), Time),
          (->),
         holdSome(Agent, Stuff1, Stuff2)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',197).

 /*  axiom(partOf(Stuff1, Stuff2),
       [ holdSome(Agent, Stuff1, Stuff2),
         some(Exists_Location,
              '$kolem_Fn_65'(Agent, Stuff1, Stuff2, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',197).

 /*  (   holdSome(HoldsomeP_Num3_V, A, Holdsome),
       some(_,
            '$kolem_Fn_65'(HoldsomeP_Num3_V,
                           A,
                           Holdsome,
                           Kolem_Fn_6512))
   ->  partOf(A, Holdsome)
   ).
 */
if holdSome(HoldsomeP_Num3_V, A, Holdsome), some(_, '$kolem_Fn_65'(HoldsomeP_Num3_V, A, Holdsome, Kolem_Fn_6512))then partOf(A, Holdsome).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',197).

 /*  reactive_rule([ happens(holdSome(HoldsomeP_Num3_V,
   				 A,
   				 Holdsome),
   			Time_From,
   			Time_Until),
   		some(_,
   		     '$kolem_Fn_65'(HoldsomeP_Num3_V,
   				    A,
   				    Holdsome,
   				    Kolem_Fn_6512))
   	      ],
   	      [partOf(A,Holdsome)]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',197).

 /*  holds_at(at(Agent, Exists_Location), Time) :-
       happens(holdSome(Agent, Stuff1, Stuff2), Time),
       some(Exists_Location,
            '$kolem_Fn_65'(Agent, Stuff1, Stuff2, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',197).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Agent, Exists_Location), Time),
          (->),
         at(Agent, Exists_Location)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',197).

 /*  axiom(at(Agent, Exists_Location),
       [ holdSome(Agent, Stuff1, Stuff2),
         some(Exists_Location,
              '$kolem_Fn_65'(Agent, Stuff1, Stuff2, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',197).

 /*  (   holdSome(HoldsomeP_Num3_V17, A, Holdsome16),
       some(Tloc15,
            '$kolem_Fn_65'(HoldsomeP_Num3_V17,
                           A,
                           Holdsome16,
                           Kolem_Fn_6518))
   ->  at(HoldsomeP_Num3_V17, Tloc15)
   ).
 */
if holdSome(HoldsomeP_Num3_V17, A, Holdsome16), some(Tloc15, '$kolem_Fn_65'(HoldsomeP_Num3_V17, A, Holdsome16, Kolem_Fn_6518))then loc_at(HoldsomeP_Num3_V17, Tloc15).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',197).

 /*  reactive_rule([ happens(holdSome(HoldsomeP_Num3_V17,
   				 A,
   				 Holdsome16),
   			Time_From19,
   			Time_Until20),
   		some(Tloc15,
   		     '$kolem_Fn_65'(HoldsomeP_Num3_V17,
   				    A,
   				    Holdsome16,
   				    Kolem_Fn_6518))
   	      ],
   	      [ holds(loc_at(HoldsomeP_Num3_V17,Tloc15),
   		      Holds)
   	      ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',197).

 /*  holds_at(at(Stuff1, Exists_Location), Time) :-
       happens(holdSome(Agent, Stuff1, Stuff2), Time),
       some(Exists_Location,
            '$kolem_Fn_65'(Agent, Stuff1, Stuff2, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',197).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Stuff1, Exists_Location), Time),
          (->),
         at(Stuff1, Exists_Location)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',197).

 /*  axiom(at(Stuff1, Exists_Location),
       [ holdSome(Agent, Stuff1, Stuff2),
         some(Exists_Location,
              '$kolem_Fn_65'(Agent, Stuff1, Stuff2, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',197).

 /*  (   holdSome(HoldsomeP_Num3_V24, A, Holdsome23),
       some(Tloc22,
            '$kolem_Fn_65'(HoldsomeP_Num3_V24,
                           A,
                           Holdsome23,
                           Kolem_Fn_6525))
   ->  at(A, Tloc22)
   ).
 */
if holdSome(HoldsomeP_Num3_V24, A, Holdsome23), some(Tloc22, '$kolem_Fn_65'(HoldsomeP_Num3_V24, A, Holdsome23, Kolem_Fn_6525))then loc_at(A, Tloc22).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',197).

 /*  reactive_rule([ happens(holdSome(HoldsomeP_Num3_V24,
   				 A,
   				 Holdsome23),
   			Time_From26,
   			Time_Until27),
   		some(Tloc22,
   		     '$kolem_Fn_65'(HoldsomeP_Num3_V24,
   				    A,
   				    Holdsome23,
   				    Kolem_Fn_6525))
   	      ],
   	      [holds(loc_at(A,Tloc22),Holds28)]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',197).

 /*  holds_at(at(Stuff2, Exists_Location), Time) :-
       happens(holdSome(Agent, Stuff1, Stuff2), Time),
       some(Exists_Location,
            '$kolem_Fn_65'(Agent, Stuff1, Stuff2, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',197).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Stuff2, Exists_Location), Time),
          (->),
         at(Stuff2, Exists_Location)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',197).

 /*  axiom(at(Stuff2, Exists_Location),
       [ holdSome(Agent, Stuff1, Stuff2),
         some(Exists_Location,
              '$kolem_Fn_65'(Agent, Stuff1, Stuff2, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',197).

 /*  (   holdSome(HoldsomeP_Num3_V31, A, Holdsome30),
       some(Tloc29,
            '$kolem_Fn_65'(HoldsomeP_Num3_V31,
                           A,
                           Holdsome30,
                           Kolem_Fn_6532))
   ->  at(Holdsome30, Tloc29)
   ).
 */
if holdSome(HoldsomeP_Num3_V31, A, Holdsome30), some(Tloc29, '$kolem_Fn_65'(HoldsomeP_Num3_V31, A, Holdsome30, Kolem_Fn_6532))then loc_at(Holdsome30, Tloc29).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',197).

 /*  reactive_rule([ happens(holdSome(HoldsomeP_Num3_V31,
   				 A,
   				 Holdsome30),
   			Time_From33,
   			Time_Until34),
   		some(Tloc29,
   		     '$kolem_Fn_65'(HoldsomeP_Num3_V31,
   				    A,
   				    Holdsome30,
   				    Kolem_Fn_6532))
   	      ],
   	      [ holds(loc_at(Holdsome30,Tloc29),
   		      Holds35)
   	      ]).
 */


%; A releases axiom states that if an agent picks up some
%; stuff out of some other stuff,
%; the first stuff's location will be released
%; from inertia:
% [agent,stuff1,stuff2,location,time]
% Releases(HoldSome(agent,stuff1,stuff2),At(stuff1,location),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',206).

 /*  axiom(releases(holdSome(Agent, Stuff1, Stuff2), at(Stuff1, Location), Time),
       []).
 */

 /*  releases(holdSome(HoldsomeP_Num3_V,A,Holdsome),
   	 at(A,Tloc),
   	 Releases).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',206).
releases(holdSome(HoldsomeP_Num3_V,A,Holdsome),
	 loc_at(A,Tloc),
	 Releases).


%; Inside
%; physobj1 is inside physobj2.

% fluent Inside(physobj,physobj)
 %  fluent(inside(physobj,physobj)).
 %  fluent(inside(physobj,physobj)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',211).
fluents([inside/2]).
mpred_prop(inside(physobj,physobj),fluent).


%; agent puts physobj1 inside physobj2.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',214).
% event PutInside(agent,physobj,physobj)
 %  event(putInside(agent,physobj,physobj)).
 %  event(putInside(agent,physobj,physobj)).
actions([putInside/3]).
mpred_prop(putInside(agent,physobj,physobj),event).


%; agent takes physobj1 out of physobj2.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',216).
% event TakeOutOf(agent,physobj,physobj)
 %  event(takeOutOf(agent,physobj,physobj)).
 %  event(takeOutOf(agent,physobj,physobj)).
actions([takeOutOf/3]).
mpred_prop(takeOutOf(agent,physobj,physobj),event).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',218).
%; A state constraint says that a physical object cannot
%; be inside itself:
% [physobj1,physobj2,time]
% HoldsAt(Inside(physobj1,physobj2),time) ->
% physobj1!=physobj2.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',220).

 /*  holds_at(inside(Physobj1, Physobj2), Time) ->
       diff(Physobj1, Physobj2).
 */
if inside(Physobj1, Physobj2)at Time then diff(Physobj1, Physobj2).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',220).

 /*  reactive_rule([holds(inside(Physobj1,Physobj2),Time)],
   	      [diff(Physobj1,Physobj2)]).
 */


%; A state constraint says that if a physical object is
%; inside another physical object, the second physical object
%; is not inside the first physical object:
% [physobj1,physobj2,time]
% HoldsAt(Inside(physobj1,physobj2),time) ->
% !HoldsAt(Inside(physobj2,physobj1),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',227).

 /*  holds_at(inside(Physobj1, Physobj2), Time) ->
       holds_at(neg(inside(Physobj2, Physobj1)), Time).
 */
if inside(Physobj1, Physobj2)at Time then not inside(Physobj2, Physobj1)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',227).

 /*  reactive_rule([holds(inside(Physobj1,Physobj2),Time)],
   	      [ holds(not(inside(Physobj2,Physobj1)),
   		      Time)
   	      ]).
 */


%; An effect axiom states that if an agent puts a physical
%; object inside another physical object, the first
%; physical object will be inside the second physical object:
% [agent,physobj1,physobj2,time]
% Initiates(PutInside(agent,physobj1,physobj2),
%           Inside(physobj1,physobj2),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',234).

 /*  axiom(initiates(putInside(Agent, Physobj1, Physobj2), inside(Physobj1, Physobj2), Time),
       []).
 */

 /*  initiates(putInside(PutinsideP_Num3_V,A,Putinside),
   	  inside(A,Putinside),
   	  Initiates).
 */
putInside(PutinsideP_Num3_V, A, Putinside)initiates inside(A, Putinside).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',234).

 /*  initiated(happens(putInside(PutinsideP_Num3_V,
   			    A,
   			    Putinside),
   		  Time_From,
   		  Time_Until),
   	  inside(A,Putinside),
   	  []).
 */


%; An effect axiom states that if an agent puts a physical
%; object inside another physical object, the agent will
%; no longer be holding the first physical object:
% [agent,physobj1,physobj2,time]
% Terminates(PutInside(agent,physobj1,physobj2),
%            Holding(agent,physobj1),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',241).

 /*  axiom(terminates(putInside(Agent, Physobj1, Physobj2), holding(Agent, Physobj1), Time),
       []).
 */

 /*  terminates(putInside(PutinsideP_Num3_V,
   		     Holding,
   		     Putinside),
   	   holding(PutinsideP_Num3_V,Holding),
   	   Terminates).
 */
putInside(PutinsideP_Num3_V, Holding, Putinside)terminates holding(PutinsideP_Num3_V, Holding).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',241).

 /*  terminated(happens(putInside(PutinsideP_Num3_V,
   			     Holding,
   			     Putinside),
   		   Time_From,
   		   Time_Until),
   	   holding(PutinsideP_Num3_V,Holding),
   	   []).
 */


%; A precondition axiom states that
%; for an agent to put a physical object inside another
%; physical object,
%; the agent must be holding the first physical object
%; and there must be a location such that
%; the agent is at the location and
%; the second physical object is at the location:
%;[agent,physobj1,physobj2,time]
%;Happens(PutInside(agent,physobj1,physobj2),time) ->
%;HoldsAt(Holding(agent,physobj1),time) &
%;{location}
%; HoldsAt(At(agent,location),time) &
%; HoldsAt(At(physobj2,location),time).
%; An effect axiom states that
%; if an agent takes a physical object out of another
%; physical object, the first physical object
%; will no longer be inside the second physical object:
% [agent,physobj1,physobj2,time]
% Terminates(TakeOutOf(agent,physobj1,physobj2),
%            Inside(physobj1,physobj2),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',263).

 /*  axiom(terminates(takeOutOf(Agent, Physobj1, Physobj2), inside(Physobj1, Physobj2), Time),
       []).
 */

 /*  terminates(takeOutOf(TakeoutofP_Num3_V,A,Takeoutof),
   	   inside(A,Takeoutof),
   	   Terminates).
 */
takeOutOf(TakeoutofP_Num3_V, A, Takeoutof)terminates inside(A, Takeoutof).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',263).

 /*  terminated(happens(takeOutOf(TakeoutofP_Num3_V,
   			     A,
   			     Takeoutof),
   		   Time_From,
   		   Time_Until),
   	   inside(A,Takeoutof),
   	   []).
 */


%; A precondition axiom states that
%; for an agent to take a physical object out of another
%; physical object,
%; the first physical object must be inside the second physical object
%; and there must be a location such that
%; the agent is at the location,
%; the first physical object is at the location, and
%; the second physical object is at the location:
% [agent,physobj1,physobj2,time]
% Happens(TakeOutOf(agent,physobj1,physobj2),time) ->
% HoldsAt(Inside(physobj1,physobj2),time) &
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',275).
% {location}% 
%  HoldsAt(At(agent,location),time) &
%  HoldsAt(At(physobj1,location),time) &
%  HoldsAt(At(physobj2,location),time).
 %  clausify_pnf=exists([Location],  (happens(takeOutOf(Agent, Physobj1, Physobj2), Time)->holds_at(inside(Physobj1, Physobj2), Time), holds_at(at(Agent, Location), Time), holds_at(at(Physobj1, Location), Time), holds_at(at(Physobj2, Location), Time))).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',278).

 /*  not(happens(takeOutOf(Agent, Physobj1, Physobj2), Time)) :-
       (   not(holds_at(inside(Physobj1, Physobj2), Time))
       ;   not(holds_at(at(Agent, Exists_Location), Time))
       ;   not(holds_at(at(Physobj1, Exists_Location), Time))
       ;   not(holds_at(at(Physobj2, Exists_Location), Time))
       ),
       some(Exists_Location,
            '$kolem_Fn_66'(Agent, Physobj1, Physobj2, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',278).

 /*  fix_axiom_head(Time) ->
       [ not(happens(takeOutOf(Agent, Physobj1, Physobj2),
                     Time)),
          (->),
         not(takeOutOf(Agent, Physobj1, Physobj2))
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',278).

 /*  axiom(not(takeOutOf(Agent, Physobj1, Physobj2)),
       [  (not(inside(Physobj1, Physobj2));not(at(Agent, Exists_Location));not(at(Physobj1, Exists_Location));not(at(Physobj2, Exists_Location))),
         some(Exists_Location,
              '$kolem_Fn_66'(Agent, Physobj1, Physobj2, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',278).

 /*  (   (   not(inside(A, Inside))
       ;   not(at(Kolem_Fn_66P_Num4_V, Tloc))
       ;   not(at(A, Tloc))
       ;   not(at(Inside, Tloc))
       ),
       some(Tloc,
            '$kolem_Fn_66'(Kolem_Fn_66P_Num4_V,
                           A,
                           Inside,
                           Kolem_Fn_66))
   ->  not(takeOutOf(Kolem_Fn_66P_Num4_V, A, Inside))
   ).
 */
if (not inside(A, Inside);not loc_at(Kolem_Fn_66P_Num4_V, Tloc);not loc_at(A, Tloc);not loc_at(Inside, Tloc)), some(Tloc, '$kolem_Fn_66'(Kolem_Fn_66P_Num4_V, A, Inside, Kolem_Fn_66))then not takeOutOf(Kolem_Fn_66P_Num4_V, A, Inside).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',278).

 /*   reactive_rule([  (not(inside(A, Inside));not(loc_at(Kolem_Fn_66P_Num4_V, Tloc));not(loc_at(A, Tloc));not(loc_at(Inside, Tloc))),
                      some(Tloc,
                           '$kolem_Fn_66'(Kolem_Fn_66P_Num4_V,
                                          A,
                                          Inside,
                                          Kolem_Fn_66))
                    ],
                    [ not(takeOutOf(Kolem_Fn_66P_Num4_V,
                                    A,
                                    Inside))
                    ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',278).

 /*  holds_at(inside(Physobj1, Physobj2), Time) :-
       happens(takeOutOf(Agent, Physobj1, Physobj2), Time),
       some(Exists_Location,
            '$kolem_Fn_66'(Agent, Physobj1, Physobj2, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',278).

 /*  fix_axiom_head(Time) ->
       [ holds_at(inside(Physobj1, Physobj2), Time),
          (->),
         inside(Physobj1, Physobj2)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',278).

 /*  axiom(inside(Physobj1, Physobj2),
       [ takeOutOf(Agent, Physobj1, Physobj2),
         some(Exists_Location,
              '$kolem_Fn_66'(Agent, Physobj1, Physobj2, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',278).

 /*  (   takeOutOf(TakeoutofP_Num3_V, A, Takeoutof),
       some(_,
            '$kolem_Fn_66'(TakeoutofP_Num3_V,
                           A,
                           Takeoutof,
                           Kolem_Fn_6612))
   ->  inside(A, Takeoutof)
   ).
 */
if takeOutOf(TakeoutofP_Num3_V, A, Takeoutof), some(_, '$kolem_Fn_66'(TakeoutofP_Num3_V, A, Takeoutof, Kolem_Fn_6612))then inside(A, Takeoutof).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',278).

 /*  reactive_rule([ happens(takeOutOf(TakeoutofP_Num3_V,
   				  A,
   				  Takeoutof),
   			Time_From,
   			Time_Until),
   		some(_,
   		     '$kolem_Fn_66'(TakeoutofP_Num3_V,
   				    A,
   				    Takeoutof,
   				    Kolem_Fn_6612))
   	      ],
   	      [holds(inside(A,Takeoutof),Holds)]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',278).

 /*  holds_at(at(Agent, Exists_Location), Time) :-
       happens(takeOutOf(Agent, Physobj1, Physobj2), Time),
       some(Exists_Location,
            '$kolem_Fn_66'(Agent, Physobj1, Physobj2, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',278).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Agent, Exists_Location), Time),
          (->),
         at(Agent, Exists_Location)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',278).

 /*  axiom(at(Agent, Exists_Location),
       [ takeOutOf(Agent, Physobj1, Physobj2),
         some(Exists_Location,
              '$kolem_Fn_66'(Agent, Physobj1, Physobj2, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',278).

 /*  (   takeOutOf(TakeoutofP_Num3_V18, A, Takeoutof17),
       some(Tloc16,
            '$kolem_Fn_66'(TakeoutofP_Num3_V18,
                           A,
                           Takeoutof17,
                           Kolem_Fn_6619))
   ->  at(TakeoutofP_Num3_V18, Tloc16)
   ).
 */
if takeOutOf(TakeoutofP_Num3_V18, A, Takeoutof17), some(Tloc16, '$kolem_Fn_66'(TakeoutofP_Num3_V18, A, Takeoutof17, Kolem_Fn_6619))then loc_at(TakeoutofP_Num3_V18, Tloc16).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',278).

 /*  reactive_rule([ happens(takeOutOf(TakeoutofP_Num3_V18,
   				  A,
   				  Takeoutof17),
   			Time_From20,
   			Time_Until21),
   		some(Tloc16,
   		     '$kolem_Fn_66'(TakeoutofP_Num3_V18,
   				    A,
   				    Takeoutof17,
   				    Kolem_Fn_6619))
   	      ],
   	      [ holds(loc_at(TakeoutofP_Num3_V18,Tloc16),
   		      Holds22)
   	      ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',278).

 /*  holds_at(at(Physobj1, Exists_Location), Time) :-
       happens(takeOutOf(Agent, Physobj1, Physobj2), Time),
       some(Exists_Location,
            '$kolem_Fn_66'(Agent, Physobj1, Physobj2, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',278).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Physobj1, Exists_Location), Time),
          (->),
         at(Physobj1, Exists_Location)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',278).

 /*  axiom(at(Physobj1, Exists_Location),
       [ takeOutOf(Agent, Physobj1, Physobj2),
         some(Exists_Location,
              '$kolem_Fn_66'(Agent, Physobj1, Physobj2, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',278).

 /*  (   takeOutOf(TakeoutofP_Num3_V25, A, Takeoutof24),
       some(Tloc23,
            '$kolem_Fn_66'(TakeoutofP_Num3_V25,
                           A,
                           Takeoutof24,
                           Kolem_Fn_6626))
   ->  at(A, Tloc23)
   ).
 */
if takeOutOf(TakeoutofP_Num3_V25, A, Takeoutof24), some(Tloc23, '$kolem_Fn_66'(TakeoutofP_Num3_V25, A, Takeoutof24, Kolem_Fn_6626))then loc_at(A, Tloc23).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',278).

 /*  reactive_rule([ happens(takeOutOf(TakeoutofP_Num3_V25,
   				  A,
   				  Takeoutof24),
   			Time_From27,
   			Time_Until28),
   		some(Tloc23,
   		     '$kolem_Fn_66'(TakeoutofP_Num3_V25,
   				    A,
   				    Takeoutof24,
   				    Kolem_Fn_6626))
   	      ],
   	      [holds(loc_at(A,Tloc23),Holds29)]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',278).

 /*  holds_at(at(Physobj2, Exists_Location), Time) :-
       happens(takeOutOf(Agent, Physobj1, Physobj2), Time),
       some(Exists_Location,
            '$kolem_Fn_66'(Agent, Physobj1, Physobj2, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',278).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Physobj2, Exists_Location), Time),
          (->),
         at(Physobj2, Exists_Location)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',278).

 /*  axiom(at(Physobj2, Exists_Location),
       [ takeOutOf(Agent, Physobj1, Physobj2),
         some(Exists_Location,
              '$kolem_Fn_66'(Agent, Physobj1, Physobj2, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',278).

 /*  (   takeOutOf(TakeoutofP_Num3_V32, A, Takeoutof31),
       some(Tloc30,
            '$kolem_Fn_66'(TakeoutofP_Num3_V32,
                           A,
                           Takeoutof31,
                           Kolem_Fn_6633))
   ->  at(Takeoutof31, Tloc30)
   ).
 */
if takeOutOf(TakeoutofP_Num3_V32, A, Takeoutof31), some(Tloc30, '$kolem_Fn_66'(TakeoutofP_Num3_V32, A, Takeoutof31, Kolem_Fn_6633))then loc_at(Takeoutof31, Tloc30).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',278).

 /*  reactive_rule([ happens(takeOutOf(TakeoutofP_Num3_V32,
   				  A,
   				  Takeoutof31),
   			Time_From34,
   			Time_Until35),
   		some(Tloc30,
   		     '$kolem_Fn_66'(TakeoutofP_Num3_V32,
   				    A,
   				    Takeoutof31,
   				    Kolem_Fn_6633))
   	      ],
   	      [ holds(loc_at(Takeoutof31,Tloc30),
   		      Holds36)
   	      ]).
 */


%; A releases axiom states that if an agent puts a physical
%; object inside another physical object,
%; the first physical object's location will be released
%; from inertia:
% [agent,physobj1,physobj2,location,time]
% Releases(PutInside(agent,physobj1,physobj2),
%          At(physobj1,location),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',287).

 /*  axiom(releases(putInside(Agent, Physobj1, Physobj2), at(Physobj1, Location), Time),
       []).
 */

 /*  releases(putInside(PutinsideP_Num3_V,A,Putinside),
   	 at(A,Tloc),
   	 Releases).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',287).
releases(putInside(PutinsideP_Num3_V,A,Putinside),
	 loc_at(A,Tloc),
	 Releases).


%; A state constraint says that if a physical object is inside
%; another physical object and the second physical object is
%; at a location, the first physical object is also at the location:
% [physobj1,physobj2,location,time]
% HoldsAt(Inside(physobj1,physobj2),time) &
% HoldsAt(At(physobj2,location),time) ->
% HoldsAt(At(physobj1,location),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',294).

 /*  (   holds_at(inside(Physobj1, Physobj2), Time),
       holds_at(at(Physobj2, Location), Time)
   ->  holds_at(at(Physobj1, Location), Time)
   ).
 */
if inside(Physobj1, Physobj2)at Time, loc_at(Physobj2, Location)at Time then loc_at(Physobj1, Location)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',294).

 /*  reactive_rule([ holds(inside(Physobj1,Physobj2),Time),
   		holds(loc_at(Physobj2,Location),Time)
   	      ],
   	      [holds(loc_at(Physobj1,Location),Time)]).
 */


%; An effect axiom states that if an agent takes a physical
%; object out of another physical object,
%; the agent will be holding the first physical object:
% [agent,physobj1,physobj2,time]
% Initiates(TakeOutOf(agent,physobj1,physobj2),
%           Holding(agent,physobj1),
%           time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',302).

 /*  axiom(initiates(takeOutOf(Agent, Physobj1, Physobj2), holding(Agent, Physobj1), Time),
       []).
 */

 /*  initiates(takeOutOf(TakeoutofP_Num3_V,
   		    Holding,
   		    Takeoutof),
   	  holding(TakeoutofP_Num3_V,Holding),
   	  Initiates).
 */
takeOutOf(TakeoutofP_Num3_V, Holding, Takeoutof)initiates holding(TakeoutofP_Num3_V, Holding).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',302).

 /*  initiated(happens(takeOutOf(TakeoutofP_Num3_V,
   			    Holding,
   			    Takeoutof),
   		  Time_From,
   		  Time_Until),
   	  holding(TakeoutofP_Num3_V,Holding),
   	  []).
 */


%; On
%; physobj1 is on physobj2.

% fluent On(physobj,physobj)
 %  fluent(on(physobj,physobj)).
 %  fluent(on(physobj,physobj)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',309).
fluents([on/2]).
mpred_prop(on(physobj,physobj),fluent).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',312).
%; agent places physobj1 on physobj2.

% event PlaceOn(agent,physobj,physobj)
 %  event(placeOn(agent,physobj,physobj)).
 %  event(placeOn(agent,physobj,physobj)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',312).
actions([placeOn/3]).
mpred_prop(placeOn(agent,physobj,physobj),event).


%; agent takes physobj1 off of physobj2.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',315).
% event TakeOffOf(agent,physobj,physobj)
 %  event(takeOffOf(agent,physobj,physobj)).
 %  event(takeOffOf(agent,physobj,physobj)).
actions([takeOffOf/3]).
mpred_prop(takeOffOf(agent,physobj,physobj),event).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',317).
%; A state constraint says that a physical object cannot
%; be on itself:
% [physobj1,physobj2,time]
% HoldsAt(On(physobj1,physobj2),time) ->
% physobj1!=physobj2.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',319).

 /*  holds_at(on(Physobj1, Physobj2), Time) ->
       diff(Physobj1, Physobj2).
 */
if on(Physobj1, Physobj2)at Time then diff(Physobj1, Physobj2).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',319).

 /*  reactive_rule([holds(on(Physobj1,Physobj2),Time)],
   	      [diff(Physobj1,Physobj2)]).
 */


%; A state constraint says that if a physical object is
%; on another physical object, the second physical object
%; is not on the first physical object:
% [physobj1,physobj2,time]
% HoldsAt(On(physobj1,physobj2),time) ->
% !HoldsAt(On(physobj2,physobj1),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',326).

 /*  holds_at(on(Physobj1, Physobj2), Time) ->
       holds_at(neg(on(Physobj2, Physobj1)), Time).
 */
if on(Physobj1, Physobj2)at Time then not on(Physobj2, Physobj1)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',326).

 /*  reactive_rule([holds(on(Physobj1,Physobj2),Time)],
   	      [ holds(not(on(Physobj2,Physobj1)),
   		      Time)
   	      ]).
 */


%; An effect axiom states that if an agent places a physical
%; object on another physical object, the first
%; physical object will be on the second physical object:
% [agent,physobj1,physobj2,time]
% Initiates(PlaceOn(agent,physobj1,physobj2),
%           On(physobj1,physobj2),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',333).

 /*  axiom(initiates(placeOn(Agent, Physobj1, Physobj2), on(Physobj1, Physobj2), Time),
       []).
 */

 /*  initiates(placeOn(PlaceonP_Num3_V,A,Placeon),
   	  on(A,Placeon),
   	  Initiates).
 */
placeOn(PlaceonP_Num3_V, A, Placeon)initiates on(A, Placeon).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',333).

 /*  initiated(happens(placeOn(PlaceonP_Num3_V,A,Placeon),
   		  Time_From,
   		  Time_Until),
   	  on(A,Placeon),
   	  []).
 */


%; An effect axiom states that if an agent places a physical
%; object on another physical object, the agent will
%; no longer be holding the first physical object:
% [agent,physobj1,physobj2,time]
% Terminates(PlaceOn(agent,physobj1,physobj2),
%            Holding(agent,physobj1),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',340).

 /*  axiom(terminates(placeOn(Agent, Physobj1, Physobj2), holding(Agent, Physobj1), Time),
       []).
 */

 /*  terminates(placeOn(PlaceonP_Num3_V,Holding,Placeon),
   	   holding(PlaceonP_Num3_V,Holding),
   	   Terminates).
 */
placeOn(PlaceonP_Num3_V, Holding, Placeon)terminates holding(PlaceonP_Num3_V, Holding).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',340).

 /*  terminated(happens(placeOn(PlaceonP_Num3_V,
   			   Holding,
   			   Placeon),
   		   Time_From,
   		   Time_Until),
   	   holding(PlaceonP_Num3_V,Holding),
   	   []).
 */


%; A precondition axiom states that
%; for an agent to place a physical object on another
%; physical object,
%; the agent must be holding the first physical object
%; and there must be a location such that
%; the agent is at the location and
%; the second physical object is at the location:
%;[agent,physobj1,physobj2,time]
%;Happens(PlaceOn(agent,physobj1,physobj2),time) ->
%;HoldsAt(Holding(agent,physobj1),time) &
%;{location}
%; HoldsAt(At(agent,location),time) &
%; HoldsAt(At(physobj2,location),time).
%; An effect axiom states that
%; if an agent takes a physical object off of another
%; physical object, the first physical object
%; will no longer be on the second physical object:
% [agent,physobj1,physobj2,time]
% Terminates(TakeOffOf(agent,physobj1,physobj2),
%            On(physobj1,physobj2),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',362).

 /*  axiom(terminates(takeOffOf(Agent, Physobj1, Physobj2), on(Physobj1, Physobj2), Time),
       []).
 */

 /*  terminates(takeOffOf(TakeoffofP_Num3_V,A,Takeoffof),
   	   on(A,Takeoffof),
   	   Terminates).
 */
takeOffOf(TakeoffofP_Num3_V, A, Takeoffof)terminates on(A, Takeoffof).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',362).

 /*  terminated(happens(takeOffOf(TakeoffofP_Num3_V,
   			     A,
   			     Takeoffof),
   		   Time_From,
   		   Time_Until),
   	   on(A,Takeoffof),
   	   []).
 */


%; An effect axiom states that if an agent takes a physical
%; object off of another physical object,
%; the agent will be holding the first physical object:
% [agent,physobj1,physobj2,time]
% Initiates(TakeOffOf(agent,physobj1,physobj2),
%           Holding(agent,physobj1),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',369).

 /*  axiom(initiates(takeOffOf(Agent, Physobj1, Physobj2), holding(Agent, Physobj1), Time),
       []).
 */

 /*  initiates(takeOffOf(TakeoffofP_Num3_V,
   		    Holding,
   		    Takeoffof),
   	  holding(TakeoffofP_Num3_V,Holding),
   	  Initiates).
 */
takeOffOf(TakeoffofP_Num3_V, Holding, Takeoffof)initiates holding(TakeoffofP_Num3_V, Holding).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',369).

 /*  initiated(happens(takeOffOf(TakeoffofP_Num3_V,
   			    Holding,
   			    Takeoffof),
   		  Time_From,
   		  Time_Until),
   	  holding(TakeoffofP_Num3_V,Holding),
   	  []).
 */


%; A precondition axiom states that
%; for an agent to take a physical object off of another
%; physical object,
%; the first physical object must be on the second physical object
%; and there must be a location such that
%; the agent is at the location and
%; the first physical object is at the location:
%; the second physical object is at the location:
% [agent,physobj1,physobj2,time]
% Happens(TakeOffOf(agent,physobj1,physobj2),time) ->
% HoldsAt(On(physobj1,physobj2),time) &
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',381).
% {location}% 
%  HoldsAt(At(agent,location),time) &
%  HoldsAt(At(physobj1,location),time) &
%  HoldsAt(At(physobj2,location),time).
 %  clausify_pnf=exists([Location],  (happens(takeOffOf(Agent, Physobj1, Physobj2), Time)->holds_at(on(Physobj1, Physobj2), Time), holds_at(at(Agent, Location), Time), holds_at(at(Physobj1, Location), Time), holds_at(at(Physobj2, Location), Time))).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',384).

 /*  not(happens(takeOffOf(Agent, Physobj1, Physobj2), Time)) :-
       (   not(holds_at(on(Physobj1, Physobj2), Time))
       ;   not(holds_at(at(Agent, Exists_Location), Time))
       ;   not(holds_at(at(Physobj1, Exists_Location), Time))
       ;   not(holds_at(at(Physobj2, Exists_Location), Time))
       ),
       some(Exists_Location,
            '$kolem_Fn_67'(Agent, Physobj1, Physobj2, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',384).

 /*  fix_axiom_head(Time) ->
       [ not(happens(takeOffOf(Agent, Physobj1, Physobj2),
                     Time)),
          (->),
         not(takeOffOf(Agent, Physobj1, Physobj2))
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',384).

 /*  axiom(not(takeOffOf(Agent, Physobj1, Physobj2)),
       [  (not(on(Physobj1, Physobj2));not(at(Agent, Exists_Location));not(at(Physobj1, Exists_Location));not(at(Physobj2, Exists_Location))),
         some(Exists_Location,
              '$kolem_Fn_67'(Agent, Physobj1, Physobj2, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',384).

 /*  (   (   not(on(A, On))
       ;   not(at(Kolem_Fn_67P_Num4_V, Tloc))
       ;   not(at(A, Tloc))
       ;   not(at(On, Tloc))
       ),
       some(Tloc,
            '$kolem_Fn_67'(Kolem_Fn_67P_Num4_V,
                           A,
                           On,
                           Kolem_Fn_67))
   ->  not(takeOffOf(Kolem_Fn_67P_Num4_V, A, On))
   ).
 */
if (not on(A, On);not loc_at(Kolem_Fn_67P_Num4_V, Tloc);not loc_at(A, Tloc);not loc_at(On, Tloc)), some(Tloc, '$kolem_Fn_67'(Kolem_Fn_67P_Num4_V, A, On, Kolem_Fn_67))then not takeOffOf(Kolem_Fn_67P_Num4_V, A, On).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',384).

 /*   reactive_rule([  (not(on(A, On));not(loc_at(Kolem_Fn_67P_Num4_V, Tloc));not(loc_at(A, Tloc));not(loc_at(On, Tloc))),
                      some(Tloc,
                           '$kolem_Fn_67'(Kolem_Fn_67P_Num4_V,
                                          A,
                                          On,
                                          Kolem_Fn_67))
                    ],
                    [not(takeOffOf(Kolem_Fn_67P_Num4_V, A, On))]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',384).

 /*  holds_at(on(Physobj1, Physobj2), Time) :-
       happens(takeOffOf(Agent, Physobj1, Physobj2), Time),
       some(Exists_Location,
            '$kolem_Fn_67'(Agent, Physobj1, Physobj2, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',384).

 /*  fix_axiom_head(Time) ->
       [ holds_at(on(Physobj1, Physobj2), Time),
          (->),
         on(Physobj1, Physobj2)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',384).

 /*  axiom(on(Physobj1, Physobj2),
       [ takeOffOf(Agent, Physobj1, Physobj2),
         some(Exists_Location,
              '$kolem_Fn_67'(Agent, Physobj1, Physobj2, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',384).

 /*  (   takeOffOf(TakeoffofP_Num3_V, A, Takeoffof),
       some(_,
            '$kolem_Fn_67'(TakeoffofP_Num3_V,
                           A,
                           Takeoffof,
                           Kolem_Fn_6712))
   ->  on(A, Takeoffof)
   ).
 */
if takeOffOf(TakeoffofP_Num3_V, A, Takeoffof), some(_, '$kolem_Fn_67'(TakeoffofP_Num3_V, A, Takeoffof, Kolem_Fn_6712))then on(A, Takeoffof).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',384).

 /*  reactive_rule([ happens(takeOffOf(TakeoffofP_Num3_V,
   				  A,
   				  Takeoffof),
   			Time_From,
   			Time_Until),
   		some(_,
   		     '$kolem_Fn_67'(TakeoffofP_Num3_V,
   				    A,
   				    Takeoffof,
   				    Kolem_Fn_6712))
   	      ],
   	      [holds(on(A,Takeoffof),Holds)]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',384).

 /*  holds_at(at(Agent, Exists_Location), Time) :-
       happens(takeOffOf(Agent, Physobj1, Physobj2), Time),
       some(Exists_Location,
            '$kolem_Fn_67'(Agent, Physobj1, Physobj2, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',384).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Agent, Exists_Location), Time),
          (->),
         at(Agent, Exists_Location)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',384).

 /*  axiom(at(Agent, Exists_Location),
       [ takeOffOf(Agent, Physobj1, Physobj2),
         some(Exists_Location,
              '$kolem_Fn_67'(Agent, Physobj1, Physobj2, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',384).

 /*  (   takeOffOf(TakeoffofP_Num3_V18, A, Takeoffof17),
       some(Tloc16,
            '$kolem_Fn_67'(TakeoffofP_Num3_V18,
                           A,
                           Takeoffof17,
                           Kolem_Fn_6719))
   ->  at(TakeoffofP_Num3_V18, Tloc16)
   ).
 */
if takeOffOf(TakeoffofP_Num3_V18, A, Takeoffof17), some(Tloc16, '$kolem_Fn_67'(TakeoffofP_Num3_V18, A, Takeoffof17, Kolem_Fn_6719))then loc_at(TakeoffofP_Num3_V18, Tloc16).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',384).

 /*  reactive_rule([ happens(takeOffOf(TakeoffofP_Num3_V18,
   				  A,
   				  Takeoffof17),
   			Time_From20,
   			Time_Until21),
   		some(Tloc16,
   		     '$kolem_Fn_67'(TakeoffofP_Num3_V18,
   				    A,
   				    Takeoffof17,
   				    Kolem_Fn_6719))
   	      ],
   	      [ holds(loc_at(TakeoffofP_Num3_V18,Tloc16),
   		      Holds22)
   	      ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',384).

 /*  holds_at(at(Physobj1, Exists_Location), Time) :-
       happens(takeOffOf(Agent, Physobj1, Physobj2), Time),
       some(Exists_Location,
            '$kolem_Fn_67'(Agent, Physobj1, Physobj2, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',384).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Physobj1, Exists_Location), Time),
          (->),
         at(Physobj1, Exists_Location)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',384).

 /*  axiom(at(Physobj1, Exists_Location),
       [ takeOffOf(Agent, Physobj1, Physobj2),
         some(Exists_Location,
              '$kolem_Fn_67'(Agent, Physobj1, Physobj2, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',384).

 /*  (   takeOffOf(TakeoffofP_Num3_V25, A, Takeoffof24),
       some(Tloc23,
            '$kolem_Fn_67'(TakeoffofP_Num3_V25,
                           A,
                           Takeoffof24,
                           Kolem_Fn_6726))
   ->  at(A, Tloc23)
   ).
 */
if takeOffOf(TakeoffofP_Num3_V25, A, Takeoffof24), some(Tloc23, '$kolem_Fn_67'(TakeoffofP_Num3_V25, A, Takeoffof24, Kolem_Fn_6726))then loc_at(A, Tloc23).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',384).

 /*  reactive_rule([ happens(takeOffOf(TakeoffofP_Num3_V25,
   				  A,
   				  Takeoffof24),
   			Time_From27,
   			Time_Until28),
   		some(Tloc23,
   		     '$kolem_Fn_67'(TakeoffofP_Num3_V25,
   				    A,
   				    Takeoffof24,
   				    Kolem_Fn_6726))
   	      ],
   	      [holds(loc_at(A,Tloc23),Holds29)]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',384).

 /*  holds_at(at(Physobj2, Exists_Location), Time) :-
       happens(takeOffOf(Agent, Physobj1, Physobj2), Time),
       some(Exists_Location,
            '$kolem_Fn_67'(Agent, Physobj1, Physobj2, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',384).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Physobj2, Exists_Location), Time),
          (->),
         at(Physobj2, Exists_Location)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',384).

 /*  axiom(at(Physobj2, Exists_Location),
       [ takeOffOf(Agent, Physobj1, Physobj2),
         some(Exists_Location,
              '$kolem_Fn_67'(Agent, Physobj1, Physobj2, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',384).

 /*  (   takeOffOf(TakeoffofP_Num3_V32, A, Takeoffof31),
       some(Tloc30,
            '$kolem_Fn_67'(TakeoffofP_Num3_V32,
                           A,
                           Takeoffof31,
                           Kolem_Fn_6733))
   ->  at(Takeoffof31, Tloc30)
   ).
 */
if takeOffOf(TakeoffofP_Num3_V32, A, Takeoffof31), some(Tloc30, '$kolem_Fn_67'(TakeoffofP_Num3_V32, A, Takeoffof31, Kolem_Fn_6733))then loc_at(Takeoffof31, Tloc30).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',384).

 /*  reactive_rule([ happens(takeOffOf(TakeoffofP_Num3_V32,
   				  A,
   				  Takeoffof31),
   			Time_From34,
   			Time_Until35),
   		some(Tloc30,
   		     '$kolem_Fn_67'(TakeoffofP_Num3_V32,
   				    A,
   				    Takeoffof31,
   				    Kolem_Fn_6733))
   	      ],
   	      [ holds(loc_at(Takeoffof31,Tloc30),
   		      Holds36)
   	      ]).
 */


%; A releases axiom states that if an agent places a physical
%; object on another physical object,
%; the first physical object's location will be released
%; from inertia:
% [agent,physobj1,physobj2,location,time]
% Releases(PlaceOn(agent,physobj1,physobj2),
%          At(physobj1,location),
%          time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',393).

 /*  axiom(releases(placeOn(Agent, Physobj1, Physobj2), at(Physobj1, Location), Time),
       []).
 */

 /*  releases(placeOn(PlaceonP_Num3_V,A,Placeon),
   	 at(A,Tloc),
   	 Releases).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',393).
releases(placeOn(PlaceonP_Num3_V,A,Placeon),
	 loc_at(A,Tloc),
	 Releases).


%; A state constraint says that if a physical object is on
%; another physical object and the second physical object is
%; at a location, the first physical object is also at the location:
% [physobj1,physobj2,location,time]
% HoldsAt(On(physobj1,physobj2),time) &
% HoldsAt(At(physobj2,location),time) ->
% HoldsAt(At(physobj1,location),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',401).

 /*  (   holds_at(on(Physobj1, Physobj2), Time),
       holds_at(at(Physobj2, Location), Time)
   ->  holds_at(at(Physobj1, Location), Time)
   ).
 */
if on(Physobj1, Physobj2)at Time, loc_at(Physobj2, Location)at Time then loc_at(Physobj1, Location)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',401).

 /*  reactive_rule([ holds(on(Physobj1,Physobj2),Time),
   		holds(loc_at(Physobj2,Location),Time)
   	      ],
   	      [holds(loc_at(Physobj1,Location),Time)]).
 */

% fluent Near(agent,object)
 %  fluent(near(agent,object)).
 %  fluent(near(agent,object)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',405).
fluents([near/2]).
mpred_prop(near(agent,object),fluent).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',407).
% event WalkFromTo(agent,object,object)
 %  event(walkFromTo(agent,object,object)).
 %  event(walkFromTo(agent,object,object)).
actions([walkFromTo/3]).
mpred_prop(walkFromTo(agent,object,object),event).

% event WalkFrom(agent,object)
 %  event(walkFrom(agent,object)).
 %  event(walkFrom(agent,object)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',407).
actions([walkFrom/2]).
mpred_prop(walkFrom(agent,object),event).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',409).
% event RunFromTo(agent,object,object)
 %  event(runFromTo(agent,object,object)).
 %  event(runFromTo(agent,object,object)).
actions([runFromTo/3]).
mpred_prop(runFromTo(agent,object,object),event).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',411).
% [agent,object1,object2,time]
% Initiates(WalkFromTo(agent,object1,object2),
%           Near(agent,object2),
%           time).

 /*  axiom(initiates(walkFromTo(Agent, Object1, Object2), near(Agent, Object2), Time),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',411).

 /*  initiates(walkFromTo(WalkfromtoP_Num3_V,_,Walkfromto),
   	  near(WalkfromtoP_Num3_V,Walkfromto),
   	  Initiates).
 */
walkFromTo(WalkfromtoP_Num3_V, _, Walkfromto)initiates near(WalkfromtoP_Num3_V, Walkfromto).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',411).

 /*  initiated(happens(walkFromTo(WalkfromtoP_Num3_V,
   			     _,
   			     Walkfromto),
   		  Time_From,
   		  Time_Until),
   	  near(WalkfromtoP_Num3_V,Walkfromto),
   	  []).
 */


% [agent,object1,object2,time]
% Terminates(WalkFromTo(agent,object1,object2),
%            Near(agent,object1),
%            time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',417).

 /*  axiom(terminates(walkFromTo(Agent, Object1, Object2), near(Agent, Object1), Time),
       []).
 */

 /*  terminates(walkFromTo(WalkfromtoP_Num3_V,
   		      Near,
   		      Walkfromto),
   	   near(WalkfromtoP_Num3_V,Near),
   	   Terminates).
 */
walkFromTo(WalkfromtoP_Num3_V, Near, Walkfromto)terminates near(WalkfromtoP_Num3_V, Near).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',417).

 /*  terminated(happens(walkFromTo(WalkfromtoP_Num3_V,
   			      Near,
   			      Walkfromto),
   		   Time_From,
   		   Time_Until),
   	   near(WalkfromtoP_Num3_V,Near),
   	   []).
 */


% [agent,object1,object2,time]
% Happens(WalkFromTo(agent,object1,object2),time) ->
% {location}% 
% HoldsAt(At(agent,location),time) &
% HoldsAt(At(object1,location),time) &
% HoldsAt(At(object2,location),time).
 %  clausify_pnf=exists([Location],  (happens(walkFromTo(Agent, Object1, Object2), Time)->holds_at(at(Agent, Location), Time), holds_at(at(Object1, Location), Time), holds_at(at(Object2, Location), Time))).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',422).

 /*  not(happens(walkFromTo(Agent, Object1, Object2), Time)) :-
       (   not(holds_at(at(Agent, Exists_Location), Time))
       ;   not(holds_at(at(Object1, Exists_Location), Time))
       ;   not(holds_at(at(Object2, Exists_Location), Time))
       ),
       some(Exists_Location,
            '$kolem_Fn_68'(Agent, Object1, Object2, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',422).

 /*  fix_axiom_head(Time) ->
       [ not(happens(walkFromTo(Agent, Object1, Object2),
                     Time)),
          (->),
         not(walkFromTo(Agent, Object1, Object2))
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',422).

 /*  axiom(not(walkFromTo(Agent, Object1, Object2)),
       [  (not(at(Agent, Exists_Location));not(at(Object1, Exists_Location));not(at(Object2, Exists_Location))),
         some(Exists_Location,
              '$kolem_Fn_68'(Agent, Object1, Object2, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',422).

 /*  (   (   not(at(Kolem_Fn_68P_Num4_V, Tloc))
       ;   not(at(A, Tloc))
       ;   not(at(Walkfromto, Tloc))
       ),
       some(Tloc,
            '$kolem_Fn_68'(Kolem_Fn_68P_Num4_V,
                           A,
                           Walkfromto,
                           Kolem_Fn_68))
   ->  not(walkFromTo(Kolem_Fn_68P_Num4_V, A, Walkfromto))
   ).
 */
if (not loc_at(Kolem_Fn_68P_Num4_V, Tloc);not loc_at(A, Tloc);not loc_at(Walkfromto, Tloc)), some(Tloc, '$kolem_Fn_68'(Kolem_Fn_68P_Num4_V, A, Walkfromto, Kolem_Fn_68))then not walkFromTo(Kolem_Fn_68P_Num4_V, A, Walkfromto).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',422).

 /*   reactive_rule([  (not(loc_at(Kolem_Fn_68P_Num4_V, Tloc));not(loc_at(A, Tloc));not(loc_at(Walkfromto, Tloc))),
                      some(Tloc,
                           '$kolem_Fn_68'(Kolem_Fn_68P_Num4_V,
                                          A,
                                          Walkfromto,
                                          Kolem_Fn_68))
                    ],
                    [ not(walkFromTo(Kolem_Fn_68P_Num4_V,
                                     A,
                                     Walkfromto))
                    ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',422).

 /*  holds_at(at(Agent, Exists_Location), Time) :-
       happens(walkFromTo(Agent, Object1, Object2), Time),
       some(Exists_Location,
            '$kolem_Fn_68'(Agent, Object1, Object2, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',422).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Agent, Exists_Location), Time),
          (->),
         at(Agent, Exists_Location)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',422).

 /*  axiom(at(Agent, Exists_Location),
       [ walkFromTo(Agent, Object1, Object2),
         some(Exists_Location,
              '$kolem_Fn_68'(Agent, Object1, Object2, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',422).

 /*  (   walkFromTo(WalkfromtoP_Num3_V, A, Walkfromto11),
       some(Tloc10,
            '$kolem_Fn_68'(WalkfromtoP_Num3_V,
                           A,
                           Walkfromto11,
                           Kolem_Fn_6813))
   ->  at(WalkfromtoP_Num3_V, Tloc10)
   ).
 */
if walkFromTo(WalkfromtoP_Num3_V, A, Walkfromto11), some(Tloc10, '$kolem_Fn_68'(WalkfromtoP_Num3_V, A, Walkfromto11, Kolem_Fn_6813))then loc_at(WalkfromtoP_Num3_V, Tloc10).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',422).

 /*  reactive_rule([ happens(walkFromTo(WalkfromtoP_Num3_V,
   				   A,
   				   Walkfromto11),
   			Time_From,
   			Time_Until),
   		some(Tloc10,
   		     '$kolem_Fn_68'(WalkfromtoP_Num3_V,
   				    A,
   				    Walkfromto11,
   				    Kolem_Fn_6813))
   	      ],
   	      [ holds(loc_at(WalkfromtoP_Num3_V,Tloc10),
   		      Holds)
   	      ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',422).

 /*  holds_at(at(Object1, Exists_Location), Time) :-
       happens(walkFromTo(Agent, Object1, Object2), Time),
       some(Exists_Location,
            '$kolem_Fn_68'(Agent, Object1, Object2, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',422).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Object1, Exists_Location), Time),
          (->),
         at(Object1, Exists_Location)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',422).

 /*  axiom(at(Object1, Exists_Location),
       [ walkFromTo(Agent, Object1, Object2),
         some(Exists_Location,
              '$kolem_Fn_68'(Agent, Object1, Object2, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',422).

 /*  (   walkFromTo(WalkfromtoP_Num3_V19, A, Walkfromto18),
       some(Tloc17,
            '$kolem_Fn_68'(WalkfromtoP_Num3_V19,
                           A,
                           Walkfromto18,
                           Kolem_Fn_6820))
   ->  at(A, Tloc17)
   ).
 */
if walkFromTo(WalkfromtoP_Num3_V19, A, Walkfromto18), some(Tloc17, '$kolem_Fn_68'(WalkfromtoP_Num3_V19, A, Walkfromto18, Kolem_Fn_6820))then loc_at(A, Tloc17).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',422).

 /*  reactive_rule([ happens(walkFromTo(WalkfromtoP_Num3_V19,
   				   A,
   				   Walkfromto18),
   			Time_From21,
   			Time_Until22),
   		some(Tloc17,
   		     '$kolem_Fn_68'(WalkfromtoP_Num3_V19,
   				    A,
   				    Walkfromto18,
   				    Kolem_Fn_6820))
   	      ],
   	      [holds(loc_at(A,Tloc17),Holds23)]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',422).

 /*  holds_at(at(Object2, Exists_Location), Time) :-
       happens(walkFromTo(Agent, Object1, Object2), Time),
       some(Exists_Location,
            '$kolem_Fn_68'(Agent, Object1, Object2, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',422).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Object2, Exists_Location), Time),
          (->),
         at(Object2, Exists_Location)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',422).

 /*  axiom(at(Object2, Exists_Location),
       [ walkFromTo(Agent, Object1, Object2),
         some(Exists_Location,
              '$kolem_Fn_68'(Agent, Object1, Object2, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',422).

 /*  (   walkFromTo(WalkfromtoP_Num3_V26, A, Walkfromto25),
       some(Tloc24,
            '$kolem_Fn_68'(WalkfromtoP_Num3_V26,
                           A,
                           Walkfromto25,
                           Kolem_Fn_6827))
   ->  at(Walkfromto25, Tloc24)
   ).
 */
if walkFromTo(WalkfromtoP_Num3_V26, A, Walkfromto25), some(Tloc24, '$kolem_Fn_68'(WalkfromtoP_Num3_V26, A, Walkfromto25, Kolem_Fn_6827))then loc_at(Walkfromto25, Tloc24).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',422).

 /*  reactive_rule([ happens(walkFromTo(WalkfromtoP_Num3_V26,
   				   A,
   				   Walkfromto25),
   			Time_From28,
   			Time_Until29),
   		some(Tloc24,
   		     '$kolem_Fn_68'(WalkfromtoP_Num3_V26,
   				    A,
   				    Walkfromto25,
   				    Kolem_Fn_6827))
   	      ],
   	      [ holds(loc_at(Walkfromto25,Tloc24),
   		      Holds30)
   	      ]).
 */


% [agent,object1,object2,time]
% Initiates(RunFromTo(agent,object1,object2),
%           Near(agent,object2),
%           time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',429).

 /*  axiom(initiates(runFromTo(Agent, Object1, Object2), near(Agent, Object2), Time),
       []).
 */

 /*  initiates(runFromTo(RunfromtoP_Num3_V,_,Runfromto),
   	  near(RunfromtoP_Num3_V,Runfromto),
   	  Initiates).
 */
runFromTo(RunfromtoP_Num3_V, _, Runfromto)initiates near(RunfromtoP_Num3_V, Runfromto).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',429).

 /*  initiated(happens(runFromTo(RunfromtoP_Num3_V,
   			    _,
   			    Runfromto),
   		  Time_From,
   		  Time_Until),
   	  near(RunfromtoP_Num3_V,Runfromto),
   	  []).
 */


% [agent,object1,object2,time]
% Terminates(RunFromTo(agent,object1,object2),
%            Near(agent,object1),
%            time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',434).

 /*  axiom(terminates(runFromTo(Agent, Object1, Object2), near(Agent, Object1), Time),
       []).
 */

 /*  terminates(runFromTo(RunfromtoP_Num3_V,
   		     Near,
   		     Runfromto),
   	   near(RunfromtoP_Num3_V,Near),
   	   Terminates).
 */
runFromTo(RunfromtoP_Num3_V, Near, Runfromto)terminates near(RunfromtoP_Num3_V, Near).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',434).

 /*  terminated(happens(runFromTo(RunfromtoP_Num3_V,
   			     Near,
   			     Runfromto),
   		   Time_From,
   		   Time_Until),
   	   near(RunfromtoP_Num3_V,Near),
   	   []).
 */


% [agent,object1,object2,time]
% Happens(RunFromTo(agent,object1,object2),time) ->
% {location}% 
% HoldsAt(At(agent,location),time) &
% HoldsAt(At(object1,location),time) &
% HoldsAt(At(object2,location),time).
 %  clausify_pnf=exists([Location],  (happens(runFromTo(Agent, Object1, Object2), Time)->holds_at(at(Agent, Location), Time), holds_at(at(Object1, Location), Time), holds_at(at(Object2, Location), Time))).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',439).

 /*  not(happens(runFromTo(Agent, Object1, Object2), Time)) :-
       (   not(holds_at(at(Agent, Exists_Location), Time))
       ;   not(holds_at(at(Object1, Exists_Location), Time))
       ;   not(holds_at(at(Object2, Exists_Location), Time))
       ),
       some(Exists_Location,
            '$kolem_Fn_69'(Agent, Object1, Object2, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',439).

 /*  fix_axiom_head(Time) ->
       [ not(happens(runFromTo(Agent, Object1, Object2),
                     Time)),
          (->),
         not(runFromTo(Agent, Object1, Object2))
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',439).

 /*  axiom(not(runFromTo(Agent, Object1, Object2)),
       [  (not(at(Agent, Exists_Location));not(at(Object1, Exists_Location));not(at(Object2, Exists_Location))),
         some(Exists_Location,
              '$kolem_Fn_69'(Agent, Object1, Object2, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',439).

 /*  (   (   not(at(Kolem_Fn_69P_Num4_V, Tloc))
       ;   not(at(A, Tloc))
       ;   not(at(Runfromto, Tloc))
       ),
       some(Tloc,
            '$kolem_Fn_69'(Kolem_Fn_69P_Num4_V,
                           A,
                           Runfromto,
                           Kolem_Fn_69))
   ->  not(runFromTo(Kolem_Fn_69P_Num4_V, A, Runfromto))
   ).
 */
if (not loc_at(Kolem_Fn_69P_Num4_V, Tloc);not loc_at(A, Tloc);not loc_at(Runfromto, Tloc)), some(Tloc, '$kolem_Fn_69'(Kolem_Fn_69P_Num4_V, A, Runfromto, Kolem_Fn_69))then not runFromTo(Kolem_Fn_69P_Num4_V, A, Runfromto).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',439).

 /*   reactive_rule([  (not(loc_at(Kolem_Fn_69P_Num4_V, Tloc));not(loc_at(A, Tloc));not(loc_at(Runfromto, Tloc))),
                      some(Tloc,
                           '$kolem_Fn_69'(Kolem_Fn_69P_Num4_V,
                                          A,
                                          Runfromto,
                                          Kolem_Fn_69))
                    ],
                    [ not(runFromTo(Kolem_Fn_69P_Num4_V,
                                    A,
                                    Runfromto))
                    ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',439).

 /*  holds_at(at(Agent, Exists_Location), Time) :-
       happens(runFromTo(Agent, Object1, Object2), Time),
       some(Exists_Location,
            '$kolem_Fn_69'(Agent, Object1, Object2, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',439).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Agent, Exists_Location), Time),
          (->),
         at(Agent, Exists_Location)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',439).

 /*  axiom(at(Agent, Exists_Location),
       [ runFromTo(Agent, Object1, Object2),
         some(Exists_Location,
              '$kolem_Fn_69'(Agent, Object1, Object2, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',439).

 /*  (   runFromTo(RunfromtoP_Num3_V, A, Runfromto11),
       some(Tloc10,
            '$kolem_Fn_69'(RunfromtoP_Num3_V,
                           A,
                           Runfromto11,
                           Kolem_Fn_6913))
   ->  at(RunfromtoP_Num3_V, Tloc10)
   ).
 */
if runFromTo(RunfromtoP_Num3_V, A, Runfromto11), some(Tloc10, '$kolem_Fn_69'(RunfromtoP_Num3_V, A, Runfromto11, Kolem_Fn_6913))then loc_at(RunfromtoP_Num3_V, Tloc10).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',439).

 /*  reactive_rule([ happens(runFromTo(RunfromtoP_Num3_V,
   				  A,
   				  Runfromto11),
   			Time_From,
   			Time_Until),
   		some(Tloc10,
   		     '$kolem_Fn_69'(RunfromtoP_Num3_V,
   				    A,
   				    Runfromto11,
   				    Kolem_Fn_6913))
   	      ],
   	      [ holds(loc_at(RunfromtoP_Num3_V,Tloc10),
   		      Holds)
   	      ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',439).

 /*  holds_at(at(Object1, Exists_Location), Time) :-
       happens(runFromTo(Agent, Object1, Object2), Time),
       some(Exists_Location,
            '$kolem_Fn_69'(Agent, Object1, Object2, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',439).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Object1, Exists_Location), Time),
          (->),
         at(Object1, Exists_Location)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',439).

 /*  axiom(at(Object1, Exists_Location),
       [ runFromTo(Agent, Object1, Object2),
         some(Exists_Location,
              '$kolem_Fn_69'(Agent, Object1, Object2, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',439).

 /*  (   runFromTo(RunfromtoP_Num3_V19, A, Runfromto18),
       some(Tloc17,
            '$kolem_Fn_69'(RunfromtoP_Num3_V19,
                           A,
                           Runfromto18,
                           Kolem_Fn_6920))
   ->  at(A, Tloc17)
   ).
 */
if runFromTo(RunfromtoP_Num3_V19, A, Runfromto18), some(Tloc17, '$kolem_Fn_69'(RunfromtoP_Num3_V19, A, Runfromto18, Kolem_Fn_6920))then loc_at(A, Tloc17).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',439).

 /*  reactive_rule([ happens(runFromTo(RunfromtoP_Num3_V19,
   				  A,
   				  Runfromto18),
   			Time_From21,
   			Time_Until22),
   		some(Tloc17,
   		     '$kolem_Fn_69'(RunfromtoP_Num3_V19,
   				    A,
   				    Runfromto18,
   				    Kolem_Fn_6920))
   	      ],
   	      [holds(loc_at(A,Tloc17),Holds23)]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',439).

 /*  holds_at(at(Object2, Exists_Location), Time) :-
       happens(runFromTo(Agent, Object1, Object2), Time),
       some(Exists_Location,
            '$kolem_Fn_69'(Agent, Object1, Object2, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',439).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Object2, Exists_Location), Time),
          (->),
         at(Object2, Exists_Location)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',439).

 /*  axiom(at(Object2, Exists_Location),
       [ runFromTo(Agent, Object1, Object2),
         some(Exists_Location,
              '$kolem_Fn_69'(Agent, Object1, Object2, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',439).

 /*  (   runFromTo(RunfromtoP_Num3_V26, A, Runfromto25),
       some(Tloc24,
            '$kolem_Fn_69'(RunfromtoP_Num3_V26,
                           A,
                           Runfromto25,
                           Kolem_Fn_6927))
   ->  at(Runfromto25, Tloc24)
   ).
 */
if runFromTo(RunfromtoP_Num3_V26, A, Runfromto25), some(Tloc24, '$kolem_Fn_69'(RunfromtoP_Num3_V26, A, Runfromto25, Kolem_Fn_6927))then loc_at(Runfromto25, Tloc24).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',439).

 /*  reactive_rule([ happens(runFromTo(RunfromtoP_Num3_V26,
   				  A,
   				  Runfromto25),
   			Time_From28,
   			Time_Until29),
   		some(Tloc24,
   		     '$kolem_Fn_69'(RunfromtoP_Num3_V26,
   				    A,
   				    Runfromto25,
   				    Kolem_Fn_6927))
   	      ],
   	      [ holds(loc_at(Runfromto25,Tloc24),
   		      Holds30)
   	      ]).
 */


% [agent,object,time]
% Terminates(WalkFrom(agent,object),
%            Near(agent,object),
%            time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',446).

 /*  axiom(terminates(walkFrom(Agent, Object), near(Agent, Object), Time),
       []).
 */

 /*  terminates(walkFrom(A,Walkfrom),
   	   near(A,Walkfrom),
   	   Terminates).
 */
walkFrom(A, Walkfrom)terminates near(A, Walkfrom).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',446).

 /*  terminated(happens(walkFrom(A,Walkfrom),
   		   Time_From,
   		   Time_Until),
   	   near(A,Walkfrom),
   	   []).
 */


% [agent,object,location,door,time]
% HoldsAt(Near(agent,object),time) &
% HoldsAt(At(agent,location),time) &
% HoldsAt(At(object,location),time) &
% Side1(door)=location &
% Happens(WalkThroughDoor12(agent,door),time) ->
% Happens(WalkFrom(agent,object),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',451).

 /*  (   holds_at(near(Agent, Object), Time),
       holds_at(at(Agent, Location), Time),
       holds_at(at(Object, Location), Time),
       side1Pred(Door, Location),
       happens(walkThroughDoor12(Agent, Door), Time)
   ->  happens(walkFrom(Agent, Object), Time)
   ).
 */
if near(Agent, Object)at Time, loc_at(Agent, Location)at Time, loc_at(Object, Location)at Time, side1Pred(Door, Location), happens(walkThroughDoor12(Agent, Door), Time)then happens(walkFrom(Agent, Object), Time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',451).

 /*  reactive_rule([ holds(near(Agent,Object),Time),
   		holds(loc_at(Agent,Location),Time),
   		holds(loc_at(Object,Location),Time),
   		side1Pred(Door,Location),
   		happens(walkThroughDoor12(Agent,Door),
   			Time)
   	      ],
   	      [happens(walkFrom(Agent,Object),Time)]).
 */


% [agent,object,location,door,time]
% HoldsAt(Near(agent,object),time) &
% HoldsAt(At(agent,location),time) &
% HoldsAt(At(object,location),time) &
% Side2(door)=location &
% Happens(WalkThroughDoor21(agent,door),time) ->
% Happens(WalkFrom(agent,object),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',459).

 /*  (   holds_at(near(Agent, Object), Time),
       holds_at(at(Agent, Location), Time),
       holds_at(at(Object, Location), Time),
       side2Pred(Door, Location),
       happens(walkThroughDoor21(Agent, Door), Time)
   ->  happens(walkFrom(Agent, Object), Time)
   ).
 */
if near(Agent, Object)at Time, loc_at(Agent, Location)at Time, loc_at(Object, Location)at Time, side2Pred(Door, Location), happens(walkThroughDoor21(Agent, Door), Time)then happens(walkFrom(Agent, Object), Time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',459).

 /*  reactive_rule([ holds(near(Agent,Object),Time),
   		holds(loc_at(Agent,Location),Time),
   		holds(loc_at(Object,Location),Time),
   		side2Pred(Door,Location),
   		happens(walkThroughDoor21(Agent,Door),
   			Time)
   	      ],
   	      [happens(walkFrom(Agent,Object),Time)]).
 */


% [agent,object,room,staircase,time]
% HoldsAt(Near(agent,object),time) &
% HoldsAt(At(agent,room),time) &
% HoldsAt(At(object,room),time) &
% Side1(staircase)=room &
% Happens(WalkUpStaircase(agent,staircase),time) ->
% Happens(WalkFrom(agent,object),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',467).

 /*  (   holds_at(near(Agent, Object), Time),
       holds_at(at(Agent, Room), Time),
       holds_at(at(Object, Room), Time),
       side1Pred(Staircase, Room),
       happens(walkUpStaircase(Agent, Staircase), Time)
   ->  happens(walkFrom(Agent, Object), Time)
   ).
 */
if near(Agent, Object)at Time, loc_at(Agent, Room)at Time, loc_at(Object, Room)at Time, side1Pred(Staircase, Room), happens(walkUpStaircase(Agent, Staircase), Time)then happens(walkFrom(Agent, Object), Time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',467).

 /*  reactive_rule([ holds(near(Agent,Object),Time),
   		holds(loc_at(Agent,Room),Time),
   		holds(loc_at(Object,Room),Time),
   		side1Pred(Staircase,Room),
   		happens(walkUpStaircase(Agent,Staircase),
   			Time)
   	      ],
   	      [happens(walkFrom(Agent,Object),Time)]).
 */


% [agent,object,room,staircase,time]
% HoldsAt(Near(agent,object),time) &
% HoldsAt(At(agent,room),time) &
% HoldsAt(At(object,room),time) &
% Side2(staircase)=room &
% Happens(WalkDownStaircase(agent,staircase),time) ->
% Happens(WalkFrom(agent,object),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',475).

 /*  (   holds_at(near(Agent, Object), Time),
       holds_at(at(Agent, Room), Time),
       holds_at(at(Object, Room), Time),
       side2Pred(Staircase, Room),
       happens(walkDownStaircase(Agent, Staircase), Time)
   ->  happens(walkFrom(Agent, Object), Time)
   ).
 */
if near(Agent, Object)at Time, loc_at(Agent, Room)at Time, loc_at(Object, Room)at Time, side2Pred(Staircase, Room), happens(walkDownStaircase(Agent, Staircase), Time)then happens(walkFrom(Agent, Object), Time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',475).

 /*  reactive_rule([ holds(near(Agent,Object),Time),
   		holds(loc_at(Agent,Room),Time),
   		holds(loc_at(Object,Room),Time),
   		side2Pred(Staircase,Room),
   		happens(walkDownStaircase(Agent,Staircase),
   			Time)
   	      ],
   	      [happens(walkFrom(Agent,Object),Time)]).
 */


%; End of file.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',481).
:- endif.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',36).
% load answers/Mueller2004c/RTSpaceM.e
:- if(is_e_toplevel).
:- cond_convert_e(changed, 'answers/Mueller2004c/RTSpaceM.e').
 %  loading(changed,'/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e').
%;
%; Copyright (c) 2005 IBM Corporation and others.
%; All rights reserved. This program and the accompanying materials
%; are made available under the terms of the Common Public License v1.0
%; which accompanies this distribution, and is available at
%; http://www.eclipse.org/legal/cpl-v10.html
%;
%; Contributors:
%; IBM - Initial implementation
%;
%; RTSpace: room-scale topological space
%;
%; We use topological and metric representations of space,
%; at two levels of granularity---room-scale and object-scale.
%; The RTSpace representation deals with topological space at
%; the scale of rooms and outdoor locations.
%; This representation of space consists of locations, which
%; are connected by portals. There are two types of locations:
%; rooms and outside areas (outsides).
%;
%; object is at location.

% fluent At(object,location)
 %  fluent(at(object,location)).
 %  fluent(at(object,location)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',22).
fluents([loc_at/2]).
 %  mpred_prop(at(object,location),fluent).
mpred_prop(loc_at(object,location),fluent).

% manualrelease At
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',24).

 /*  axiom(manualrelease(at),
       []).
 */
manualrelease(at).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',26).
% [object1,location,time]
% (% {object2} PartOf(object1,object2)) ->
% ReleasedAt(At(object1,location),time).
 %  clausify_pnf=exists([Object2],  (partOf(Object1, Object2)->releasedAt(at(Object1, Location), Time))).

 /*  releasedAt(at(Object1, Location), Time) :-
       partOf(Object1, Exists_Object2),
       some(Exists_Object2,
            '$kolem_Fn_70'(Object1, Location, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',26).

 /*  axiom(releasedAt(at(Object1, Location), Time),
       [ partOf(Object1, Exists_Object2),
         some(Exists_Object2,
              '$kolem_Fn_70'(Object1, Location, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',26).

 /*  (   partOf(Kolem_Fn_70P_Num3_V, Partof),
       some(Partof,
            '$kolem_Fn_70'(Kolem_Fn_70P_Num3_V, Tloc, Time_At))
   ->  releasedAt(at(Kolem_Fn_70P_Num3_V, Tloc), Time_At)
   ).
 */
if partOf(Kolem_Fn_70P_Num3_V, Partof), some(Partof, '$kolem_Fn_70'(Kolem_Fn_70P_Num3_V, Tloc, Time_At))then releasedAt(loc_at(Kolem_Fn_70P_Num3_V, Tloc), Time_At).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',26).

 /*  reactive_rule([ partOf(Kolem_Fn_70P_Num3_V,Partof),
   		some(Partof,
   		     '$kolem_Fn_70'(Kolem_Fn_70P_Num3_V,
   				    Tloc,
   				    Time_At))
   	      ],
   	      [ releasedAt(loc_at(Kolem_Fn_70P_Num3_V,Tloc),
   			   Time_At)
   	      ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',26).

 /*  not(partOf(Object1, Exists_Object2)) :-
       not(releasedAt(at(Object1, Location), Time)),
       some(Exists_Object2,
            '$kolem_Fn_70'(Object1, Location, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',26).

 /*  axiom(not(partOf(Object1, Exists_Object2)),
       [ not(releasedAt(at(Object1, Location), Time)),
         some(Exists_Object2,
              '$kolem_Fn_70'(Object1, Location, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',26).

 /*  (   not(releasedAt(at(Kolem_Fn_70P_Num3_V11, Tloc9),
                      Time_At10)),
       some(Partof12,
            '$kolem_Fn_70'(Kolem_Fn_70P_Num3_V11, Tloc9, Time_At10))
   ->  not(partOf(Kolem_Fn_70P_Num3_V11, Partof12))
   ).
 */
if not releasedAt(loc_at(Kolem_Fn_70P_Num3_V11, Tloc9), Time_At10), some(Partof12, '$kolem_Fn_70'(Kolem_Fn_70P_Num3_V11, Tloc9, Time_At10))then not partOf(Kolem_Fn_70P_Num3_V11, Partof12).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',26).

 /*  reactive_rule([ not(releasedAt(loc_at(Kolem_Fn_70P_Num3_V11,
   				      Tloc9),
   			       Time_At10)),
   		some(Partof12,
   		     '$kolem_Fn_70'(Kolem_Fn_70P_Num3_V11,
   				    Tloc9,
   				    Time_At10))
   	      ],
   	      [not(partOf(Kolem_Fn_70P_Num3_V11,Partof12))]).
 */


%; A state constraint says that an object
%; is at one location at a time:
% [object,location1,location2,time]
% HoldsAt(At(object,location1),time) &
% HoldsAt(At(object,location2),time) ->
% location1=location2.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',32).

 /*  (   holds_at(at(Object, Location1), Time),
       holds_at(at(Object, Location2), Time)
   ->  equals(Location1, Location2)
   ).
 */
if loc_at(Object, Location1)at Time, loc_at(Object, Location2)at Time then equals(Location1, Location2).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',32).

 /*  reactive_rule([ holds(loc_at(Object,Location1),Time),
   		holds(loc_at(Object,Location2),Time)
   	      ],
   	      [equals(Location1,Location2)]).
 */


%; connectivity
%; Side one of portal is location.

% function Side1(portal): location
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',39).

 /*  axiom(function_argtypes(Function_ArgtypesP_Num3_V, side1(portal), location),
       []).
 */
function_argtypes(Function_ArgtypesP_Num3_V1,
		  side1(portal),
		  location).
 %  predicate(side1Pred(portal,location)).
 %  predicate(side1Pred(portal,location)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',39).
predicates([side1Pred/2]).
mpred_prop(side1Pred(portal,location),predicate).

 /*  axiom(functional_predicate(side1, side1Pred),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',39).
functional_predicate(side1,side1Pred).
resultIsa(side1,location).
%; Side two of portal is location.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',42).
% function Side2(portal): location

 /*  axiom(function_argtypes(Function_ArgtypesP_Num3_V, side2(portal), location),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',42).
function_argtypes(Function_ArgtypesP_Num3_V1,
		  side2(portal),
		  location).
 %  predicate(side2Pred(portal,location)).
 %  predicate(side2Pred(portal,location)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',42).
predicates([side2Pred/2]).
mpred_prop(side2Pred(portal,location),predicate).

 /*  axiom(functional_predicate(side2, side2Pred),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',42).
functional_predicate(side2,side2Pred).
resultIsa(side2,location).
%; The building of room is building.

% function BuildingOf(room): building
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',44).

 /*  axiom(function_argtypes(Function_ArgtypesP_Num3_V, buildingOf(room), building),
       []).
 */
function_argtypes(Function_ArgtypesP_Num3_V1,
		  buildingOf(room),
		  building).
 %  predicate(building(room,building)).
 %  predicate(building(room,building)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',44).
predicates([building/2]).
mpred_prop(building(room,building),predicate).

 /*  axiom(functional_predicate(buildingOf, building),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',44).
functional_predicate(buildingOf,building).
resultIsa(buildingOf,building).
%; object is at a location that has portal.

% fluent NearPortal(object,portal)
 %  fluent(nearPortal(object,portal)).
 %  fluent(nearPortal(object,portal)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',47).
fluents([nearPortal/2]).
mpred_prop(nearPortal(object,portal),fluent).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',49).
% noninertial NearPortal
noninertial(nearPortal).
%; A state constraint says that an object is near
%; a portal if and only if there is a location such that
%; the object is at the location and one of the sides
%; of the portal is the location:
% [object,portal,time]
% HoldsAt(NearPortal(object,portal),time) <->
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',55).
% {location}% 
%  (Side1(portal)=location|
%   Side2(portal)=location) &
%  HoldsAt(At(object,location),time).
 %  clausify_pnf=exists([Location], <->(holds_at(nearPortal(Object, Portal), Time),  ((side1Pred(Portal, Location);side2Pred(Portal, Location)), holds_at(at(Object, Location), Time)))).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  not(holds_at(nearPortal(Object, Portal), Time)) :-
       (   not(side1Pred(Portal, Exists_Location)),
           not(side2Pred(Portal, Exists_Location))
       ;   not(holds_at(at(Object, Exists_Location), Time))
       ),
       some(Exists_Location,
            '$kolem_Fn_71'(Object, Portal, Time)).
 */
 %  axiom(not(nearPortal(Object, Portal)), [(not(side1Pred(Portal, Exists_Location)), not(side2Pred(Portal, Exists_Location));not(at(Object, Exists_Location))), some(Exists_Location, '$kolem_Fn_71'(Object, Portal, Time))]).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  (   (   not(side1Pred(Nearportal, Tloc)),
           not(side2Pred(Nearportal, Tloc))
       ;   not(at(Kolem_Fn_71P_Num3_V, Tloc))
       ),
       some(Tloc,
            '$kolem_Fn_71'(Kolem_Fn_71P_Num3_V,
                           Nearportal,
                           Kolem_Fn_71))
   ->  not(nearPortal(Kolem_Fn_71P_Num3_V, Nearportal))
   ).
 */
if (not side1Pred(Nearportal, Tloc), not side2Pred(Nearportal, Tloc);not loc_at(Kolem_Fn_71P_Num3_V, Tloc)), some(Tloc, '$kolem_Fn_71'(Kolem_Fn_71P_Num3_V, Nearportal, Kolem_Fn_71))then not nearPortal(Kolem_Fn_71P_Num3_V, Nearportal).
 %  reactive_rule([(not(side1Pred(Nearportal, Tloc)), not(side2Pred(Nearportal, Tloc));not(loc_at(Kolem_Fn_71P_Num3_V, Tloc))), some(Tloc, '$kolem_Fn_71'(Kolem_Fn_71P_Num3_V, Nearportal, Kolem_Fn_71))], [holds(not(nearPortal(Kolem_Fn_71P_Num3_V, Nearportal)), Holds)]).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  side1Pred(Portal, Exists_Location) :-
       not(side2Pred(Portal, Exists_Location)),
       holds_at(nearPortal(Object, Portal), Time),
       some(Exists_Location,
            '$kolem_Fn_71'(Object, Portal, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  fix_axiom_head(Time) ->
       [ holds_at(nearPortal(Object, Portal), Time),
          (->),
         nearPortal(Object, Portal)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  axiom(side1Pred(Portal, Exists_Location),
       [ not(side2Pred(Portal, Exists_Location)),
         nearPortal(Object, Portal),
         some(Exists_Location,
              '$kolem_Fn_71'(Object, Portal, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  (   not(side2Pred(Nearportal11, Side2pred)),
       nearPortal(Kolem_Fn_71P_Num3_V13, Nearportal11),
       some(Side2pred,
            '$kolem_Fn_71'(Kolem_Fn_71P_Num3_V13,
                           Nearportal11,
                           Kolem_Fn_7112))
   ->  side1Pred(Nearportal11, Side2pred)
   ).
 */
if not side2Pred(Nearportal11, Side2pred), nearPortal(Kolem_Fn_71P_Num3_V13, Nearportal11), some(Side2pred, '$kolem_Fn_71'(Kolem_Fn_71P_Num3_V13, Nearportal11, Kolem_Fn_7112))then side1Pred(Nearportal11, Side2pred).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  reactive_rule([ not(side2Pred(Nearportal11,Side2pred)),
   		holds(nearPortal(Kolem_Fn_71P_Num3_V13,
   				 Nearportal11),
   		      Holds14),
   		some(Side2pred,
   		     '$kolem_Fn_71'(Kolem_Fn_71P_Num3_V13,
   				    Nearportal11,
   				    Kolem_Fn_7112))
   	      ],
   	      [side1Pred(Nearportal11,Side2pred)]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  side2Pred(Portal, Exists_Location) :-
       not(side1Pred(Portal, Exists_Location)),
       holds_at(nearPortal(Object, Portal), Time),
       some(Exists_Location,
            '$kolem_Fn_71'(Object, Portal, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  fix_axiom_head(Time) ->
       [ holds_at(nearPortal(Object, Portal), Time),
          (->),
         nearPortal(Object, Portal)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  axiom(side2Pred(Portal, Exists_Location),
       [ not(side1Pred(Portal, Exists_Location)),
         nearPortal(Object, Portal),
         some(Exists_Location,
              '$kolem_Fn_71'(Object, Portal, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  (   not(side1Pred(Nearportal16, Side1pred)),
       nearPortal(Kolem_Fn_71P_Num3_V18, Nearportal16),
       some(Side1pred,
            '$kolem_Fn_71'(Kolem_Fn_71P_Num3_V18,
                           Nearportal16,
                           Kolem_Fn_7117))
   ->  side2Pred(Nearportal16, Side1pred)
   ).
 */
if not side1Pred(Nearportal16, Side1pred), nearPortal(Kolem_Fn_71P_Num3_V18, Nearportal16), some(Side1pred, '$kolem_Fn_71'(Kolem_Fn_71P_Num3_V18, Nearportal16, Kolem_Fn_7117))then side2Pred(Nearportal16, Side1pred).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  reactive_rule([ not(side1Pred(Nearportal16,Side1pred)),
   		holds(nearPortal(Kolem_Fn_71P_Num3_V18,
   				 Nearportal16),
   		      Holds19),
   		some(Side1pred,
   		     '$kolem_Fn_71'(Kolem_Fn_71P_Num3_V18,
   				    Nearportal16,
   				    Kolem_Fn_7117))
   	      ],
   	      [side2Pred(Nearportal16,Side1pred)]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  holds_at(at(Object, Exists_Location), Time) :-
       holds_at(nearPortal(Object, Portal), Time),
       some(Exists_Location,
            '$kolem_Fn_71'(Object, Portal, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Object, Exists_Location), Time),
          (->),
         at(Object, Exists_Location)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  axiom(at(Object, Exists_Location),
       [ nearPortal(Object, Portal),
         some(Exists_Location,
              '$kolem_Fn_71'(Object, Portal, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  (   nearPortal(Kolem_Fn_71P_Num3_V23, Nearportal21),
       some(Tloc20,
            '$kolem_Fn_71'(Kolem_Fn_71P_Num3_V23,
                           Nearportal21,
                           Kolem_Fn_7122))
   ->  at(Kolem_Fn_71P_Num3_V23, Tloc20)
   ).
 */
if nearPortal(Kolem_Fn_71P_Num3_V23, Nearportal21), some(Tloc20, '$kolem_Fn_71'(Kolem_Fn_71P_Num3_V23, Nearportal21, Kolem_Fn_7122))then loc_at(Kolem_Fn_71P_Num3_V23, Tloc20).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  reactive_rule([ holds(nearPortal(Kolem_Fn_71P_Num3_V23,
   				 Nearportal21),
   		      Holds24),
   		some(Tloc20,
   		     '$kolem_Fn_71'(Kolem_Fn_71P_Num3_V23,
   				    Nearportal21,
   				    Kolem_Fn_7122))
   	      ],
   	      [ holds(loc_at(Kolem_Fn_71P_Num3_V23,Tloc20),
   		      Holds25)
   	      ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  holds_at(nearPortal(Object, Portal), Time) :-
       holds_at(at(Object, Exists_Location), Time),
       (   side1Pred(Portal, Exists_Location)
       ;   side2Pred(Portal, Exists_Location)
       ),
       some(Exists_Location,
            '$kolem_Fn_71'(Object, Portal, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  fix_axiom_head(Time) ->
       [ holds_at(nearPortal(Object, Portal), Time),
          (->),
         nearPortal(Object, Portal)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  axiom(nearPortal(Object, Portal),
       [ at(Object, Exists_Location),
          (side1Pred(Portal, Exists_Location);side2Pred(Portal, Exists_Location)),
         some(Exists_Location,
              '$kolem_Fn_71'(Object, Portal, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  (   at(Kolem_Fn_71P_Num3_V28, Tloc26),
       (   side1Pred(Nearportal29, Tloc26)
       ;   side2Pred(Nearportal29, Tloc26)
       ),
       some(Tloc26,
            '$kolem_Fn_71'(Kolem_Fn_71P_Num3_V28,
                           Nearportal29,
                           Kolem_Fn_7127))
   ->  nearPortal(Kolem_Fn_71P_Num3_V28, Nearportal29)
   ).
 */
if loc_at(Kolem_Fn_71P_Num3_V28, Tloc26), (side1Pred(Nearportal29, Tloc26);side2Pred(Nearportal29, Tloc26)), some(Tloc26, '$kolem_Fn_71'(Kolem_Fn_71P_Num3_V28, Nearportal29, Kolem_Fn_7127))then nearPortal(Kolem_Fn_71P_Num3_V28, Nearportal29).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*   reactive_rule([ holds(loc_at(Kolem_Fn_71P_Num3_V28, Tloc26),
                            Holds30),
                       (side1Pred(Nearportal29, Tloc26);side2Pred(Nearportal29, Tloc26)),
                      some(Tloc26,
                           '$kolem_Fn_71'(Kolem_Fn_71P_Num3_V28,
                                          Nearportal29,
                                          Kolem_Fn_7127))
                    ],
                    [ holds(nearPortal(Kolem_Fn_71P_Num3_V28,
                                       Nearportal29),
                            Holds31)
                    ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  not(holds_at(at(Object, Exists_Location), Time)) :-
       (   side1Pred(Portal, Exists_Location)
       ;   side2Pred(Portal, Exists_Location)
       ),
       not(holds_at(nearPortal(Object, Portal), Time)),
       some(Exists_Location,
            '$kolem_Fn_71'(Object, Portal, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  axiom(not(at(Object, Exists_Location)),
       [  (side1Pred(Portal, Exists_Location);side2Pred(Portal, Exists_Location)),
         not(nearPortal(Object, Portal)),
         some(Exists_Location,
              '$kolem_Fn_71'(Object, Portal, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  (   (   side1Pred(Nearportal33, Tloc32)
       ;   side2Pred(Nearportal33, Tloc32)
       ),
       not(nearPortal(Kolem_Fn_71P_Num3_V35, Nearportal33)),
       some(Tloc32,
            '$kolem_Fn_71'(Kolem_Fn_71P_Num3_V35,
                           Nearportal33,
                           Kolem_Fn_7134))
   ->  not(at(Kolem_Fn_71P_Num3_V35, Tloc32))
   ).
 */
if (side1Pred(Nearportal33, Tloc32);side2Pred(Nearportal33, Tloc32)), not nearPortal(Kolem_Fn_71P_Num3_V35, Nearportal33), some(Tloc32, '$kolem_Fn_71'(Kolem_Fn_71P_Num3_V35, Nearportal33, Kolem_Fn_7134))then not loc_at(Kolem_Fn_71P_Num3_V35, Tloc32).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*   reactive_rule([  (side1Pred(Nearportal33, Tloc32);side2Pred(Nearportal33, Tloc32)),
                      holds(not(nearPortal(Kolem_Fn_71P_Num3_V35,
                                           Nearportal33)),
                            Holds36),
                      some(Tloc32,
                           '$kolem_Fn_71'(Kolem_Fn_71P_Num3_V35,
                                          Nearportal33,
                                          Kolem_Fn_7134))
                    ],
                    [ holds(not(loc_at(Kolem_Fn_71P_Num3_V35, Tloc32)),
                            Holds37)
                    ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  not(side1Pred(Portal, Exists_Location)) :-
       holds_at(at(Object, Exists_Location), Time),
       not(holds_at(nearPortal(Object, Portal), Time)),
       some(Exists_Location,
            '$kolem_Fn_71'(Object, Portal, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Object, Exists_Location), Time),
          (->),
         at(Object, Exists_Location)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  axiom(not(side1Pred(Portal, Exists_Location)),
       [ at(Object, Exists_Location),
         not(nearPortal(Object, Portal)),
         some(Exists_Location,
              '$kolem_Fn_71'(Object, Portal, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  (   at(Kolem_Fn_71P_Num3_V41, Tloc38),
       not(nearPortal(Kolem_Fn_71P_Num3_V41, Nearportal39)),
       some(Tloc38,
            '$kolem_Fn_71'(Kolem_Fn_71P_Num3_V41,
                           Nearportal39,
                           Kolem_Fn_7140))
   ->  not(side1Pred(Nearportal39, Tloc38))
   ).
 */
if loc_at(Kolem_Fn_71P_Num3_V41, Tloc38), not nearPortal(Kolem_Fn_71P_Num3_V41, Nearportal39), some(Tloc38, '$kolem_Fn_71'(Kolem_Fn_71P_Num3_V41, Nearportal39, Kolem_Fn_7140))then not side1Pred(Nearportal39, Tloc38).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  reactive_rule([ holds(loc_at(Kolem_Fn_71P_Num3_V41,Tloc38),
   		      Holds42),
   		holds(not(nearPortal(Kolem_Fn_71P_Num3_V41,
   				     Nearportal39)),
   		      Holds42),
   		some(Tloc38,
   		     '$kolem_Fn_71'(Kolem_Fn_71P_Num3_V41,
   				    Nearportal39,
   				    Kolem_Fn_7140))
   	      ],
   	      [not(side1Pred(Nearportal39,Tloc38))]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  not(side2Pred(Portal, Exists_Location)) :-
       holds_at(at(Object, Exists_Location), Time),
       not(holds_at(nearPortal(Object, Portal), Time)),
       some(Exists_Location,
            '$kolem_Fn_71'(Object, Portal, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Object, Exists_Location), Time),
          (->),
         at(Object, Exists_Location)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  axiom(not(side2Pred(Portal, Exists_Location)),
       [ at(Object, Exists_Location),
         not(nearPortal(Object, Portal)),
         some(Exists_Location,
              '$kolem_Fn_71'(Object, Portal, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  (   at(Kolem_Fn_71P_Num3_V46, Tloc43),
       not(nearPortal(Kolem_Fn_71P_Num3_V46, Nearportal44)),
       some(Tloc43,
            '$kolem_Fn_71'(Kolem_Fn_71P_Num3_V46,
                           Nearportal44,
                           Kolem_Fn_7145))
   ->  not(side2Pred(Nearportal44, Tloc43))
   ).
 */
if loc_at(Kolem_Fn_71P_Num3_V46, Tloc43), not nearPortal(Kolem_Fn_71P_Num3_V46, Nearportal44), some(Tloc43, '$kolem_Fn_71'(Kolem_Fn_71P_Num3_V46, Nearportal44, Kolem_Fn_7145))then not side2Pred(Nearportal44, Tloc43).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  reactive_rule([ holds(loc_at(Kolem_Fn_71P_Num3_V46,Tloc43),
   		      Holds47),
   		holds(not(nearPortal(Kolem_Fn_71P_Num3_V46,
   				     Nearportal44)),
   		      Holds47),
   		some(Tloc43,
   		     '$kolem_Fn_71'(Kolem_Fn_71P_Num3_V46,
   				    Nearportal44,
   				    Kolem_Fn_7145))
   	      ],
   	      [not(side2Pred(Nearportal44,Tloc43))]).
 */


%; locking and unlocking doors
%; agent unlocks door.

% event DoorUnlock(agent,door)
 %  event(doorUnlock(agent,door)).
 %  event(doorUnlock(agent,door)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',64).
actions([doorUnlock/2]).
mpred_prop(doorUnlock(agent,door),event).


%; agent locks door.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',67).
% event DoorLock(agent,door)
 %  event(doorLock(agent,door)).
 %  event(doorLock(agent,door)).
actions([doorLock/2]).
mpred_prop(doorLock(agent,door),event).


%; door is unlocked.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',69).
% fluent DoorUnlocked(door)
 %  fluent(doorUnlocked(door)).
 %  fluent(doorUnlocked(door)).
fluents([doorUnlocked/1]).
mpred_prop(doorUnlocked(door),fluent).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',71).
%; A precondition axiom states that
%; for an agent to unlock a door,
%; the agent must be awake,
%; the door must not already be unlocked, and
%; the agent must be near the door:
% [agent,door,time]
% Happens(DoorUnlock(agent,door),time) ->
% HoldsAt(Awake(agent),time) &
% !HoldsAt(DoorUnlocked(door),time) &
% HoldsAt(NearPortal(agent,door),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',76).

 /*  (   happens(doorUnlock(Agent, Door), Time)
   ->  holds_at(awake(Agent), Time),
       holds_at(neg(doorUnlocked(Door)), Time),
       holds_at(nearPortal(Agent, Door), Time)
   ).
 */
if happens(doorUnlock(Agent, Door), Time)then awake(Agent)at Time, not doorUnlocked(Door)at Time, nearPortal(Agent, Door)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',76).

 /*  reactive_rule([happens(doorUnlock(Agent,Door),Time)],
   	      [ holds(awake(Agent),Time),
   		holds(not(doorUnlocked(Door)),Time),
   		holds(nearPortal(Agent,Door),Time)
   	      ]).
 */


%; An effect axiom states that
%; if an agent unlocks a door,
%; the door will be unlocked:
% [agent,door,time]
% Initiates(DoorUnlock(agent,door),DoorUnlocked(door),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',85).

 /*  axiom(initiates(doorUnlock(Agent, Door), doorUnlocked(Door), Time),
       []).
 */

 /*  initiates(doorUnlock(_,Doorunlock),
   	  doorUnlocked(Doorunlock),
   	  Initiates).
 */
doorUnlock(_, Doorunlock)initiates doorUnlocked(Doorunlock).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',85).

 /*  initiated(happens(doorUnlock(_,Doorunlock),
   		  Time_From,
   		  Time_Until),
   	  doorUnlocked(Doorunlock),
   	  []).
 */


%; A precondition axiom states that
%; for an agent to lock a door,
%; the agent must be awake,
%; the door must be unlocked, and
%; the agent must be near the door:
% [agent,door,time]
% Happens(DoorLock(agent,door),time) ->
% HoldsAt(Awake(agent),time) &
% HoldsAt(DoorUnlocked(door),time) &
% HoldsAt(NearPortal(agent,door),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',93).

 /*  (   happens(doorLock(Agent, Door), Time)
   ->  holds_at(awake(Agent), Time),
       holds_at(doorUnlocked(Door), Time),
       holds_at(nearPortal(Agent, Door), Time)
   ).
 */
if happens(doorLock(Agent, Door), Time)then awake(Agent)at Time, doorUnlocked(Door)at Time, nearPortal(Agent, Door)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',93).

 /*  reactive_rule([happens(doorLock(Agent,Door),Time)],
   	      [ holds(awake(Agent),Time),
   		holds(doorUnlocked(Door),Time),
   		holds(nearPortal(Agent,Door),Time)
   	      ]).
 */


%; An effect axiom states that
%; if an agent locks a door,
%; the door will no longer be unlocked.
% [agent,door,time]
% Terminates(DoorLock(agent,door),DoorUnlocked(door),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',102).

 /*  axiom(terminates(doorLock(Agent, Door), doorUnlocked(Door), Time),
       []).
 */

 /*  terminates(doorLock(_,Doorlock),
   	   doorUnlocked(Doorlock),
   	   Terminates).
 */
doorLock(_, Doorlock)terminates doorUnlocked(Doorlock).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',102).

 /*  terminated(happens(doorLock(_,Doorlock),
   		   Time_From,
   		   Time_Until),
   	   doorUnlocked(Doorlock),
   	   []).
 */


%; A state constraint says that if a door is open,
%; it is unlocked:
% [door,time]
% HoldsAt(DoorIsOpen(door),time) -> HoldsAt(DoorUnlocked(door),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',107).

 /*  holds_at(doorIsOpen(Door), Time) ->
       holds_at(doorUnlocked(Door), Time).
 */
if doorIsOpen(Door)at Time then doorUnlocked(Door)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',107).

 /*  reactive_rule([holds(doorIsOpen(Door),Time)],
   	      [holds(doorUnlocked(Door),Time)]).
 */


%; opening and closing doors
%; agent opens door.

% event DoorOpen(agent,door)
 %  event(doorOpen(agent,door)).
 %  event(doorOpen(agent,door)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',112).
actions([doorOpen/2]).
mpred_prop(doorOpen(agent,door),event).


%; agent closes door.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',115).
% event DoorClose(agent,door)
 %  event(doorClose(agent,door)).
 %  event(doorClose(agent,door)).
actions([doorClose/2]).
mpred_prop(doorClose(agent,door),event).


%; door is open.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',117).
% fluent DoorIsOpen(door)
 %  fluent(doorIsOpen(door)).
 %  fluent(doorIsOpen(door)).
fluents([doorIsOpen/1]).
mpred_prop(doorIsOpen(door),fluent).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',119).
%; A precondition axiom states that
%; for an agent to open a door,
%; the agent must be awake,
%; the door must not already be open,
%; the door must be unlocked, and
%; the agent must be near the door:
% [agent,door,time]
% Happens(DoorOpen(agent,door),time) ->
% HoldsAt(Awake(agent),time) &
% !HoldsAt(DoorIsOpen(door),time) &
% HoldsAt(DoorUnlocked(door),time) &
% HoldsAt(NearPortal(agent,door),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',125).

 /*  (   happens(doorOpen(Agent, Door), Time)
   ->  holds_at(awake(Agent), Time),
       holds_at(neg(doorIsOpen(Door)), Time),
       holds_at(doorUnlocked(Door), Time),
       holds_at(nearPortal(Agent, Door), Time)
   ).
 */
if happens(doorOpen(Agent, Door), Time)then awake(Agent)at Time, not doorIsOpen(Door)at Time, doorUnlocked(Door)at Time, nearPortal(Agent, Door)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',125).

 /*  reactive_rule([happens(doorOpen(Agent,Door),Time)],
   	      [ holds(awake(Agent),Time),
   		holds(not(doorIsOpen(Door)),Time),
   		holds(doorUnlocked(Door),Time),
   		holds(nearPortal(Agent,Door),Time)
   	      ]).
 */


%; An effect axiom states that
%; if an agent opens a door,
%; the door will be open:
% [agent,door,time]
% Initiates(DoorOpen(agent,door),DoorIsOpen(door),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',135).

 /*  axiom(initiates(doorOpen(Agent, Door), doorIsOpen(Door), Time),
       []).
 */

 /*  initiates(doorOpen(_,Dooropen),
   	  doorIsOpen(Dooropen),
   	  Initiates).
 */
doorOpen(_, Dooropen)initiates doorIsOpen(Dooropen).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',135).

 /*  initiated(happens(doorOpen(_,Dooropen),
   		  Time_From,
   		  Time_Until),
   	  doorIsOpen(Dooropen),
   	  []).
 */


%; A precondition axiom states that
%; for an agent to close a door,
%; the agent must be awake,
%; the door must be open,
%; the door must be unlocked, and
%; the agent must be near the door:
% [agent,door,time]
% Happens(DoorClose(agent,door),time) ->
% HoldsAt(Awake(agent),time) &
% HoldsAt(DoorIsOpen(door),time) &
% HoldsAt(DoorUnlocked(door),time) &
% HoldsAt(NearPortal(agent,door),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',144).

 /*  (   happens(doorClose(Agent, Door), Time)
   ->  holds_at(awake(Agent), Time),
       holds_at(doorIsOpen(Door), Time),
       holds_at(doorUnlocked(Door), Time),
       holds_at(nearPortal(Agent, Door), Time)
   ).
 */
if happens(doorClose(Agent, Door), Time)then awake(Agent)at Time, doorIsOpen(Door)at Time, doorUnlocked(Door)at Time, nearPortal(Agent, Door)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',144).

 /*  reactive_rule([happens(doorClose(Agent,Door),Time)],
   	      [ holds(awake(Agent),Time),
   		holds(doorIsOpen(Door),Time),
   		holds(doorUnlocked(Door),Time),
   		holds(nearPortal(Agent,Door),Time)
   	      ]).
 */


%; An effect axiom states that
%; if an agent closes a door,
%; the door will no longer be open:
% [agent,door,time]
% Terminates(DoorClose(agent,door),DoorIsOpen(door),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',154).

 /*  axiom(terminates(doorClose(Agent, Door), doorIsOpen(Door), Time),
       []).
 */

 /*  terminates(doorClose(_,Doorclose),
   	   doorIsOpen(Doorclose),
   	   Terminates).
 */
doorClose(_, Doorclose)terminates doorIsOpen(Doorclose).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',154).

 /*  terminated(happens(doorClose(_,Doorclose),
   		   Time_From,
   		   Time_Until),
   	   doorIsOpen(Doorclose),
   	   []).
 */


%; passing through doors
%; agent walks through side one of door.

% event WalkThroughDoor12(agent,door)
 %  event(walkThroughDoor12(agent,door)).
 %  event(walkThroughDoor12(agent,door)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',159).
actions([walkThroughDoor12/2]).
mpred_prop(walkThroughDoor12(agent,door),event).


%; agent walks through side two of door.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',162).
% event WalkThroughDoor21(agent,door)
 %  event(walkThroughDoor21(agent,door)).
 %  event(walkThroughDoor21(agent,door)).
actions([walkThroughDoor21/2]).
mpred_prop(walkThroughDoor21(agent,door),event).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',164).
%; Precondition axioms state that
%; for an agent to walk through a side of a door,
%; the agent must be awake and standing,
%; the door must be open, and
%; the agent must be at the side of the door that
%; the agent walks through:
% [agent,door,time]
% Happens(WalkThroughDoor12(agent,door),time) ->
% HoldsAt(Awake(agent),time) &
% HoldsAt(Standing(agent),time) &
% HoldsAt(DoorIsOpen(door),time) &
% HoldsAt(At(agent,Side1(door)),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',170).

 /*  (   happens(walkThroughDoor12(Agent, Door), Time)
   ->  holds_at(awake(Agent), Time),
       holds_at(standing(Agent), Time),
       holds_at(doorIsOpen(Door), Time),
       holds_at(at(Agent, side1(Door)), Time)
   ).
 */
if happens(walkThroughDoor12(Agent, Door), Time)then awake(Agent)at Time, standing(Agent)at Time, doorIsOpen(Door)at Time, loc_at(Agent, side1(Door))at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',170).

 /*  reactive_rule([ happens(walkThroughDoor12(Agent,Door),
   			Time)
   	      ],
   	      [ holds(awake(Agent),Time),
   		holds(standing(Agent),Time),
   		holds(doorIsOpen(Door),Time),
   		holds(loc_at(Agent,side1(Door)),Time)
   	      ]).
 */


% [agent,door,time]
% Happens(WalkThroughDoor21(agent,door),time) ->
% HoldsAt(Awake(agent),time) &
% HoldsAt(Standing(agent),time) &
% HoldsAt(DoorIsOpen(door),time) &
% HoldsAt(At(agent,Side2(door)),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',178).

 /*  (   happens(walkThroughDoor21(Agent, Door), Time)
   ->  holds_at(awake(Agent), Time),
       holds_at(standing(Agent), Time),
       holds_at(doorIsOpen(Door), Time),
       holds_at(at(Agent, side2(Door)), Time)
   ).
 */
if happens(walkThroughDoor21(Agent, Door), Time)then awake(Agent)at Time, standing(Agent)at Time, doorIsOpen(Door)at Time, loc_at(Agent, side2(Door))at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',178).

 /*  reactive_rule([ happens(walkThroughDoor21(Agent,Door),
   			Time)
   	      ],
   	      [ holds(awake(Agent),Time),
   		holds(standing(Agent),Time),
   		holds(doorIsOpen(Door),Time),
   		holds(loc_at(Agent,side2(Door)),Time)
   	      ]).
 */


%; Effect axioms state that
%; if an agent walks through one side of a door,
%; the agent will be at the other side of the door:
% [agent,door,location,time]
% Side2(door)=location ->
% Initiates(WalkThroughDoor12(agent,door),At(agent,location),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',187).

 /*  axiom(initiates(walkThroughDoor12(Agent, Door), at(Agent, Location), Time),
       [side2Pred(Door, Location)]).
 */

 /*  side2Pred(Walkthroughdoor12, Tloc) ->
       initiates(walkThroughDoor12(A, Walkthroughdoor12),
                 at(A, Tloc),
                 Initiates).
 */
if side2Pred(Walkthroughdoor12, Tloc)then initiates(walkThroughDoor12(A, Walkthroughdoor12), loc_at(A, Tloc)at Initiates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',187).

 /*  reactive_rule([side2Pred(Walkthroughdoor12,Tloc)],
   	      [ initiates(walkThroughDoor12(A,
   					    Walkthroughdoor12),
   			  at(loc_at(A,Tloc),
   			     Initiates),
   			  Initiates7)
   	      ]).
 */


% [agent,door,location,time]
% Side1(door)=location ->
% Initiates(WalkThroughDoor21(agent,door),At(agent,location),time).

 /*  axiom(initiates(walkThroughDoor21(Agent, Door), at(Agent, Location), Time),
       [side1Pred(Door, Location)]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',192).

 /*  side1Pred(Walkthroughdoor21, Tloc) ->
       initiates(walkThroughDoor21(A, Walkthroughdoor21),
                 at(A, Tloc),
                 Initiates).
 */
if side1Pred(Walkthroughdoor21, Tloc)then initiates(walkThroughDoor21(A, Walkthroughdoor21), loc_at(A, Tloc)at Initiates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',192).

 /*  reactive_rule([side1Pred(Walkthroughdoor21,Tloc)],
   	      [ initiates(walkThroughDoor21(A,
   					    Walkthroughdoor21),
   			  at(loc_at(A,Tloc),
   			     Initiates),
   			  Initiates7)
   	      ]).
 */


% [agent,door,location,time]
% Side1(door)=location ->
% Terminates(WalkThroughDoor12(agent,door),At(agent,location),time).

 /*  axiom(terminates(walkThroughDoor12(Agent, Door), at(Agent, Location), Time),
       [side1Pred(Door, Location)]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',196).

 /*  side1Pred(Walkthroughdoor12, Tloc) ->
       terminates(walkThroughDoor12(A, Walkthroughdoor12),
                  at(A, Tloc),
                  Terminates).
 */
if side1Pred(Walkthroughdoor12, Tloc)then terminates(walkThroughDoor12(A, Walkthroughdoor12), loc_at(A, Tloc)at Terminates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',196).

 /*  reactive_rule([side1Pred(Walkthroughdoor12,Tloc)],
   	      [ terminates(walkThroughDoor12(A,
   					     Walkthroughdoor12),
   			   at(loc_at(A,Tloc),
   			      Terminates),
   			   Terminates7)
   	      ]).
 */


% [agent,door,location,time]
% Side2(door)=location ->
% Terminates(WalkThroughDoor21(agent,door),At(agent,location),time).

 /*  axiom(terminates(walkThroughDoor21(Agent, Door), at(Agent, Location), Time),
       [side2Pred(Door, Location)]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',200).

 /*  side2Pred(Walkthroughdoor21, Tloc) ->
       terminates(walkThroughDoor21(A, Walkthroughdoor21),
                  at(A, Tloc),
                  Terminates).
 */
if side2Pred(Walkthroughdoor21, Tloc)then terminates(walkThroughDoor21(A, Walkthroughdoor21), loc_at(A, Tloc)at Terminates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',200).

 /*  reactive_rule([side2Pred(Walkthroughdoor21,Tloc)],
   	      [ terminates(walkThroughDoor21(A,
   					     Walkthroughdoor21),
   			   at(loc_at(A,Tloc),
   			      Terminates),
   			   Terminates7)
   	      ]).
 */


%; walking from one end of a street to another
%; agent walks from the first end of street to the second end.

% event WalkStreet12(agent,street)
 %  event(walkStreet12(agent,street)).
 %  event(walkStreet12(agent,street)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',205).
actions([walkStreet12/2]).
mpred_prop(walkStreet12(agent,street),event).


%; agent walks from the second end of street to the first end.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',208).
% event WalkStreet21(agent,street)
 %  event(walkStreet21(agent,street)).
 %  event(walkStreet21(agent,street)).
actions([walkStreet21/2]).
mpred_prop(walkStreet21(agent,street),event).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',210).
%; Precondition axioms state that
%; for an agent to walk from one end of a street to another,
%; the agent must be awake,
%; the agent must be standing, and
%; the agent must be at the first end of the street:
% [agent,street,time]
% Happens(WalkStreet12(agent,street),time) ->
% HoldsAt(Awake(agent),time) &
% HoldsAt(Standing(agent),time) &
% HoldsAt(At(agent,Side1(street)),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',215).

 /*  (   happens(walkStreet12(Agent, Street), Time)
   ->  holds_at(awake(Agent), Time),
       holds_at(standing(Agent), Time),
       holds_at(at(Agent, side1(Street)), Time)
   ).
 */
if happens(walkStreet12(Agent, Street), Time)then awake(Agent)at Time, standing(Agent)at Time, loc_at(Agent, side1(Street))at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',215).

 /*  reactive_rule([ happens(walkStreet12(Agent,Street),
   			Time)
   	      ],
   	      [ holds(awake(Agent),Time),
   		holds(standing(Agent),Time),
   		holds(loc_at(Agent,side1(Street)),
   		      Time)
   	      ]).
 */


% [agent,street,time]
% Happens(WalkStreet21(agent,street),time) ->
% HoldsAt(Awake(agent),time) &
% HoldsAt(Standing(agent),time) &
% HoldsAt(At(agent,Side2(street)),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',222).

 /*  (   happens(walkStreet21(Agent, Street), Time)
   ->  holds_at(awake(Agent), Time),
       holds_at(standing(Agent), Time),
       holds_at(at(Agent, side2(Street)), Time)
   ).
 */
if happens(walkStreet21(Agent, Street), Time)then awake(Agent)at Time, standing(Agent)at Time, loc_at(Agent, side2(Street))at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',222).

 /*  reactive_rule([ happens(walkStreet21(Agent,Street),
   			Time)
   	      ],
   	      [ holds(awake(Agent),Time),
   		holds(standing(Agent),Time),
   		holds(loc_at(Agent,side2(Street)),
   		      Time)
   	      ]).
 */


%; Effect axioms state that
%; if an agent walks from one end of a street to another,
%; the agent will be at the other end of the street:
% [agent,street,location,time]
% Side2(street)=location ->
% Initiates(WalkStreet12(agent,street),At(agent,location),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',230).

 /*  axiom(initiates(walkStreet12(Agent, Street), at(Agent, Location), Time),
       [side2Pred(Street, Location)]).
 */

 /*  side2Pred(Walkstreet12, Tloc) ->
       initiates(walkStreet12(A, Walkstreet12),
                 at(A, Tloc),
                 Initiates).
 */
if side2Pred(Walkstreet12, Tloc)then initiates(walkStreet12(A, Walkstreet12), loc_at(A, Tloc)at Initiates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',230).

 /*  reactive_rule([side2Pred(Walkstreet12,Tloc)],
   	      [ initiates(walkStreet12(A,Walkstreet12),
   			  at(loc_at(A,Tloc),
   			     Initiates),
   			  Initiates7)
   	      ]).
 */


% [agent,street,location,time]
% Side1(street)=location ->
% Initiates(WalkStreet21(agent,street),At(agent,location),time).

 /*  axiom(initiates(walkStreet21(Agent, Street), at(Agent, Location), Time),
       [side1Pred(Street, Location)]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',235).

 /*  side1Pred(Walkstreet21, Tloc) ->
       initiates(walkStreet21(A, Walkstreet21),
                 at(A, Tloc),
                 Initiates).
 */
if side1Pred(Walkstreet21, Tloc)then initiates(walkStreet21(A, Walkstreet21), loc_at(A, Tloc)at Initiates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',235).

 /*  reactive_rule([side1Pred(Walkstreet21,Tloc)],
   	      [ initiates(walkStreet21(A,Walkstreet21),
   			  at(loc_at(A,Tloc),
   			     Initiates),
   			  Initiates7)
   	      ]).
 */


% [agent,street,location,time]
% Side1(street)=location ->
% Terminates(WalkStreet12(agent,street),At(agent,location),time).

 /*  axiom(terminates(walkStreet12(Agent, Street), at(Agent, Location), Time),
       [side1Pred(Street, Location)]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',239).

 /*  side1Pred(Walkstreet12, Tloc) ->
       terminates(walkStreet12(A, Walkstreet12),
                  at(A, Tloc),
                  Terminates).
 */
if side1Pred(Walkstreet12, Tloc)then terminates(walkStreet12(A, Walkstreet12), loc_at(A, Tloc)at Terminates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',239).

 /*  reactive_rule([side1Pred(Walkstreet12,Tloc)],
   	      [ terminates(walkStreet12(A,Walkstreet12),
   			   at(loc_at(A,Tloc),
   			      Terminates),
   			   Terminates7)
   	      ]).
 */


% [agent,street,location,time]
% Side2(street)=location ->
% Terminates(WalkStreet21(agent,street),At(agent,location),time).

 /*  axiom(terminates(walkStreet21(Agent, Street), at(Agent, Location), Time),
       [side2Pred(Street, Location)]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',243).

 /*  side2Pred(Walkstreet21, Tloc) ->
       terminates(walkStreet21(A, Walkstreet21),
                  at(A, Tloc),
                  Terminates).
 */
if side2Pred(Walkstreet21, Tloc)then terminates(walkStreet21(A, Walkstreet21), loc_at(A, Tloc)at Terminates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',243).

 /*  reactive_rule([side2Pred(Walkstreet21,Tloc)],
   	      [ terminates(walkStreet21(A,Walkstreet21),
   			   at(loc_at(A,Tloc),
   			      Terminates),
   			   Terminates7)
   	      ]).
 */


%; floors
%; The floor of room is integer.

% function Floor(room): integer
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',248).

 /*  axiom(function_argtypes(Function_ArgtypesP_Num3_V, floor(room), integer),
       []).
 */
function_argtypes(Function_ArgtypesP_Num3_V1,floor(room),integer).
 %  predicate(floorPred(room,integer)).
 %  predicate(floorPred(room,integer)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',248).
predicates([floorPred/2]).
mpred_prop(floorPred(room,integer),predicate).

 /*  axiom(functional_predicate(floor, floorPred),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',248).
functional_predicate(floor,floorPred).
resultIsa(floor,integer).
%; walking up and down staircases
%; agent walks down staircase.

% event WalkDownStaircase(agent,staircase)
 %  event(walkDownStaircase(agent,staircase)).
 %  event(walkDownStaircase(agent,staircase)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',253).
actions([walkDownStaircase/2]).
mpred_prop(walkDownStaircase(agent,staircase),event).


%; agent walks up staircase.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',256).
% event WalkUpStaircase(agent,staircase)
 %  event(walkUpStaircase(agent,staircase)).
 %  event(walkUpStaircase(agent,staircase)).
actions([walkUpStaircase/2]).
mpred_prop(walkUpStaircase(agent,staircase),event).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',258).
%; Precondition axioms state that
%; for an agent to walk down (up) a staircase,
%; the agent must be awake, standing, and
%; at the top (bottom) of the staircase:
% [agent,staircase,time]
% Happens(WalkDownStaircase(agent,staircase),time) ->
% HoldsAt(Awake(agent),time) &
% HoldsAt(Standing(agent),time) &
% HoldsAt(At(agent,Side2(staircase)),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',262).

 /*  (   happens(walkDownStaircase(Agent, Staircase), Time)
   ->  holds_at(awake(Agent), Time),
       holds_at(standing(Agent), Time),
       holds_at(at(Agent, side2(Staircase)), Time)
   ).
 */
if happens(walkDownStaircase(Agent, Staircase), Time)then awake(Agent)at Time, standing(Agent)at Time, loc_at(Agent, side2(Staircase))at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',262).

 /*  reactive_rule([ happens(walkDownStaircase(Agent,Staircase),
   			Time)
   	      ],
   	      [ holds(awake(Agent),Time),
   		holds(standing(Agent),Time),
   		holds(loc_at(Agent,side2(Staircase)),
   		      Time)
   	      ]).
 */


% [agent,staircase,time]
% Happens(WalkUpStaircase(agent,staircase),time) ->
% HoldsAt(Awake(agent),time) &
% HoldsAt(Standing(agent),time) &
% HoldsAt(At(agent,Side1(staircase)),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',269).

 /*  (   happens(walkUpStaircase(Agent, Staircase), Time)
   ->  holds_at(awake(Agent), Time),
       holds_at(standing(Agent), Time),
       holds_at(at(Agent, side1(Staircase)), Time)
   ).
 */
if happens(walkUpStaircase(Agent, Staircase), Time)then awake(Agent)at Time, standing(Agent)at Time, loc_at(Agent, side1(Staircase))at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',269).

 /*  reactive_rule([ happens(walkUpStaircase(Agent,Staircase),
   			Time)
   	      ],
   	      [ holds(awake(Agent),Time),
   		holds(standing(Agent),Time),
   		holds(loc_at(Agent,side1(Staircase)),
   		      Time)
   	      ]).
 */


%; Effect axioms state that
%; if an agent walks down (up) a staircase,
%; the agent will be at the bottom (top) of the staircase:
% [agent,staircase,room,time]
% Side1(staircase)=room ->
% Initiates(WalkDownStaircase(agent,staircase),At(agent,room),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',277).

 /*  axiom(initiates(walkDownStaircase(Agent, Staircase), at(Agent, Room), Time),
       [side1Pred(Staircase, Room)]).
 */

 /*  side1Pred(Walkdownstaircase, Tloc) ->
       initiates(walkDownStaircase(A, Walkdownstaircase),
                 at(A, Tloc),
                 Initiates).
 */
if side1Pred(Walkdownstaircase, Tloc)then initiates(walkDownStaircase(A, Walkdownstaircase), loc_at(A, Tloc)at Initiates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',277).

 /*  reactive_rule([side1Pred(Walkdownstaircase,Tloc)],
   	      [ initiates(walkDownStaircase(A,
   					    Walkdownstaircase),
   			  at(loc_at(A,Tloc),
   			     Initiates),
   			  Initiates7)
   	      ]).
 */


% [agent,staircase,room,time]
% Side2(staircase)=room ->
% Terminates(WalkDownStaircase(agent,staircase),At(agent,room),time).

 /*  axiom(terminates(walkDownStaircase(Agent, Staircase), at(Agent, Room), Time),
       [side2Pred(Staircase, Room)]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',282).

 /*  side2Pred(Walkdownstaircase, Tloc) ->
       terminates(walkDownStaircase(A, Walkdownstaircase),
                  at(A, Tloc),
                  Terminates).
 */
if side2Pred(Walkdownstaircase, Tloc)then terminates(walkDownStaircase(A, Walkdownstaircase), loc_at(A, Tloc)at Terminates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',282).

 /*  reactive_rule([side2Pred(Walkdownstaircase,Tloc)],
   	      [ terminates(walkDownStaircase(A,
   					     Walkdownstaircase),
   			   at(loc_at(A,Tloc),
   			      Terminates),
   			   Terminates7)
   	      ]).
 */


% [agent,staircase,room,time]
% Side2(staircase)=room ->
% Initiates(WalkUpStaircase(agent,staircase),At(agent,room),time).

 /*  axiom(initiates(walkUpStaircase(Agent, Staircase), at(Agent, Room), Time),
       [side2Pred(Staircase, Room)]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',286).

 /*  side2Pred(Walkupstaircase, Tloc) ->
       initiates(walkUpStaircase(A, Walkupstaircase),
                 at(A, Tloc),
                 Initiates).
 */
if side2Pred(Walkupstaircase, Tloc)then initiates(walkUpStaircase(A, Walkupstaircase), loc_at(A, Tloc)at Initiates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',286).

 /*  reactive_rule([side2Pred(Walkupstaircase,Tloc)],
   	      [ initiates(walkUpStaircase(A,
   					  Walkupstaircase),
   			  at(loc_at(A,Tloc),
   			     Initiates),
   			  Initiates7)
   	      ]).
 */


% [agent,staircase,room,time]
% Side1(staircase)=room ->
% Terminates(WalkUpStaircase(agent,staircase),At(agent,room),time).

 /*  axiom(terminates(walkUpStaircase(Agent, Staircase), at(Agent, Room), Time),
       [side1Pred(Staircase, Room)]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',290).

 /*  side1Pred(Walkupstaircase, Tloc) ->
       terminates(walkUpStaircase(A, Walkupstaircase),
                  at(A, Tloc),
                  Terminates).
 */
if side1Pred(Walkupstaircase, Tloc)then terminates(walkUpStaircase(A, Walkupstaircase), loc_at(A, Tloc)at Terminates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',290).

 /*  reactive_rule([side1Pred(Walkupstaircase,Tloc)],
   	      [ terminates(walkUpStaircase(A,
   					   Walkupstaircase),
   			   at(loc_at(A,Tloc),
   			      Terminates),
   			   Terminates7)
   	      ]).
 */


%; A state constraint says that if an agent is outside,
%; the agent is dressed.
% [agent,outside,time]
% HoldsAt(At(agent,outside),time) ->
% HoldsAt(Dressed(agent),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',295).

 /*  holds_at(at(Agent, Outside), Time) ->
       holds_at(dressed(Agent), Time).
 */
if loc_at(Agent, Outside)at Time then dressed(Agent)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',295).

 /*  reactive_rule([holds(loc_at(Agent,Outside),Time)],
   	      [holds(dressed(Agent),Time)]).
 */


%; room looks out onto outside.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',300).
% function LookOutOnto(room): outside

 /*  axiom(function_argtypes(Function_ArgtypesP_Num3_V, lookOutOnto(room), outside),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',300).
function_argtypes(Function_ArgtypesP_Num3_V1,
		  lookOutOnto(room),
		  outside).
 %  predicate(lookOutOntoPred(room,outside)).
 %  predicate(lookOutOntoPred(room,outside)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',300).
predicates([lookOutOntoPred/2]).
mpred_prop(lookOutOntoPred(room,outside),predicate).

 /*  axiom(functional_predicate(lookOutOnto, lookOutOntoPred),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',300).
functional_predicate(lookOutOnto,lookOutOntoPred).
resultIsa(lookOutOnto,outside).
%; location1 is adjacent to location2.

% predicate Adjacent(location,location)
 %  predicate(adjacent(location,location)).
 %  predicate(adjacent(location,location)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',302).
predicates([adjacent/2]).
mpred_prop(adjacent(location,location),predicate).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',305).
%; A state constraint says that
%; two locations are adjacent if and only if
%; they have a portal in common:
% [location1,location2]
 
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).
% Adjacent(location1,location2) <->
% {portal}% 
% (Side1(portal)=location1 &
%  Side2(portal)=location2) |
% (Side2(portal)=location1 &
%  Side1(portal)=location2).
 %  clausify_pnf=exists([Portal], <->(adjacent(Location1, Location2),  (side1Pred(Portal, Location1), side2Pred(Portal, Location2);side2Pred(Portal, Location1), side1Pred(Portal, Location2)))).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*  adjacent(Location1, Location2) :-
       (   side1Pred(Exists_Portal, Location1),
           side2Pred(Exists_Portal, Location2)
       ;   side2Pred(Exists_Portal, Location1),
           side1Pred(Exists_Portal, Location2)
       ),
       some(Exists_Portal, '$kolem_Fn_72'(Location1, Location2)).
 */
 %  axiom(adjacent(Location1, Location2), [(side1Pred(Exists_Portal, Location1), side2Pred(Exists_Portal, Location2);side2Pred(Exists_Portal, Location1), side1Pred(Exists_Portal, Location2)), some(Exists_Portal, '$kolem_Fn_72'(Location1, Location2))]).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*  (   (   side1Pred(A, Side1pred),
           side2Pred(A, Side2pred)
       ;   side2Pred(A, Side1pred),
           side1Pred(A, Side2pred)
       ),
       some(A, '$kolem_Fn_72'(Side1pred, Side2pred))
   ->  adjacent(Side1pred, Side2pred)
   ).
 */
if (side1Pred(A, Side1pred), side2Pred(A, Side2pred);side2Pred(A, Side1pred), side1Pred(A, Side2pred)), some(A, '$kolem_Fn_72'(Side1pred, Side2pred))then adjacent(Side1pred, Side2pred).
 %  reactive_rule([(side1Pred(A, Side1pred), side2Pred(A, Side2pred);side2Pred(A, Side1pred), side1Pred(A, Side2pred)), some(A, '$kolem_Fn_72'(Side1pred, Side2pred))], [adjacent(Side1pred, Side2pred)]).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*  not(side1Pred(Exists_Portal, Location1)) :-
       side2Pred(Exists_Portal, Location2),
       not(adjacent(Location1, Location2)),
       some(Exists_Portal, '$kolem_Fn_72'(Location1, Location2)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*  axiom(not(side1Pred(Exists_Portal, Location1)),
       [ side2Pred(Exists_Portal, Location2),
         not(adjacent(Location1, Location2)),
         some(Exists_Portal, '$kolem_Fn_72'(Location1, Location2))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*  (   side2Pred(A, Side2pred6),
       not(adjacent(Side1pred7, Side2pred6)),
       some(A, '$kolem_Fn_72'(Side1pred7, Side2pred6))
   ->  not(side1Pred(A, Side1pred7))
   ).
 */
if side2Pred(A, Side2pred6), not adjacent(Side1pred7, Side2pred6), some(A, '$kolem_Fn_72'(Side1pred7, Side2pred6))then not side1Pred(A, Side1pred7).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*  reactive_rule([ side2Pred(A,Side2pred6),
   		not(adjacent(Side1pred7,Side2pred6)),
   		some(A,
   		     '$kolem_Fn_72'(Side1pred7,Side2pred6))
   	      ],
   	      [not(side1Pred(A,Side1pred7))]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*  not(side2Pred(Exists_Portal, Location2)) :-
       side1Pred(Exists_Portal, Location1),
       not(adjacent(Location1, Location2)),
       some(Exists_Portal, '$kolem_Fn_72'(Location1, Location2)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*  axiom(not(side2Pred(Exists_Portal, Location2)),
       [ side1Pred(Exists_Portal, Location1),
         not(adjacent(Location1, Location2)),
         some(Exists_Portal, '$kolem_Fn_72'(Location1, Location2))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*  (   side1Pred(A, Side1pred8),
       not(adjacent(Side1pred8, Adjacent)),
       some(A, '$kolem_Fn_72'(Side1pred8, Adjacent))
   ->  not(side2Pred(A, Adjacent))
   ).
 */
if side1Pred(A, Side1pred8), not adjacent(Side1pred8, Adjacent), some(A, '$kolem_Fn_72'(Side1pred8, Adjacent))then not side2Pred(A, Adjacent).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*  reactive_rule([ side1Pred(A,Side1pred8),
   		not(adjacent(Side1pred8,Adjacent)),
   		some(A,
   		     '$kolem_Fn_72'(Side1pred8,Adjacent))
   	      ],
   	      [not(side2Pred(A,Adjacent))]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*  not(side2Pred(Exists_Portal, Location1)) :-
       side1Pred(Exists_Portal, Location2),
       not(adjacent(Location1, Location2)),
       some(Exists_Portal, '$kolem_Fn_72'(Location1, Location2)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*  axiom(not(side2Pred(Exists_Portal, Location1)),
       [ side1Pred(Exists_Portal, Location2),
         not(adjacent(Location1, Location2)),
         some(Exists_Portal, '$kolem_Fn_72'(Location1, Location2))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*  (   side1Pred(A, Side1pred10),
       not(adjacent(Side2pred11, Side1pred10)),
       some(A, '$kolem_Fn_72'(Side2pred11, Side1pred10))
   ->  not(side2Pred(A, Side2pred11))
   ).
 */
if side1Pred(A, Side1pred10), not adjacent(Side2pred11, Side1pred10), some(A, '$kolem_Fn_72'(Side2pred11, Side1pred10))then not side2Pred(A, Side2pred11).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*  reactive_rule([ side1Pred(A,Side1pred10),
   		not(adjacent(Side2pred11,Side1pred10)),
   		some(A,
   		     '$kolem_Fn_72'(Side2pred11,Side1pred10))
   	      ],
   	      [not(side2Pred(A,Side2pred11))]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*  not(side1Pred(Exists_Portal, Location2)) :-
       side2Pred(Exists_Portal, Location1),
       not(adjacent(Location1, Location2)),
       some(Exists_Portal, '$kolem_Fn_72'(Location1, Location2)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*  axiom(not(side1Pred(Exists_Portal, Location2)),
       [ side2Pred(Exists_Portal, Location1),
         not(adjacent(Location1, Location2)),
         some(Exists_Portal, '$kolem_Fn_72'(Location1, Location2))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*  (   side2Pred(A, Side2pred12),
       not(adjacent(Side2pred12, Adjacent13)),
       some(A, '$kolem_Fn_72'(Side2pred12, Adjacent13))
   ->  not(side1Pred(A, Adjacent13))
   ).
 */
if side2Pred(A, Side2pred12), not adjacent(Side2pred12, Adjacent13), some(A, '$kolem_Fn_72'(Side2pred12, Adjacent13))then not side1Pred(A, Adjacent13).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*  reactive_rule([ side2Pred(A,Side2pred12),
   		not(adjacent(Side2pred12,Adjacent13)),
   		some(A,
   		     '$kolem_Fn_72'(Side2pred12,Adjacent13))
   	      ],
   	      [not(side1Pred(A,Adjacent13))]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*  not(adjacent(Location1, Location2)) :-
       (   not(side1Pred(Exists_Portal, Location1))
       ;   not(side2Pred(Exists_Portal, Location2))
       ),
       (   not(side2Pred(Exists_Portal, Location1))
       ;   not(side1Pred(Exists_Portal, Location2))
       ),
       some(Exists_Portal, '$kolem_Fn_72'(Location1, Location2)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*  axiom(not(adjacent(Location1, Location2)),
       [  (not(side1Pred(Exists_Portal, Location1));not(side2Pred(Exists_Portal, Location2))),
          (not(side2Pred(Exists_Portal, Location1));not(side1Pred(Exists_Portal, Location2))),
         some(Exists_Portal, '$kolem_Fn_72'(Location1, Location2))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*  (   (   not(side1Pred(A, Side1pred14))
       ;   not(side2Pred(A, Side2pred15))
       ),
       (   not(side2Pred(A, Side1pred14))
       ;   not(side1Pred(A, Side2pred15))
       ),
       some(A, '$kolem_Fn_72'(Side1pred14, Side2pred15))
   ->  not(adjacent(Side1pred14, Side2pred15))
   ).
 */
if (not side1Pred(A, Side1pred14);not side2Pred(A, Side2pred15)), (not side2Pred(A, Side1pred14);not side1Pred(A, Side2pred15)), some(A, '$kolem_Fn_72'(Side1pred14, Side2pred15))then not adjacent(Side1pred14, Side2pred15).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*   reactive_rule([  (not(side1Pred(A, Side1pred14));not(side2Pred(A, Side2pred15))),
                       (not(side2Pred(A, Side1pred14));not(side1Pred(A, Side2pred15))),
                      some(A,
                           '$kolem_Fn_72'(Side1pred14, Side2pred15))
                    ],
                    [not(adjacent(Side1pred14, Side2pred15))]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*  side1Pred(Exists_Portal, Location1) :-
       (   not(side2Pred(Exists_Portal, Location1))
       ;   not(side1Pred(Exists_Portal, Location2))
       ),
       adjacent(Location1, Location2),
       some(Exists_Portal, '$kolem_Fn_72'(Location1, Location2)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*  axiom(side1Pred(Exists_Portal, Location1),
       [  (not(side2Pred(Exists_Portal, Location1));not(side1Pred(Exists_Portal, Location2))),
         adjacent(Location1, Location2),
         some(Exists_Portal, '$kolem_Fn_72'(Location1, Location2))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*  (   (   not(side2Pred(A, Side2pred16))
       ;   not(side1Pred(A, Side1pred17))
       ),
       adjacent(Side2pred16, Side1pred17),
       some(A, '$kolem_Fn_72'(Side2pred16, Side1pred17))
   ->  side1Pred(A, Side2pred16)
   ).
 */
if (not side2Pred(A, Side2pred16);not side1Pred(A, Side1pred17)), adjacent(Side2pred16, Side1pred17), some(A, '$kolem_Fn_72'(Side2pred16, Side1pred17))then side1Pred(A, Side2pred16).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*   reactive_rule([  (not(side2Pred(A, Side2pred16));not(side1Pred(A, Side1pred17))),
                      adjacent(Side2pred16, Side1pred17),
                      some(A,
                           '$kolem_Fn_72'(Side2pred16, Side1pred17))
                    ],
                    [side1Pred(A, Side2pred16)]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*  side2Pred(Exists_Portal, Location2) :-
       (   not(side2Pred(Exists_Portal, Location1))
       ;   not(side1Pred(Exists_Portal, Location2))
       ),
       adjacent(Location1, Location2),
       some(Exists_Portal, '$kolem_Fn_72'(Location1, Location2)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*  axiom(side2Pred(Exists_Portal, Location2),
       [  (not(side2Pred(Exists_Portal, Location1));not(side1Pred(Exists_Portal, Location2))),
         adjacent(Location1, Location2),
         some(Exists_Portal, '$kolem_Fn_72'(Location1, Location2))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*  (   (   not(side2Pred(A, Side2pred18))
       ;   not(side1Pred(A, Side1pred19))
       ),
       adjacent(Side2pred18, Side1pred19),
       some(A, '$kolem_Fn_72'(Side2pred18, Side1pred19))
   ->  side2Pred(A, Side1pred19)
   ).
 */
if (not side2Pred(A, Side2pred18);not side1Pred(A, Side1pred19)), adjacent(Side2pred18, Side1pred19), some(A, '$kolem_Fn_72'(Side2pred18, Side1pred19))then side2Pred(A, Side1pred19).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*   reactive_rule([  (not(side2Pred(A, Side2pred18));not(side1Pred(A, Side1pred19))),
                      adjacent(Side2pred18, Side1pred19),
                      some(A,
                           '$kolem_Fn_72'(Side2pred18, Side1pred19))
                    ],
                    [side2Pred(A, Side1pred19)]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*  side2Pred(Exists_Portal, Location1) :-
       (   not(side1Pred(Exists_Portal, Location1))
       ;   not(side2Pred(Exists_Portal, Location2))
       ),
       adjacent(Location1, Location2),
       some(Exists_Portal, '$kolem_Fn_72'(Location1, Location2)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*  axiom(side2Pred(Exists_Portal, Location1),
       [  (not(side1Pred(Exists_Portal, Location1));not(side2Pred(Exists_Portal, Location2))),
         adjacent(Location1, Location2),
         some(Exists_Portal, '$kolem_Fn_72'(Location1, Location2))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*  (   (   not(side1Pred(A, Side1pred20))
       ;   not(side2Pred(A, Side2pred21))
       ),
       adjacent(Side1pred20, Side2pred21),
       some(A, '$kolem_Fn_72'(Side1pred20, Side2pred21))
   ->  side2Pred(A, Side1pred20)
   ).
 */
if (not side1Pred(A, Side1pred20);not side2Pred(A, Side2pred21)), adjacent(Side1pred20, Side2pred21), some(A, '$kolem_Fn_72'(Side1pred20, Side2pred21))then side2Pred(A, Side1pred20).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*   reactive_rule([  (not(side1Pred(A, Side1pred20));not(side2Pred(A, Side2pred21))),
                      adjacent(Side1pred20, Side2pred21),
                      some(A,
                           '$kolem_Fn_72'(Side1pred20, Side2pred21))
                    ],
                    [side2Pred(A, Side1pred20)]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*  side1Pred(Exists_Portal, Location2) :-
       (   not(side1Pred(Exists_Portal, Location1))
       ;   not(side2Pred(Exists_Portal, Location2))
       ),
       adjacent(Location1, Location2),
       some(Exists_Portal, '$kolem_Fn_72'(Location1, Location2)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*  axiom(side1Pred(Exists_Portal, Location2),
       [  (not(side1Pred(Exists_Portal, Location1));not(side2Pred(Exists_Portal, Location2))),
         adjacent(Location1, Location2),
         some(Exists_Portal, '$kolem_Fn_72'(Location1, Location2))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*  (   (   not(side1Pred(A, Side1pred22))
       ;   not(side2Pred(A, Side2pred23))
       ),
       adjacent(Side1pred22, Side2pred23),
       some(A, '$kolem_Fn_72'(Side1pred22, Side2pred23))
   ->  side1Pred(A, Side2pred23)
   ).
 */
if (not side1Pred(A, Side1pred22);not side2Pred(A, Side2pred23)), adjacent(Side1pred22, Side2pred23), some(A, '$kolem_Fn_72'(Side1pred22, Side2pred23))then side1Pred(A, Side2pred23).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*   reactive_rule([  (not(side1Pred(A, Side1pred22));not(side2Pred(A, Side2pred23))),
                      adjacent(Side1pred22, Side2pred23),
                      some(A,
                           '$kolem_Fn_72'(Side1pred22, Side2pred23))
                    ],
                    [side1Pred(A, Side2pred23)]).
 */


%; The ground of outside is ground.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',316).
% function GroundOf(outside): ground

 /*  axiom(function_argtypes(Function_ArgtypesP_Num3_V, groundOf(outside), ground),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',316).
function_argtypes(Function_ArgtypesP_Num3_V1,
		  groundOf(outside),
		  ground).
 %  predicate(ground(outside,ground)).
 %  predicate(ground(outside,ground)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',316).
predicates([ground/2]).
mpred_prop(ground(outside,ground),predicate).

 /*  axiom(functional_predicate(groundOf, ground),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',316).
functional_predicate(groundOf,ground).
resultIsa(groundOf,ground).
%; The sky of outside is sky.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',318).
% function SkyOf(outside): sky

 /*  axiom(function_argtypes(Function_ArgtypesP_Num3_V, skyOf(outside), sky),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',318).
function_argtypes(Function_ArgtypesP_Num3_V1,skyOf(outside),sky).
 %  predicate(sky(outside,sky)).
 %  predicate(sky(outside,sky)).
predicates([sky/2]).
mpred_prop(sky(outside,sky),predicate).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',318).

 /*  axiom(functional_predicate(skyOf, sky),
       []).
 */
functional_predicate(skyOf,sky).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',318).
resultIsa(skyOf,sky).
 %; State constraints fix the location of ground and sky:
% [outside,ground,time]
% GroundOf(outside) = ground ->
% HoldsAt(At(ground,outside),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',322).

 /*  ground(Outside, Ground) ->
       holds_at(at(Ground, Outside), Time).
 */
if ground(Outside, Ground)then loc_at(Ground, Outside)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',322).

 /*  reactive_rule([ground(Outside,Ground)],
   	      [holds(loc_at(Ground,Outside),Time)]).
 */


% [outside,sky,time]
% SkyOf(outside) = sky ->
% HoldsAt(At(sky,outside),time).

 /*  sky(Outside, Sky) ->
       holds_at(at(Sky, Outside), Time).
 */
if sky(Outside, Sky)then loc_at(Sky, Outside)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',327).

 /*  reactive_rule([sky(Outside,Sky)],
   	      [holds(loc_at(Sky,Outside),Time)]).
 */


%; End of file.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',329).
:- endif.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',37).
% load answers/Mueller2004c/Fire.e
:- if(is_e_toplevel).
:- cond_convert_e(changed, 'answers/Mueller2004c/Fire.e').
 %  loading(changed,'/pack/logicmoo_ec/ext/ec_sources/ecnet/Fire.e').
%;
%; Copyright (c) 2005 IBM Corporation and others.
%; All rights reserved. This program and the accompanying materials
%; are made available under the terms of the Common Public License v1.0
%; which accompanies this distribution, and is available at
%; http://www.eclipse.org/legal/cpl-v10.html
%;
%; Contributors:
%; IBM - Initial implementation
%;
%; fire
%;
%; agent sets fire to physobj with burn time offset.

% event SetFireTo(agent,physobj,fire,offset)
 %  event(setFireTo(agent,physobj,fire,offset)).
 %  event(setFireTo(agent,physobj,fire,offset)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Fire.e',14).
actions([setFireTo/4]).
mpred_prop(setFireTo(agent,physobj,fire,offset),event).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Fire.e',17).
%; An effect axioms states that
%; if an agent sets a fire to a physical object with a burn time,
%; the physical object will be burning with the fire and burn time:
% [agent,physobj,fire,offset,time]
% Initiates(SetFireTo(agent,physobj,fire,offset),
%           Burning(physobj,fire,offset),
%           time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Fire.e',20).

 /*  axiom(initiates(setFireTo(Agent, Physobj, Fire, Offset), burning(Physobj, Fire, Offset), Time),
       []).
 */

 /*  initiates(setFireTo(SetfiretoP_Num4_V,
   		    BurningP_Num3_V,
   		    A,
   		    Setfireto),
   	  burning(BurningP_Num3_V,A,Setfireto),
   	  Initiates).
 */
setFireTo(SetfiretoP_Num4_V, BurningP_Num3_V, A, Setfireto)initiates burning(BurningP_Num3_V, A, Setfireto).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Fire.e',20).

 /*  initiated(happens(setFireTo(SetfiretoP_Num4_V,
   			    BurningP_Num3_V,
   			    A,
   			    Setfireto),
   		  Time_From,
   		  Time_Until),
   	  burning(BurningP_Num3_V,A,Setfireto),
   	  []).
 */


%; agent puts out fire on physobj.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Fire.e',26).
% event PutOutFire(agent,physobj,fire)
 %  event(putOutFire(agent,physobj,fire)).
 %  event(putOutFire(agent,physobj,fire)).
actions([putOutFire/3]).
mpred_prop(putOutFire(agent,physobj,fire),event).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Fire.e',28).
%; An effect axiom states that
%; if an agent puts out a fire on a physical object,
%; the physical object will no longer be burning:
% [agent,physobj,fire,offset,time]
% Terminates(PutOutFire(agent,physobj,fire),
%            Burning(physobj,fire,offset),
%            time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Fire.e',31).

 /*  axiom(terminates(putOutFire(Agent, Physobj, Fire), burning(Physobj, Fire, Offset), Time),
       []).
 */

 /*  terminates(putOutFire(PutoutfireP_Num3_V,
   		      BurningP_Num3_V,
   		      Putoutfire),
   	   burning(BurningP_Num3_V,
   		   Putoutfire,
   		   Burning),
   	   Terminates).
 */
putOutFire(PutoutfireP_Num3_V, BurningP_Num3_V, Putoutfire)terminates burning(BurningP_Num3_V, Putoutfire, Burning).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Fire.e',31).

 /*  terminated(happens(putOutFire(PutoutfireP_Num3_V,
   			      BurningP_Num3_V,
   			      Putoutfire),
   		   Time_From,
   		   Time_Until),
   	   burning(BurningP_Num3_V,
   		   Putoutfire,
   		   Burning),
   	   []).
 */


%; A precondition axiom states that
%; for an agent to set fire to a physical object,
%; there must be a location such that
%; the agent is at the location and
%; the physical object is at the location:
% [agent,fire,physobj,offset,time]
% Happens(SetFireTo(agent,physobj,fire,offset),time) ->
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Fire.e',41).
% {location}%  HoldsAt(At(agent,location),time) &
%            HoldsAt(At(physobj,location),time).
 %  clausify_pnf=exists([Location],  (happens(setFireTo(Agent, Physobj, Fire, Offset), Time)->holds_at(at(Agent, Location), Time), holds_at(at(Physobj, Location), Time))).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Fire.e',43).

 /*  not(happens(setFireTo(Agent, Physobj, Fire, Offset), Time)) :-
       (   not(holds_at(at(Agent, Exists_Location), Time))
       ;   not(holds_at(at(Physobj, Exists_Location), Time))
       ),
       some(Exists_Location,
            '$kolem_Fn_73'(Agent,
                           Physobj,
                           Fire,
                           Offset,
                           Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Fire.e',43).

 /*  fix_axiom_head(Time) ->
       [ not(happens(setFireTo(Agent, Physobj, Fire, Offset),
                     Time)),
          (->),
         not(setFireTo(Agent, Physobj, Fire, Offset))
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Fire.e',43).

 /*  axiom(not(setFireTo(Agent, Physobj, Fire, Offset)),
       [  (not(at(Agent, Exists_Location));not(at(Physobj, Exists_Location))),
         some(Exists_Location,
              '$kolem_Fn_73'(Agent,
                             Physobj,
                             Fire,
                             Offset,
                             Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Fire.e',43).

 /*  (   (   not(at(Kolem_Fn_73P_Num5_V, Tloc))
       ;   not(at(A, Tloc))
       ),
       some(Tloc,
            '$kolem_Fn_73'(Kolem_Fn_73P_Num5_V,
                           A,
                           B,
                           Setfireto,
                           Kolem_Fn_73))
   ->  not(setFireTo(Kolem_Fn_73P_Num5_V, A, B, Setfireto))
   ).
 */
if (not loc_at(Kolem_Fn_73P_Num5_V, Tloc);not loc_at(A, Tloc)), some(Tloc, '$kolem_Fn_73'(Kolem_Fn_73P_Num5_V, A, B, Setfireto, Kolem_Fn_73))then not setFireTo(Kolem_Fn_73P_Num5_V, A, B, Setfireto).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Fire.e',43).

 /*   reactive_rule([  (not(loc_at(Kolem_Fn_73P_Num5_V, Tloc));not(loc_at(A, Tloc))),
                      some(Tloc,
                           '$kolem_Fn_73'(Kolem_Fn_73P_Num5_V,
                                          A,
                                          B,
                                          Setfireto,
                                          Kolem_Fn_73))
                    ],
                    [ not(setFireTo(Kolem_Fn_73P_Num5_V,
                                    A,
                                    B,
                                    Setfireto))
                    ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Fire.e',43).

 /*  holds_at(at(Agent, Exists_Location), Time) :-
       happens(setFireTo(Agent, Physobj, Fire, Offset),
               Time),
       some(Exists_Location,
            '$kolem_Fn_73'(Agent,
                           Physobj,
                           Fire,
                           Offset,
                           Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Fire.e',43).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Agent, Exists_Location), Time),
          (->),
         at(Agent, Exists_Location)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Fire.e',43).

 /*  axiom(at(Agent, Exists_Location),
       [ setFireTo(Agent, Physobj, Fire, Offset),
         some(Exists_Location,
              '$kolem_Fn_73'(Agent,
                             Physobj,
                             Fire,
                             Offset,
                             Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Fire.e',43).

 /*  (   setFireTo(SetfiretoP_Num4_V, A, B, Setfireto12),
       some(Tloc11,
            '$kolem_Fn_73'(SetfiretoP_Num4_V,
                           A,
                           B,
                           Setfireto12,
                           Kolem_Fn_7314))
   ->  at(SetfiretoP_Num4_V, Tloc11)
   ).
 */
if setFireTo(SetfiretoP_Num4_V, A, B, Setfireto12), some(Tloc11, '$kolem_Fn_73'(SetfiretoP_Num4_V, A, B, Setfireto12, Kolem_Fn_7314))then loc_at(SetfiretoP_Num4_V, Tloc11).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Fire.e',43).

 /*  reactive_rule([ happens(setFireTo(SetfiretoP_Num4_V,
   				  A,
   				  B,
   				  Setfireto12),
   			Time_From,
   			Time_Until),
   		some(Tloc11,
   		     '$kolem_Fn_73'(SetfiretoP_Num4_V,
   				    A,
   				    B,
   				    Setfireto12,
   				    Kolem_Fn_7314))
   	      ],
   	      [ holds(loc_at(SetfiretoP_Num4_V,Tloc11),
   		      Holds)
   	      ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Fire.e',43).

 /*  holds_at(at(Physobj, Exists_Location), Time) :-
       happens(setFireTo(Agent, Physobj, Fire, Offset),
               Time),
       some(Exists_Location,
            '$kolem_Fn_73'(Agent,
                           Physobj,
                           Fire,
                           Offset,
                           Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Fire.e',43).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Physobj, Exists_Location), Time),
          (->),
         at(Physobj, Exists_Location)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Fire.e',43).

 /*  axiom(at(Physobj, Exists_Location),
       [ setFireTo(Agent, Physobj, Fire, Offset),
         some(Exists_Location,
              '$kolem_Fn_73'(Agent,
                             Physobj,
                             Fire,
                             Offset,
                             Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Fire.e',43).

 /*  (   setFireTo(SetfiretoP_Num4_V20, A, B, Setfireto19),
       some(Tloc18,
            '$kolem_Fn_73'(SetfiretoP_Num4_V20,
                           A,
                           B,
                           Setfireto19,
                           Kolem_Fn_7321))
   ->  at(A, Tloc18)
   ).
 */
if setFireTo(SetfiretoP_Num4_V20, A, B, Setfireto19), some(Tloc18, '$kolem_Fn_73'(SetfiretoP_Num4_V20, A, B, Setfireto19, Kolem_Fn_7321))then loc_at(A, Tloc18).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Fire.e',43).

 /*  reactive_rule([ happens(setFireTo(SetfiretoP_Num4_V20,
   				  A,
   				  B,
   				  Setfireto19),
   			Time_From22,
   			Time_Until23),
   		some(Tloc18,
   		     '$kolem_Fn_73'(SetfiretoP_Num4_V20,
   				    A,
   				    B,
   				    Setfireto19,
   				    Kolem_Fn_7321))
   	      ],
   	      [holds(loc_at(A,Tloc18),Holds24)]).
 */


%; A precondition axiom states that
%; for an agent to put out a fire on a physical object,
%; there must be a location such that
%; the agent is at the location and
%; the physical object is at the location:
% [agent,fire,physobj,time]
% Happens(PutOutFire(agent,physobj,fire),time) ->
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Fire.e',51).
% {location}%  HoldsAt(At(agent,location),time) &
%            HoldsAt(At(physobj,location),time).
 %  clausify_pnf=exists([Location],  (happens(putOutFire(Agent, Physobj, Fire), Time)->holds_at(at(Agent, Location), Time), holds_at(at(Physobj, Location), Time))).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Fire.e',53).

 /*  not(happens(putOutFire(Agent, Physobj, Fire), Time)) :-
       (   not(holds_at(at(Agent, Exists_Location), Time))
       ;   not(holds_at(at(Physobj, Exists_Location), Time))
       ),
       some(Exists_Location,
            '$kolem_Fn_74'(Agent, Physobj, Fire, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Fire.e',53).

 /*  fix_axiom_head(Time) ->
       [ not(happens(putOutFire(Agent, Physobj, Fire), Time)),
          (->),
         not(putOutFire(Agent, Physobj, Fire))
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Fire.e',53).

 /*  axiom(not(putOutFire(Agent, Physobj, Fire)),
       [  (not(at(Agent, Exists_Location));not(at(Physobj, Exists_Location))),
         some(Exists_Location,
              '$kolem_Fn_74'(Agent, Physobj, Fire, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Fire.e',53).

 /*  (   (   not(at(Kolem_Fn_74P_Num4_V, Tloc))
       ;   not(at(A, Tloc))
       ),
       some(Tloc,
            '$kolem_Fn_74'(Kolem_Fn_74P_Num4_V,
                           A,
                           Putoutfire,
                           Kolem_Fn_74))
   ->  not(putOutFire(Kolem_Fn_74P_Num4_V, A, Putoutfire))
   ).
 */
if (not loc_at(Kolem_Fn_74P_Num4_V, Tloc);not loc_at(A, Tloc)), some(Tloc, '$kolem_Fn_74'(Kolem_Fn_74P_Num4_V, A, Putoutfire, Kolem_Fn_74))then not putOutFire(Kolem_Fn_74P_Num4_V, A, Putoutfire).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Fire.e',53).

 /*   reactive_rule([  (not(loc_at(Kolem_Fn_74P_Num4_V, Tloc));not(loc_at(A, Tloc))),
                      some(Tloc,
                           '$kolem_Fn_74'(Kolem_Fn_74P_Num4_V,
                                          A,
                                          Putoutfire,
                                          Kolem_Fn_74))
                    ],
                    [ not(putOutFire(Kolem_Fn_74P_Num4_V,
                                     A,
                                     Putoutfire))
                    ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Fire.e',53).

 /*  holds_at(at(Agent, Exists_Location), Time) :-
       happens(putOutFire(Agent, Physobj, Fire), Time),
       some(Exists_Location,
            '$kolem_Fn_74'(Agent, Physobj, Fire, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Fire.e',53).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Agent, Exists_Location), Time),
          (->),
         at(Agent, Exists_Location)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Fire.e',53).

 /*  axiom(at(Agent, Exists_Location),
       [ putOutFire(Agent, Physobj, Fire),
         some(Exists_Location,
              '$kolem_Fn_74'(Agent, Physobj, Fire, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Fire.e',53).

 /*  (   putOutFire(PutoutfireP_Num3_V, A, Putoutfire11),
       some(Tloc10,
            '$kolem_Fn_74'(PutoutfireP_Num3_V,
                           A,
                           Putoutfire11,
                           Kolem_Fn_7413))
   ->  at(PutoutfireP_Num3_V, Tloc10)
   ).
 */
if putOutFire(PutoutfireP_Num3_V, A, Putoutfire11), some(Tloc10, '$kolem_Fn_74'(PutoutfireP_Num3_V, A, Putoutfire11, Kolem_Fn_7413))then loc_at(PutoutfireP_Num3_V, Tloc10).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Fire.e',53).

 /*  reactive_rule([ happens(putOutFire(PutoutfireP_Num3_V,
   				   A,
   				   Putoutfire11),
   			Time_From,
   			Time_Until),
   		some(Tloc10,
   		     '$kolem_Fn_74'(PutoutfireP_Num3_V,
   				    A,
   				    Putoutfire11,
   				    Kolem_Fn_7413))
   	      ],
   	      [ holds(loc_at(PutoutfireP_Num3_V,Tloc10),
   		      Holds)
   	      ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Fire.e',53).

 /*  holds_at(at(Physobj, Exists_Location), Time) :-
       happens(putOutFire(Agent, Physobj, Fire), Time),
       some(Exists_Location,
            '$kolem_Fn_74'(Agent, Physobj, Fire, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Fire.e',53).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Physobj, Exists_Location), Time),
          (->),
         at(Physobj, Exists_Location)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Fire.e',53).

 /*  axiom(at(Physobj, Exists_Location),
       [ putOutFire(Agent, Physobj, Fire),
         some(Exists_Location,
              '$kolem_Fn_74'(Agent, Physobj, Fire, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Fire.e',53).

 /*  (   putOutFire(PutoutfireP_Num3_V19, A, Putoutfire18),
       some(Tloc17,
            '$kolem_Fn_74'(PutoutfireP_Num3_V19,
                           A,
                           Putoutfire18,
                           Kolem_Fn_7420))
   ->  at(A, Tloc17)
   ).
 */
if putOutFire(PutoutfireP_Num3_V19, A, Putoutfire18), some(Tloc17, '$kolem_Fn_74'(PutoutfireP_Num3_V19, A, Putoutfire18, Kolem_Fn_7420))then loc_at(A, Tloc17).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Fire.e',53).

 /*  reactive_rule([ happens(putOutFire(PutoutfireP_Num3_V19,
   				   A,
   				   Putoutfire18),
   			Time_From21,
   			Time_Until22),
   		some(Tloc17,
   		     '$kolem_Fn_74'(PutoutfireP_Num3_V19,
   				    A,
   				    Putoutfire18,
   				    Kolem_Fn_7420))
   	      ],
   	      [holds(loc_at(A,Tloc17),Holds23)]).
 */


%; physobj is burning with fire and burn time offset.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Fire.e',57).
% fluent Burning(physobj,fire,offset)
 %  fluent(burning(physobj,fire,offset)).
 %  fluent(burning(physobj,fire,offset)).
fluents([burning/3]).
mpred_prop(burning(physobj,fire,offset),fluent).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Fire.e',59).
%; A state constraint says that a physical object burning with
%; a fire has at most one burn time at a time:
% [physobj,fire,offset1,offset2,time]
% HoldsAt(Burning(physobj,fire,offset1),time) &
% HoldsAt(Burning(physobj,fire,offset2),time) ->
% offset1=offset2.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Fire.e',61).

 /*  (   holds_at(burning(Physobj, Fire, Offset1), Time),
       holds_at(burning(Physobj, Fire, Offset2), Time)
   ->  equals(Offset1, Offset2)
   ).
 */
if burning(Physobj, Fire, Offset1)at Time, burning(Physobj, Fire, Offset2)at Time then equals(Offset1, Offset2).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Fire.e',61).

 /*  reactive_rule([ holds(burning(Physobj,Fire,Offset1),
   		      Time),
   		holds(burning(Physobj,Fire,Offset2),
   		      Time)
   	      ],
   	      [equals(Offset1,Offset2)]).
 */


%; The burn time of physobj is decremented.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Fire.e',67).
% event DecrementBurning(physobj)
 %  event(decrementBurning(physobj)).
 %  event(decrementBurning(physobj)).
events([decrementBurning/1]).
mpred_prop(decrementBurning(physobj),event).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Fire.e',69).
%; A trigger axiom states that
%; if a physical object is burning with a fire and a burn time and
%; the burn time is greater than zero,
%; the burn time of the physical object is decremented:
% [physobj,fire,offset,time]
% HoldsAt(Burning(physobj,fire,offset),time) &
% (offset > 0) ->
% Happens(DecrementBurning(physobj),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Fire.e',73).

 /*  (   holds_at(burning(Physobj, Fire, Offset), Time),
       Offset>0
   ->  happens(decrementBurning(Physobj), Time)
   ).
 */
if burning(Physobj, Fire, Offset)at Time, Offset>0 then happens(decrementBurning(Physobj), Time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Fire.e',73).

 /*  reactive_rule([ holds(burning(Physobj,Fire,Offset),
   		      Time),
   		Offset>0
   	      ],
   	      [happens(decrementBurning(Physobj),Time)]).
 */


%; An effect axiom states that if a physical object is
%; burning with a fire and a burn time, and the burn time of a physical
%; object is decremented, the burn time of the physical
%; object will be the burn time minus one:
% [physobj,fire,offset1,offset2,time]
% HoldsAt(Burning(physobj,fire,offset1),time) &
% offset2 = offset1-1 ->
% Initiates(DecrementBurning(physobj),
%           Burning(physobj,fire,offset2),
%           time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Fire.e',82).

 /*  axiom(initiates(decrementBurning(Physobj), burning(Physobj, Fire, Offset2), Time),
       [ burning(Physobj, Fire, Offset1),
         '-Pred'(Offset1, 1, Offset2)
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Fire.e',82).

 /*  (   burning(BurningP_Num3_V, A, Burning),
       '-Pred'(Burning, 1, Pred)
   ->  initiates(decrementBurning(BurningP_Num3_V),
                 burning(BurningP_Num3_V, A, Pred),
                 Initiates)
   ).
 */
if burning(BurningP_Num3_V, A, Burning), '-Pred'(Burning, 1, Pred)then initiates(decrementBurning(BurningP_Num3_V), burning(BurningP_Num3_V, A, Pred)at Initiates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Fire.e',82).

 /*  reactive_rule([ holds(burning(BurningP_Num3_V,
   			      A,
   			      Burning),
   		      Holds),
   		'-Pred'(Burning,1,Pred)
   	      ],
   	      [ initiates(decrementBurning(BurningP_Num3_V),
   			  at(burning(BurningP_Num3_V,
   				     A,
   				     Pred),
   			     Initiates),
   			  Initiates10)
   	      ]).
 */


%; An effect axiom states that if a physical object is
%; burning with a fire and a burn time, and the burn time of a physical
%; object is decremented, the burn time of the physical
%; object will no longer be the burn time:
% [physobj,fire,offset,time]
% HoldsAt(Burning(physobj,fire,offset),time) ->
% Terminates(DecrementBurning(physobj),
%            Burning(physobj,fire,offset),
%            time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Fire.e',93).

 /*  axiom(terminates(decrementBurning(Physobj), burning(Physobj, Fire, Offset), Time),
       [burning(Physobj, Fire, Offset)]).
 */

 /*  burning(BurningP_Num3_V, A, Burning) ->
       terminates(decrementBurning(BurningP_Num3_V),
                  burning(BurningP_Num3_V, A, Burning),
                  Terminates).
 */
if burning(BurningP_Num3_V, A, Burning)then terminates(decrementBurning(BurningP_Num3_V), burning(BurningP_Num3_V, A, Burning)at Terminates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Fire.e',93).

 /*  reactive_rule([ holds(burning(BurningP_Num3_V,
   			      A,
   			      Burning),
   		      Holds)
   	      ],
   	      [ terminates(decrementBurning(BurningP_Num3_V),
   			   at(burning(BurningP_Num3_V,
   				      A,
   				      Burning),
   			      Terminates),
   			   Terminates8)
   	      ]).
 */


%; A trigger axiom states that
%; if a physical object is burning with a fire and a burn time
%; that is not equal to zero, the fire will damage the
%; physical object:
% [physobj,fire,offset,time]
% offset!=% 0 &
% HoldsAt(Burning(physobj,fire,offset),time) &
% HoldsAt(Intact(physobj),time) ->
% Happens(Damage(fire,physobj),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Fire.e',103).

 /*  (   diff(Offset, 0),
       holds_at(burning(Physobj, Fire, Offset), Time),
       holds_at(intact(Physobj), Time)
   ->  happens(damage(Fire, Physobj), Time)
   ).
 */
if diff(Offset, 0), burning(Physobj, Fire, Offset)at Time, intact(Physobj)at Time then happens(damage(Fire, Physobj), Time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Fire.e',103).

 /*  reactive_rule([ diff(Offset,0),
   		holds(burning(Physobj,Fire,Offset),
   		      Time),
   		holds(intact(Physobj),Time)
   	      ],
   	      [happens(damage(Fire,Physobj),Time)]).
 */


%; A trigger axiom states that
%; if a physical object is burning with a fire and a burn time
%; that is equal to zero, the fire will destroy the
%; physical object:
% [physobj,fire,time]
% HoldsAt(Burning(physobj,fire,0),time) &
% !HoldsAt(Destroyed(physobj),time) ->
% Happens(Destroy(fire,physobj),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Fire.e',113).

 /*  (   holds_at(burning(Physobj, Fire, 0), Time),
       holds_at(neg(destroyed(Physobj)), Time)
   ->  happens(destroy(Fire, Physobj), Time)
   ).
 */
if burning(Physobj, Fire, 0)at Time, not destroyed(Physobj)at Time then happens(destroy(Fire, Physobj), Time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Fire.e',113).

 /*  reactive_rule([ holds(burning(Physobj,Fire,0),Time),
   		holds(not(destroyed(Physobj)),Time)
   	      ],
   	      [happens(destroy(Fire,Physobj),Time)]).
 */


%; An effect axiom states that if a fire destroys a physical
%; object, the physical object will no longer be burning:
% [physobj,fire,offset,time]
% Terminates(Destroy(fire,physobj),
%            Burning(physobj,fire,offset),
%            time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Fire.e',120).

 /*  axiom(terminates(destroy(Fire, Physobj), burning(Physobj, Fire, Offset), Time),
       []).
 */

 /*  terminates(destroy(A,Destroy),
   	   burning(Destroy,A,Burning),
   	   Terminates).
 */
destroy(A, Destroy)terminates burning(Destroy, A, Burning).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Fire.e',120).

 /*  terminated(happens(destroy(A,Destroy),
   		   Time_From,
   		   Time_Until),
   	   burning(Destroy,A,Burning),
   	   []).
 */


%; End of file.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Fire.e',124).
:- endif.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',38).
% load answers/Mueller2004c/Condition.e
:- if(is_e_toplevel).
:- cond_convert_e(changed, 'answers/Mueller2004c/Condition.e').
 %  loading(changed,'/pack/logicmoo_ec/ext/ec_sources/ecnet/Condition.e').
%;
%; Copyright (c) 2005 IBM Corporation and others.
%; All rights reserved. This program and the accompanying materials
%; are made available under the terms of the Common Public License v1.0
%; which accompanies this distribution, and is available at
%; http://www.eclipse.org/legal/cpl-v10.html
%;
%; Contributors:
%; IBM - Initial implementation
%;
%; human health

% fluent Alive(agent)
 %  fluent(alive(agent)).
 %  fluent(alive(agent)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Condition.e',13).
fluents([alive/1]).
mpred_prop(alive(agent),fluent).

% fluent Dead(agent)
 %  fluent(dead(agent)).
 %  fluent(dead(agent)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Condition.e',15).
fluents([dead/1]).
mpred_prop(dead(agent),fluent).

% noninertial Dead
noninertial(dead).

% fluent Injured(agent)
 %  fluent(injured(agent)).
 %  fluent(injured(agent)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Condition.e',18).
fluents([injured/1]).
mpred_prop(injured(agent),fluent).

% event Kill(object,agent)
 %  event(kill(object,agent)).
 %  event(kill(object,agent)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Condition.e',20).
events([kill/2]).
mpred_prop(kill(object,agent),event).

% event Injure(object,agent)
 %  event(injure(object,agent)).
 %  event(injure(object,agent)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Condition.e',20).
events([injure/2]).
mpred_prop(injure(object,agent),event).

% event HealInjured(agent)
 %  event(healInjured(agent)).
 %  event(healInjured(agent)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Condition.e',22).
actions([healInjured/1]).
mpred_prop(healInjured(agent),event).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Condition.e',24).
% [agent,time]
 % HoldsAt(Alive(agent),time) <-> !HoldsAt(Dead(agent),time).

 /*  holds_at(alive(Agent), Time) <->
       holds_at(neg(dead(Agent)), Time).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Condition.e',24).

 /*  holds_at(alive(Agent), Time) ->
       holds_at(neg(dead(Agent)), Time).
 */
if alive(Agent)at Time then not dead(Agent)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Condition.e',24).

 /*  reactive_rule([holds(alive(Agent),Time)],
   	      [holds(not(dead(Agent)),Time)]).
 */

 /*  holds_at(neg(dead(Agent)), Time) ->
       holds_at(alive(Agent), Time).
 */
if not dead(Agent)at Time then alive(Agent)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Condition.e',24).

 /*  reactive_rule([holds(not(dead(Agent)),Time)],
   	      [holds(alive(Agent),Time)]).
 */


% [agent,time]
 % HoldsAt(Injured(agent),time) -> HoldsAt(Alive(agent),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Condition.e',24).

 /*  holds_at(injured(Agent), Time) ->
       holds_at(alive(Agent), Time).
 */
if injured(Agent)at Time then alive(Agent)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Condition.e',24).

 /*  reactive_rule([holds(injured(Agent),Time)],
   	      [holds(alive(Agent),Time)]).
 */


% [object,agent,time]
% Terminates(Kill(object,agent),Alive(agent),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Condition.e',28).

 /*  axiom(terminates(kill(Object, Agent), alive(Agent), Time),
       []).
 */
 %  terminates(kill(_,Kill),alive(Kill),Terminates).
kill(_, Kill)terminates alive(Kill).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Condition.e',28).

 /*  terminated(happens(kill(_,Kill),
   		   Time_From,
   		   Time_Until),
   	   alive(Kill),
   	   []).
 */


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Condition.e',30).
% [object,agent,time]
% Initiates(Injure(object,agent),Injured(agent),time).

 /*  axiom(initiates(injure(Object, Agent), injured(Agent), Time),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Condition.e',30).

 /*  initiates(injure(_,Injure),
   	  injured(Injure),
   	  Initiates).
 */
injure(_, Injure)initiates injured(Injure).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Condition.e',30).

 /*  initiated(happens(injure(_,Injure),
   		  Time_From,
   		  Time_Until),
   	  injured(Injure),
   	  []).
 */


% [agent,time]
% Terminates(HealInjured(agent),Injured(agent),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Condition.e',34).

 /*  axiom(terminates(healInjured(Agent), injured(Agent), Time),
       []).
 */

 /*  terminates(healInjured(Healinjured),
   	   injured(Healinjured),
   	   Terminates).
 */
healInjured(Healinjured)terminates injured(Healinjured).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Condition.e',34).

 /*  terminated(happens(healInjured(Healinjured),
   		   Time_From,
   		   Time_Until),
   	   injured(Healinjured),
   	   []).
 */

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Condition.e',36).
% fluent Intact(physobj)
 %  fluent(intact(physobj)).
 %  fluent(intact(physobj)).
fluents([intact/1]).
mpred_prop(intact(physobj),fluent).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Condition.e',38).
% fluent Damaged(physobj)
 %  fluent(damaged(physobj)).
 %  fluent(damaged(physobj)).
fluents([damaged/1]).
mpred_prop(damaged(physobj),fluent).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Condition.e',40).
% fluent Destroyed(physobj)
 %  fluent(destroyed(physobj)).
 %  fluent(destroyed(physobj)).
fluents([destroyed/1]).
mpred_prop(destroyed(physobj),fluent).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Condition.e',42).
%; At any time, a physical object is either intact, damaged, or destroyed:

% xor Intact, Damaged, Destroyed
 %  ==>xor[intact,damaged,destroyed].
==>xor[intact,damaged,destroyed].

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Condition.e',45).
% event Damage(object,physobj)
 %  event(damage(object,physobj)).
 %  event(damage(object,physobj)).
events([damage/2]).
mpred_prop(damage(object,physobj),event).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Condition.e',47).
% event Destroy(object,physobj)
 %  event(destroy(object,physobj)).
 %  event(destroy(object,physobj)).
events([destroy/2]).
mpred_prop(destroy(object,physobj),event).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Condition.e',49).
% event Repair(object,physobj)
 %  event(repair(object,physobj)).
 %  event(repair(object,physobj)).
events([repair/2]).
mpred_prop(repair(object,physobj),event).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Condition.e',51).
% [object,physobj,time]
% Happens(Damage(object,physobj),time) ->
% HoldsAt(Intact(physobj),time).

 /*  happens(damage(Object, Physobj), Time) ->
       holds_at(intact(Physobj), Time).
 */
if happens(damage(Object, Physobj), Time)then intact(Physobj)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Condition.e',51).

 /*  reactive_rule([happens(damage(Object,Physobj),Time)],
   	      [holds(intact(Physobj),Time)]).
 */


% [object,physobj,time]
% Initiates(Damage(object,physobj),Damaged(physobj),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Condition.e',56).

 /*  axiom(initiates(damage(Object, Physobj), damaged(Physobj), Time),
       []).
 */

 /*  initiates(damage(_,Damage),
   	  damaged(Damage),
   	  Initiates).
 */
damage(_, Damage)initiates damaged(Damage).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Condition.e',56).

 /*  initiated(happens(damage(_,Damage),
   		  Time_From,
   		  Time_Until),
   	  damaged(Damage),
   	  []).
 */


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Condition.e',58).
% [object,physobj,time]
% Terminates(Damage(object,physobj),Intact(physobj),time).

 /*  axiom(terminates(damage(Object, Physobj), intact(Physobj), Time),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Condition.e',58).

 /*  terminates(damage(_,Damage),
   	   intact(Damage),
   	   Terminates).
 */
damage(_, Damage)terminates intact(Damage).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Condition.e',58).

 /*  terminated(happens(damage(_,Damage),
   		   Time_From,
   		   Time_Until),
   	   intact(Damage),
   	   []).
 */


% [object,physobj,time]
% Happens(Destroy(object,physobj),time) ->
% (HoldsAt(Intact(physobj),time)|
%  HoldsAt(Damaged(physobj),time)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Condition.e',62).

 /*  happens(destroy(Object, Physobj), Time) ->
       (   holds_at(intact(Physobj), Time)
       ;   holds_at(damaged(Physobj), Time)
       ).
 */
if happens(destroy(Object, Physobj), Time)then intact(Physobj)at Time;damaged(Physobj)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Condition.e',62).

 /*   reactive_rule([happens(destroy(Object, Physobj), Time)],
                    [  (at(intact(Physobj), Time);at(damaged(Physobj), Time))
                    ]).
 */


% [object,physobj,time]
% Initiates(Destroy(object,physobj),Destroyed(physobj),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Condition.e',67).

 /*  axiom(initiates(destroy(Object, Physobj), destroyed(Physobj), Time),
       []).
 */

 /*  initiates(destroy(_,Destroy),
   	  destroyed(Destroy),
   	  Initiates).
 */
destroy(_, Destroy)initiates destroyed(Destroy).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Condition.e',67).

 /*  initiated(happens(destroy(_,Destroy),
   		  Time_From,
   		  Time_Until),
   	  destroyed(Destroy),
   	  []).
 */


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Condition.e',69).
% [object,physobj,time]
% Terminates(Destroy(object,physobj),Intact(physobj),time).

 /*  axiom(terminates(destroy(Object, Physobj), intact(Physobj), Time),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Condition.e',69).

 /*  terminates(destroy(_,Destroy),
   	   intact(Destroy),
   	   Terminates).
 */
destroy(_, Destroy)terminates intact(Destroy).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Condition.e',69).

 /*  terminated(happens(destroy(_,Destroy),
   		   Time_From,
   		   Time_Until),
   	   intact(Destroy),
   	   []).
 */


% [object,physobj,time]
% Terminates(Destroy(object,physobj),Damaged(physobj),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Condition.e',73).

 /*  axiom(terminates(destroy(Object, Physobj), damaged(Physobj), Time),
       []).
 */

 /*  terminates(destroy(_,Destroy),
   	   damaged(Destroy),
   	   Terminates).
 */
destroy(_, Destroy)terminates damaged(Destroy).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Condition.e',73).

 /*  terminated(happens(destroy(_,Destroy),
   		   Time_From,
   		   Time_Until),
   	   damaged(Destroy),
   	   []).
 */


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Condition.e',75).
% [object,physobj,time]
% Initiates(Repair(object,physobj),Intact(physobj),time).

 /*  axiom(initiates(repair(Object, Physobj), intact(Physobj), Time),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Condition.e',75).

 /*  initiates(repair(_,Repair),
   	  intact(Repair),
   	  Initiates).
 */
repair(_, Repair)initiates intact(Repair).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Condition.e',75).

 /*  initiated(happens(repair(_,Repair),
   		  Time_From,
   		  Time_Until),
   	  intact(Repair),
   	  []).
 */


%; end of file.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Condition.e',77).
:- endif.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',39).
% load answers/Mueller2003/Sleep.e
:- if(is_e_toplevel).
:- cond_convert_e(changed, 'answers/Mueller2003/Sleep.e').
 %  loading(changed,'/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e').
%;
%; Copyright (c) 2005 IBM Corporation and others.
%; All rights reserved. This program and the accompanying materials
%; are made available under the terms of the Common Public License v1.0
%; which accompanies this distribution, and is available at
%; http://www.eclipse.org/legal/cpl-v10.html
%;
%; Contributors:
%; IBM - Initial implementation
%;
%; The Sleep representation deals with the activity of sleeping and
%; body posture.
%; It is similar to the finite automaton representation of sleep
%; used in ThoughtTreasure \fullcite[chap. 7]{Mueller:1998}.
%;
%; @book{Mueller:1998,
%;   author = "Erik T. Mueller",
%;   year = "1998",
%;   title = "Natural Language Processing with \uppercase{T}hought\uppercase{T}reasure",
%;   address = "New York",
%;   publisher = "Signiform",
%; }
%;
%; sleep
%; agent wakes up.

% event WakeUp(agent)
 %  event(wakeUp(agent)).
 %  event(wakeUp(agent)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',27).
actions([wakeUp/1]).
mpred_prop(wakeUp(agent),event).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',30).
%; agent gets tired.

% event GetTired(agent)
 %  event(getTired(agent)).
 %  event(getTired(agent)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',30).
actions([getTired/1]).
mpred_prop(getTired(agent),event).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',33).
%; agent falls asleep.

% event FallAsleep(agent)
 %  event(fallAsleep(agent)).
 %  event(fallAsleep(agent)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',33).
actions([fallAsleep/1]).
mpred_prop(fallAsleep(agent),event).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',36).
%; agent is asleep.

% fluent Sleep0(agent)
 %  fluent(sleep0(agent)).
 %  fluent(sleep0(agent)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',36).
fluents([sleep0/1]).
mpred_prop(sleep0(agent),fluent).


%; agent is awake and in bed.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',39).
% fluent Sleep1(agent)
 %  fluent(sleep1(agent)).
 %  fluent(sleep1(agent)).
fluents([sleep1/1]).
mpred_prop(sleep1(agent),fluent).


%; agent is awake, out of bed, and undressed.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',41).
% fluent Sleep2(agent)
 %  fluent(sleep2(agent)).
 %  fluent(sleep2(agent)).
fluents([sleep2/1]).
mpred_prop(sleep2(agent),fluent).


%; agent is awake and dressed.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',43).
% fluent Sleep3(agent)
 %  fluent(sleep3(agent)).
 %  fluent(sleep3(agent)).
fluents([sleep3/1]).
mpred_prop(sleep3(agent),fluent).


%; agent is tired and dressed.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',45).
% fluent Sleep4(agent)
 %  fluent(sleep4(agent)).
 %  fluent(sleep4(agent)).
fluents([sleep4/1]).
mpred_prop(sleep4(agent),fluent).


%; agent is tired and undressed.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',47).
% fluent Sleep5(agent)
 %  fluent(sleep5(agent)).
 %  fluent(sleep5(agent)).
fluents([sleep5/1]).
mpred_prop(sleep5(agent),fluent).


%; agent is in bed, waiting to fall asleep.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',49).
% fluent Sleep6(agent)
 %  fluent(sleep6(agent)).
 %  fluent(sleep6(agent)).
fluents([sleep6/1]).
mpred_prop(sleep6(agent),fluent).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',51).
%; At any time, an agent is in one of seven sleep states:

% xor Sleep0, Sleep1, Sleep2, Sleep3, Sleep4, Sleep5, Sleep6
 %  ==>xor[sleep0,sleep1,sleep2,sleep3,sleep4,sleep5,sleep6].
==>xor[sleep0,sleep1,sleep2,sleep3,sleep4,sleep5,sleep6].
%; constraints
%; agent is asleep.

% fluent Asleep(agent)
 %  fluent(asleep(agent)).
 %  fluent(asleep(agent)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',56).
fluents([asleep/1]).
mpred_prop(asleep(agent),fluent).


%; agent is awake.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',59).
% fluent Awake(agent)
 %  fluent(awake(agent)).
 %  fluent(awake(agent)).
fluents([awake/1]).
mpred_prop(awake(agent),fluent).

% noninertial Asleep
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',59).
noninertial(asleep).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',61).
% noninertial Awake
noninertial(awake).
%; Sleep0 indicates that the agent is asleep:
% [agent,time]
 % HoldsAt(Asleep(agent),time) <-> HoldsAt(Sleep0(agent),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',63).

 /*  holds_at(asleep(Agent), Time) <->
       holds_at(sleep0(Agent), Time).
 */

 /*  holds_at(asleep(Agent), Time) ->
       holds_at(sleep0(Agent), Time).
 */
if asleep(Agent)at Time then sleep0(Agent)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',63).

 /*  reactive_rule([holds(asleep(Agent),Time)],
   	      [holds(sleep0(Agent),Time)]).
 */

 /*  holds_at(sleep0(Agent), Time) ->
       holds_at(asleep(Agent), Time).
 */
if sleep0(Agent)at Time then asleep(Agent)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',63).

 /*  reactive_rule([holds(sleep0(Agent),Time)],
   	      [holds(asleep(Agent),Time)]).
 */


%; In all other sleep states, the agent is awake:
% [agent,time]
% HoldsAt(Awake(agent),time) <->
% HoldsAt(Sleep1(agent),time) |
% HoldsAt(Sleep2(agent),time) |
% HoldsAt(Sleep3(agent),time) |
% HoldsAt(Sleep4(agent),time) |
% HoldsAt(Sleep5(agent),time) |
% HoldsAt(Sleep6(agent),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',67).

 /*  holds_at(awake(Agent), Time) <->
       (   holds_at(sleep1(Agent), Time)
       ;   holds_at(sleep2(Agent), Time)
       ;   holds_at(sleep3(Agent), Time)
       ;   holds_at(sleep4(Agent), Time)
       ;   holds_at(sleep5(Agent), Time)
       ;   holds_at(sleep6(Agent), Time)
       ).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',67).

 /*  holds_at(awake(Agent), Time) ->
       (   holds_at(sleep1(Agent), Time)
       ;   holds_at(sleep2(Agent), Time)
       ;   holds_at(sleep3(Agent), Time)
       ;   holds_at(sleep4(Agent), Time)
       ;   holds_at(sleep5(Agent), Time)
       ;   holds_at(sleep6(Agent), Time)
       ).
 */
if awake(Agent)at Time then sleep1(Agent)at Time;sleep2(Agent)at Time;sleep3(Agent)at Time;sleep4(Agent)at Time;sleep5(Agent)at Time;sleep6(Agent)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',67).

 /*   reactive_rule([holds(awake(Agent), Time)],
                    [  (at(sleep1(Agent), Time);at(sleep2(Agent), Time);at(sleep3(Agent), Time);at(sleep4(Agent), Time);at(sleep5(Agent), Time);at(sleep6(Agent), Time))
                    ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',67).

 /*  holds_at(sleep1(Agent), Time);holds_at(sleep2(Agent), Time);holds_at(sleep3(Agent), Time);holds_at(sleep4(Agent), Time);holds_at(sleep5(Agent), Time);holds_at(sleep6(Agent), Time) ->
       holds_at(awake(Agent), Time).
 */
if sleep1(Agent)at Time;sleep2(Agent)at Time;sleep3(Agent)at Time;sleep4(Agent)at Time;sleep5(Agent)at Time;sleep6(Agent)at Time then awake(Agent)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',67).

 /*   reactive_rule([  (at(sleep1(Agent), Time);at(sleep2(Agent), Time);at(sleep3(Agent), Time);at(sleep4(Agent), Time);at(sleep5(Agent), Time);at(sleep6(Agent), Time))
                    ],
                    [holds(awake(Agent), Time)]).
 */


%; A number of axioms are used to specify the transitions of
%; a finite automaton.
%;--
%; Waking up causes a transition from Sleep0
%; to Sleep1:
% [agent,time]
 
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',82).
% Terminates(WakeUp(agent),Sleep0(agent),time).

 /*  axiom(terminates(wakeUp(Agent), sleep0(Agent), Time),
       []).
 */
 %  terminates(wakeUp(Wakeup),sleep0(Wakeup),Terminates).
wakeUp(Wakeup)terminates sleep0(Wakeup).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',82).

 /*  terminated(happens(wakeUp(Wakeup),
   		   Time_From,
   		   Time_Until),
   	   sleep0(Wakeup),
   	   []).
 */


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',84).
% [agent,time]
 % Initiates(WakeUp(agent),Sleep1(agent),time).

 /*  axiom(initiates(wakeUp(Agent), sleep1(Agent), Time),
       []).
 */
 %  initiates(wakeUp(Wakeup),sleep1(Wakeup),Initiates).
wakeUp(Wakeup)initiates sleep1(Wakeup).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',84).

 /*  initiated(happens(wakeUp(Wakeup),
   		  Time_From,
   		  Time_Until),
   	  sleep1(Wakeup),
   	  []).
 */


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',86).
% [agent,time]
 % Happens(WakeUp(agent),time) -> HoldsAt(Sleep0(agent),time).

 /*  happens(wakeUp(Agent), Time) ->
       holds_at(sleep0(Agent), Time).
 */
if happens(wakeUp(Agent), Time)then sleep0(Agent)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',86).

 /*  reactive_rule([happens(wakeUp(Agent),Time)],
   	      [holds(sleep0(Agent),Time)]).
 */


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',88).
%;--
%; Getting out of bed causes a transition from Sleep1
%; to Sleep2:
% [agent,bed,time]
 
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',92).
% Terminates(RiseFrom(agent,bed),Sleep1(agent),time).

 /*  axiom(terminates(riseFrom(Agent, Bed), sleep1(Agent), Time),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',92).

 /*  terminates(riseFrom(Sleep1,Risefrom),
   	   sleep1(Sleep1),
   	   Terminates).
 */
riseFrom(Sleep1, Risefrom)terminates sleep1(Sleep1).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',92).

 /*  terminated(happens(riseFrom(Sleep1,Risefrom),
   		   Time_From,
   		   Time_Until),
   	   sleep1(Sleep1),
   	   []).
 */


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',94).
% [agent,bed,time]
 % Initiates(RiseFrom(agent,bed),Sleep2(agent),time).

 /*  axiom(initiates(riseFrom(Agent, Bed), sleep2(Agent), Time),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',94).

 /*  initiates(riseFrom(Sleep2,Risefrom),
   	  sleep2(Sleep2),
   	  Initiates).
 */
riseFrom(Sleep2, Risefrom)initiates sleep2(Sleep2).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',94).

 /*  initiated(happens(riseFrom(Sleep2,Risefrom),
   		  Time_From,
   		  Time_Until),
   	  sleep2(Sleep2),
   	  []).
 */


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',96).
% [agent,bed,time]
% Happens(RiseFrom(agent,bed),time) -> HoldsAt(Sleep1(agent),time).

 /*  happens(riseFrom(Agent, Bed), Time) ->
       holds_at(sleep1(Agent), Time).
 */
if happens(riseFrom(Agent, Bed), Time)then sleep1(Agent)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',96).

 /*  reactive_rule([happens(riseFrom(Agent,Bed),Time)],
   	      [holds(sleep1(Agent),Time)]).
 */


%;--
%; Getting dressed causes a transition from Sleep2
%; to Sleep3, the normal state of awakeness:
% [agent,time]
 
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',103).
% Terminates(GetDressed(agent),Sleep2(agent),time).

 /*  axiom(terminates(getDressed(Agent), sleep2(Agent), Time),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',103).

 /*  terminates(getDressed(Getdressed),
   	   sleep2(Getdressed),
   	   Terminates).
 */
getDressed(Getdressed)terminates sleep2(Getdressed).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',103).

 /*  terminated(happens(getDressed(Getdressed),
   		   Time_From,
   		   Time_Until),
   	   sleep2(Getdressed),
   	   []).
 */


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',105).
% [agent,time]
 % Initiates(GetDressed(agent),Sleep3(agent),time).

 /*  axiom(initiates(getDressed(Agent), sleep3(Agent), Time),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',105).

 /*  initiates(getDressed(Getdressed),
   	  sleep3(Getdressed),
   	  Initiates).
 */
getDressed(Getdressed)initiates sleep3(Getdressed).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',105).

 /*  initiated(happens(getDressed(Getdressed),
   		  Time_From,
   		  Time_Until),
   	  sleep3(Getdressed),
   	  []).
 */


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',107).
% [agent,time]
 % Happens(GetDressed(agent),time) -> HoldsAt(Sleep2(agent),time).

 /*  happens(getDressed(Agent), Time) ->
       holds_at(sleep2(Agent), Time).
 */
if happens(getDressed(Agent), Time)then sleep2(Agent)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',107).

 /*  reactive_rule([happens(getDressed(Agent),Time)],
   	      [holds(sleep2(Agent),Time)]).
 */


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',109).
%;--
%; Getting tired causes a transition from Sleep3
%; to Sleep4:
% [agent,time]
 
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',113).
% Terminates(GetTired(agent),Sleep3(agent),time).

 /*  axiom(terminates(getTired(Agent), sleep3(Agent), Time),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',113).

 /*  terminates(getTired(Gettired),
   	   sleep3(Gettired),
   	   Terminates).
 */
getTired(Gettired)terminates sleep3(Gettired).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',113).

 /*  terminated(happens(getTired(Gettired),
   		   Time_From,
   		   Time_Until),
   	   sleep3(Gettired),
   	   []).
 */


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',115).
% [agent,time]
 % Initiates(GetTired(agent),Sleep4(agent),time).

 /*  axiom(initiates(getTired(Agent), sleep4(Agent), Time),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',115).

 /*  initiates(getTired(Gettired),
   	  sleep4(Gettired),
   	  Initiates).
 */
getTired(Gettired)initiates sleep4(Gettired).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',115).

 /*  initiated(happens(getTired(Gettired),
   		  Time_From,
   		  Time_Until),
   	  sleep4(Gettired),
   	  []).
 */


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',117).
% [agent,time]
 % Happens(GetTired(agent),time) -> HoldsAt(Sleep3(agent),time).

 /*  happens(getTired(Agent), Time) ->
       holds_at(sleep3(Agent), Time).
 */
if happens(getTired(Agent), Time)then sleep3(Agent)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',117).

 /*  reactive_rule([happens(getTired(Agent),Time)],
   	      [holds(sleep3(Agent),Time)]).
 */


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',119).
%;--
%; Getting undressed causes a transition from Sleep4
%; to Sleep5:
% [agent,time]
 
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',123).
% Terminates(GetUndressed(agent),Sleep4(agent),time).

 /*  axiom(terminates(getUndressed(Agent), sleep4(Agent), Time),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',123).

 /*  terminates(getUndressed(Getundressed),
   	   sleep4(Getundressed),
   	   Terminates).
 */
getUndressed(Getundressed)terminates sleep4(Getundressed).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',123).

 /*  terminated(happens(getUndressed(Getundressed),
   		   Time_From,
   		   Time_Until),
   	   sleep4(Getundressed),
   	   []).
 */


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',125).
% [agent,time]
 % Initiates(GetUndressed(agent),Sleep5(agent),time).

 /*  axiom(initiates(getUndressed(Agent), sleep5(Agent), Time),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',125).

 /*  initiates(getUndressed(Getundressed),
   	  sleep5(Getundressed),
   	  Initiates).
 */
getUndressed(Getundressed)initiates sleep5(Getundressed).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',125).

 /*  initiated(happens(getUndressed(Getundressed),
   		  Time_From,
   		  Time_Until),
   	  sleep5(Getundressed),
   	  []).
 */


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',127).
% [agent,time]
 % Happens(GetUndressed(agent),time) -> HoldsAt(Sleep4(agent),time).

 /*  happens(getUndressed(Agent), Time) ->
       holds_at(sleep4(Agent), Time).
 */
if happens(getUndressed(Agent), Time)then sleep4(Agent)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',127).

 /*  reactive_rule([happens(getUndressed(Agent),Time)],
   	      [holds(sleep4(Agent),Time)]).
 */


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',129).
%;--
%; Lying on a bed causes a transition from Sleep5
%; to Sleep6:
% [agent,bed,time]
 
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',133).
% Terminates(LieOn(agent,bed),Sleep5(agent),time).

 /*  axiom(terminates(lieOn(Agent, Bed), sleep5(Agent), Time),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',133).

 /*  terminates(lieOn(Sleep5,Lieon),
   	   sleep5(Sleep5),
   	   Terminates).
 */
lieOn(Sleep5, Lieon)terminates sleep5(Sleep5).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',133).

 /*  terminated(happens(lieOn(Sleep5,Lieon),
   		   Time_From,
   		   Time_Until),
   	   sleep5(Sleep5),
   	   []).
 */


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',135).
% [agent,bed,time]
 % Initiates(LieOn(agent,bed),Sleep6(agent),time).

 /*  axiom(initiates(lieOn(Agent, Bed), sleep6(Agent), Time),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',135).

 /*  initiates(lieOn(Sleep6,Lieon),
   	  sleep6(Sleep6),
   	  Initiates).
 */
lieOn(Sleep6, Lieon)initiates sleep6(Sleep6).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',135).

 /*  initiated(happens(lieOn(Sleep6,Lieon),
   		  Time_From,
   		  Time_Until),
   	  sleep6(Sleep6),
   	  []).
 */


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',137).
% [agent,bed,time]
 % Happens(LieOn(agent,bed),time) -> HoldsAt(Sleep5(agent),time).

 /*  happens(lieOn(Agent, Bed), Time) ->
       holds_at(sleep5(Agent), Time).
 */
if happens(lieOn(Agent, Bed), Time)then sleep5(Agent)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',137).

 /*  reactive_rule([happens(lieOn(Agent,Bed),Time)],
   	      [holds(sleep5(Agent),Time)]).
 */


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',139).
%;--
%; Falling asleep causes a transition from Sleep6
%; to Sleep0:
% [agent,time]
 
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',143).
% Terminates(FallAsleep(agent),Sleep6(agent),time).

 /*  axiom(terminates(fallAsleep(Agent), sleep6(Agent), Time),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',143).

 /*  terminates(fallAsleep(Fallasleep),
   	   sleep6(Fallasleep),
   	   Terminates).
 */
fallAsleep(Fallasleep)terminates sleep6(Fallasleep).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',143).

 /*  terminated(happens(fallAsleep(Fallasleep),
   		   Time_From,
   		   Time_Until),
   	   sleep6(Fallasleep),
   	   []).
 */


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',145).
% [agent,time]
 % Initiates(FallAsleep(agent),Sleep0(agent),time).

 /*  axiom(initiates(fallAsleep(Agent), sleep0(Agent), Time),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',145).

 /*  initiates(fallAsleep(Fallasleep),
   	  sleep0(Fallasleep),
   	  Initiates).
 */
fallAsleep(Fallasleep)initiates sleep0(Fallasleep).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',145).

 /*  initiated(happens(fallAsleep(Fallasleep),
   		  Time_From,
   		  Time_Until),
   	  sleep0(Fallasleep),
   	  []).
 */


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',147).
% [agent,time]
 % Happens(FallAsleep(agent),time) -> HoldsAt(Sleep6(agent),time).

 /*  happens(fallAsleep(Agent), Time) ->
       holds_at(sleep6(Agent), Time).
 */
if happens(fallAsleep(Agent), Time)then sleep6(Agent)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',147).

 /*  reactive_rule([happens(fallAsleep(Agent),Time)],
   	      [holds(sleep6(Agent),Time)]).
 */


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',149).
%;--
%; agent acts on being in state Sleep5.

% fluent ActOnSleep5(agent)
 %  fluent(actOnSleep5(agent)).
 %  fluent(actOnSleep5(agent)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',151).
fluents([actOnSleep5/1]).
mpred_prop(actOnSleep5(agent),fluent).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',153).
% noninertial ActOnSleep5
noninertial(actOnSleep5).
%; We reduce the number of models by asserting that
%; an agent only acts on being in state Sleep5 while in
%; that state:
% [agent,time]
% !HoldsAt(Sleep5(agent),time) ->
% !HoldsAt(ActOnSleep5(agent),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',158).

 /*  holds_at(neg(sleep5(Agent)), Time) ->
       holds_at(neg(actOnSleep5(Agent)), Time).
 */
if not sleep5(Agent)at Time then not actOnSleep5(Agent)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',158).

 /*  reactive_rule([holds(not(sleep5(Agent)),Time)],
   	      [holds(not(actOnSleep5(Agent)),Time)]).
 */


%; Undressed is like IntentionToPlay
%; ActOnSleep5 is like ActOnIntentionToPlay
%; A trigger axiom states that if an agent is in state Sleep5,
%; the agent acts on this state, the agent is in a room, and
%; a bed is at the room, the agent lies on the bed:
% [agent,room,bed,time]
% HoldsAt(Sleep5(agent),time) &
% HoldsAt(ActOnSleep5(agent),time) &
% HoldsAt(At(agent,room),time) &
% HoldsAt(At(bed,room),time) ->
% Happens(LieOn(agent,bed),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',168).

 /*  (   holds_at(sleep5(Agent), Time),
       holds_at(actOnSleep5(Agent), Time),
       holds_at(at(Agent, Room), Time),
       holds_at(at(Bed, Room), Time)
   ->  happens(lieOn(Agent, Bed), Time)
   ).
 */
if sleep5(Agent)at Time, actOnSleep5(Agent)at Time, loc_at(Agent, Room)at Time, loc_at(Bed, Room)at Time then happens(lieOn(Agent, Bed), Time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',168).

 /*  reactive_rule([ holds(sleep5(Agent),Time),
   		holds(actOnSleep5(Agent),Time),
   		holds(loc_at(Agent,Room),Time),
   		holds(loc_at(Bed,Room),Time)
   	      ],
   	      [happens(lieOn(Agent,Bed),Time)]).
 */


%; A precondition axiom states that for
%; an agent to lie on a bed,
%; the agent must be in state Sleep5,
%; the agent must act on this state, and
%; there must be a room such that
%; the agent is in the room and the bed is in the room:
% [agent,bed,time]
% Happens(LieOn(agent,bed),time) ->
% HoldsAt(Sleep5(agent),time) &
% HoldsAt(ActOnSleep5(agent),time) &
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',181).
% {room}% 
%  HoldsAt(At(agent,room),time) &
%  HoldsAt(At(bed,room),time).
 %  clausify_pnf=exists([Room],  (happens(lieOn(Agent, Bed), Time)->holds_at(sleep5(Agent), Time), holds_at(actOnSleep5(Agent), Time), holds_at(at(Agent, Room), Time), holds_at(at(Bed, Room), Time))).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',185).

 /*  not(happens(lieOn(Agent, Bed), Time)) :-
       (   not(holds_at(sleep5(Agent), Time))
       ;   not(holds_at(actOnSleep5(Agent), Time))
       ;   not(holds_at(at(Agent, Exists_Room), Time))
       ;   not(holds_at(at(Bed, Exists_Room), Time))
       ),
       some(Exists_Room, '$kolem_Fn_75'(Agent, Bed, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',185).

 /*  fix_axiom_head(Time) ->
       [ not(happens(lieOn(Agent, Bed), Time)),
          (->),
         not(lieOn(Agent, Bed))
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',185).

 /*  axiom(not(lieOn(Agent, Bed)),
       [  (not(sleep5(Agent));not(actOnSleep5(Agent));not(at(Agent, Exists_Room));not(at(Bed, Exists_Room))),
         some(Exists_Room, '$kolem_Fn_75'(Agent, Bed, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',185).

 /*  (   (   not(sleep5(Sleep5))
       ;   not(actOnSleep5(Sleep5))
       ;   not(at(Sleep5, Tloc))
       ;   not(at(Lieon, Tloc))
       ),
       some(Tloc, '$kolem_Fn_75'(Sleep5, Lieon, Kolem_Fn_75))
   ->  not(lieOn(Sleep5, Lieon))
   ).
 */
if (not sleep5(Sleep5);not actOnSleep5(Sleep5);not loc_at(Sleep5, Tloc);not loc_at(Lieon, Tloc)), some(Tloc, '$kolem_Fn_75'(Sleep5, Lieon, Kolem_Fn_75))then not lieOn(Sleep5, Lieon).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',185).

 /*   reactive_rule([  (not(sleep5(Sleep5));not(actOnSleep5(Sleep5));not(loc_at(Sleep5, Tloc));not(loc_at(Lieon, Tloc))),
                      some(Tloc,
                           '$kolem_Fn_75'(Sleep5,
                                          Lieon,
                                          Kolem_Fn_75))
                    ],
                    [not(lieOn(Sleep5, Lieon))]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',185).

 /*  holds_at(sleep5(Agent), Time) :-
       happens(lieOn(Agent, Bed), Time),
       some(Exists_Room, '$kolem_Fn_75'(Agent, Bed, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',185).

 /*  fix_axiom_head(Time) ->
       [holds_at(sleep5(Agent), Time), ->, sleep5(Agent)].
 */

 /*  axiom(sleep5(Agent),
       [ lieOn(Agent, Bed),
         some(Exists_Room, '$kolem_Fn_75'(Agent, Bed, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',185).

 /*  (   lieOn(Kolem_Fn_75P_Num3_V, Lieon9),
       some(_,
            '$kolem_Fn_75'(Kolem_Fn_75P_Num3_V,
                           Lieon9,
                           Kolem_Fn_7510))
   ->  sleep5(Kolem_Fn_75P_Num3_V)
   ).
 */
if lieOn(Kolem_Fn_75P_Num3_V, Lieon9), some(_, '$kolem_Fn_75'(Kolem_Fn_75P_Num3_V, Lieon9, Kolem_Fn_7510))then sleep5(Kolem_Fn_75P_Num3_V).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',185).

 /*  reactive_rule([ happens(lieOn(Kolem_Fn_75P_Num3_V,Lieon9),
   			Time_From,
   			Time_Until),
   		some(_,
   		     '$kolem_Fn_75'(Kolem_Fn_75P_Num3_V,
   				    Lieon9,
   				    Kolem_Fn_7510))
   	      ],
   	      [holds(sleep5(Kolem_Fn_75P_Num3_V),Holds)]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',185).

 /*  holds_at(actOnSleep5(Agent), Time) :-
       happens(lieOn(Agent, Bed), Time),
       some(Exists_Room, '$kolem_Fn_75'(Agent, Bed, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',185).

 /*  fix_axiom_head(Time) ->
       [ holds_at(actOnSleep5(Agent), Time),
          (->),
         actOnSleep5(Agent)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',185).

 /*  axiom(actOnSleep5(Agent),
       [ lieOn(Agent, Bed),
         some(Exists_Room, '$kolem_Fn_75'(Agent, Bed, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',185).

 /*  (   lieOn(Kolem_Fn_75P_Num3_V17, Lieon15),
       some(_,
            '$kolem_Fn_75'(Kolem_Fn_75P_Num3_V17,
                           Lieon15,
                           Kolem_Fn_7516))
   ->  actOnSleep5(Kolem_Fn_75P_Num3_V17)
   ).
 */
if lieOn(Kolem_Fn_75P_Num3_V17, Lieon15), some(_, '$kolem_Fn_75'(Kolem_Fn_75P_Num3_V17, Lieon15, Kolem_Fn_7516))then actOnSleep5(Kolem_Fn_75P_Num3_V17).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',185).

 /*  reactive_rule([ happens(lieOn(Kolem_Fn_75P_Num3_V17,
   			      Lieon15),
   			Time_From18,
   			Time_Until19),
   		some(_,
   		     '$kolem_Fn_75'(Kolem_Fn_75P_Num3_V17,
   				    Lieon15,
   				    Kolem_Fn_7516))
   	      ],
   	      [ holds(actOnSleep5(Kolem_Fn_75P_Num3_V17),
   		      Holds20)
   	      ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',185).

 /*  holds_at(at(Agent, Exists_Room), Time) :-
       happens(lieOn(Agent, Bed), Time),
       some(Exists_Room, '$kolem_Fn_75'(Agent, Bed, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',185).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Agent, Exists_Room), Time),
          (->),
         at(Agent, Exists_Room)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',185).

 /*  axiom(at(Agent, Exists_Room),
       [ lieOn(Agent, Bed),
         some(Exists_Room, '$kolem_Fn_75'(Agent, Bed, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',185).

 /*  (   lieOn(Kolem_Fn_75P_Num3_V24, Lieon22),
       some(Tloc21,
            '$kolem_Fn_75'(Kolem_Fn_75P_Num3_V24,
                           Lieon22,
                           Kolem_Fn_7523))
   ->  at(Kolem_Fn_75P_Num3_V24, Tloc21)
   ).
 */
if lieOn(Kolem_Fn_75P_Num3_V24, Lieon22), some(Tloc21, '$kolem_Fn_75'(Kolem_Fn_75P_Num3_V24, Lieon22, Kolem_Fn_7523))then loc_at(Kolem_Fn_75P_Num3_V24, Tloc21).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',185).

 /*  reactive_rule([ happens(lieOn(Kolem_Fn_75P_Num3_V24,
   			      Lieon22),
   			Time_From25,
   			Time_Until26),
   		some(Tloc21,
   		     '$kolem_Fn_75'(Kolem_Fn_75P_Num3_V24,
   				    Lieon22,
   				    Kolem_Fn_7523))
   	      ],
   	      [ holds(loc_at(Kolem_Fn_75P_Num3_V24,Tloc21),
   		      Holds27)
   	      ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',185).

 /*  holds_at(at(Bed, Exists_Room), Time) :-
       happens(lieOn(Agent, Bed), Time),
       some(Exists_Room, '$kolem_Fn_75'(Agent, Bed, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',185).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Bed, Exists_Room), Time),
          (->),
         at(Bed, Exists_Room)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',185).

 /*  axiom(at(Bed, Exists_Room),
       [ lieOn(Agent, Bed),
         some(Exists_Room, '$kolem_Fn_75'(Agent, Bed, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',185).

 /*  (   lieOn(Kolem_Fn_75P_Num3_V31, Lieon29),
       some(Tloc28,
            '$kolem_Fn_75'(Kolem_Fn_75P_Num3_V31,
                           Lieon29,
                           Kolem_Fn_7530))
   ->  at(Lieon29, Tloc28)
   ).
 */
if lieOn(Kolem_Fn_75P_Num3_V31, Lieon29), some(Tloc28, '$kolem_Fn_75'(Kolem_Fn_75P_Num3_V31, Lieon29, Kolem_Fn_7530))then loc_at(Lieon29, Tloc28).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',185).

 /*  reactive_rule([ happens(lieOn(Kolem_Fn_75P_Num3_V31,
   			      Lieon29),
   			Time_From32,
   			Time_Until33),
   		some(Tloc28,
   		     '$kolem_Fn_75'(Kolem_Fn_75P_Num3_V31,
   				    Lieon29,
   				    Kolem_Fn_7530))
   	      ],
   	      [holds(loc_at(Lieon29,Tloc28),Holds34)]).
 */


%; (body) posture
%; agent lies on physobj.

% event LieOn(agent,physobj)
 %  event(lieOn(agent,physobj)).
 %  event(lieOn(agent,physobj)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',191).
actions([lieOn/2]).
mpred_prop(lieOn(agent,physobj),event).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',194).
%; agent sits on physobj.

% event SitOn(agent,physobj)
 %  event(sitOn(agent,physobj)).
 %  event(sitOn(agent,physobj)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',194).
actions([sitOn/2]).
mpred_prop(sitOn(agent,physobj),event).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',197).
% [agent,physobj,time]
% Happens(SitOn(agent,physobj),time) ->
% {location}% 
%  HoldsAt(At(agent,location),time) &
%  HoldsAt(At(physobj,location),time).
 %  clausify_pnf=exists([Location],  (happens(sitOn(Agent, Physobj), Time)->holds_at(at(Agent, Location), Time), holds_at(at(Physobj, Location), Time))).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',199).

 /*  not(happens(sitOn(Agent, Physobj), Time)) :-
       (   not(holds_at(at(Agent, Exists_Location), Time))
       ;   not(holds_at(at(Physobj, Exists_Location), Time))
       ),
       some(Exists_Location,
            '$kolem_Fn_76'(Agent, Physobj, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',199).

 /*  fix_axiom_head(Time) ->
       [ not(happens(sitOn(Agent, Physobj), Time)),
          (->),
         not(sitOn(Agent, Physobj))
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',199).

 /*  axiom(not(sitOn(Agent, Physobj)),
       [  (not(at(Agent, Exists_Location));not(at(Physobj, Exists_Location))),
         some(Exists_Location,
              '$kolem_Fn_76'(Agent, Physobj, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',199).

 /*  (   (   not(at(Kolem_Fn_76P_Num3_V, Tloc))
       ;   not(at(Siton, Tloc))
       ),
       some(Tloc,
            '$kolem_Fn_76'(Kolem_Fn_76P_Num3_V, Siton, Kolem_Fn_76))
   ->  not(sitOn(Kolem_Fn_76P_Num3_V, Siton))
   ).
 */
if (not loc_at(Kolem_Fn_76P_Num3_V, Tloc);not loc_at(Siton, Tloc)), some(Tloc, '$kolem_Fn_76'(Kolem_Fn_76P_Num3_V, Siton, Kolem_Fn_76))then not sitOn(Kolem_Fn_76P_Num3_V, Siton).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',199).

 /*   reactive_rule([  (not(loc_at(Kolem_Fn_76P_Num3_V, Tloc));not(loc_at(Siton, Tloc))),
                      some(Tloc,
                           '$kolem_Fn_76'(Kolem_Fn_76P_Num3_V,
                                          Siton,
                                          Kolem_Fn_76))
                    ],
                    [not(sitOn(Kolem_Fn_76P_Num3_V, Siton))]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',199).

 /*  holds_at(at(Agent, Exists_Location), Time) :-
       happens(sitOn(Agent, Physobj), Time),
       some(Exists_Location,
            '$kolem_Fn_76'(Agent, Physobj, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',199).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Agent, Exists_Location), Time),
          (->),
         at(Agent, Exists_Location)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',199).

 /*  axiom(at(Agent, Exists_Location),
       [ sitOn(Agent, Physobj),
         some(Exists_Location,
              '$kolem_Fn_76'(Agent, Physobj, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',199).

 /*  (   sitOn(Kolem_Fn_76P_Num3_V12, Siton10),
       some(Tloc9,
            '$kolem_Fn_76'(Kolem_Fn_76P_Num3_V12,
                           Siton10,
                           Kolem_Fn_7611))
   ->  at(Kolem_Fn_76P_Num3_V12, Tloc9)
   ).
 */
if sitOn(Kolem_Fn_76P_Num3_V12, Siton10), some(Tloc9, '$kolem_Fn_76'(Kolem_Fn_76P_Num3_V12, Siton10, Kolem_Fn_7611))then loc_at(Kolem_Fn_76P_Num3_V12, Tloc9).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',199).

 /*  reactive_rule([ happens(sitOn(Kolem_Fn_76P_Num3_V12,
   			      Siton10),
   			Time_From,
   			Time_Until),
   		some(Tloc9,
   		     '$kolem_Fn_76'(Kolem_Fn_76P_Num3_V12,
   				    Siton10,
   				    Kolem_Fn_7611))
   	      ],
   	      [ holds(loc_at(Kolem_Fn_76P_Num3_V12,Tloc9),
   		      Holds)
   	      ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',199).

 /*  holds_at(at(Physobj, Exists_Location), Time) :-
       happens(sitOn(Agent, Physobj), Time),
       some(Exists_Location,
            '$kolem_Fn_76'(Agent, Physobj, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',199).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Physobj, Exists_Location), Time),
          (->),
         at(Physobj, Exists_Location)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',199).

 /*  axiom(at(Physobj, Exists_Location),
       [ sitOn(Agent, Physobj),
         some(Exists_Location,
              '$kolem_Fn_76'(Agent, Physobj, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',199).

 /*  (   sitOn(Kolem_Fn_76P_Num3_V19, Siton17),
       some(Tloc16,
            '$kolem_Fn_76'(Kolem_Fn_76P_Num3_V19,
                           Siton17,
                           Kolem_Fn_7618))
   ->  at(Siton17, Tloc16)
   ).
 */
if sitOn(Kolem_Fn_76P_Num3_V19, Siton17), some(Tloc16, '$kolem_Fn_76'(Kolem_Fn_76P_Num3_V19, Siton17, Kolem_Fn_7618))then loc_at(Siton17, Tloc16).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',199).

 /*  reactive_rule([ happens(sitOn(Kolem_Fn_76P_Num3_V19,
   			      Siton17),
   			Time_From20,
   			Time_Until21),
   		some(Tloc16,
   		     '$kolem_Fn_76'(Kolem_Fn_76P_Num3_V19,
   				    Siton17,
   				    Kolem_Fn_7618))
   	      ],
   	      [holds(loc_at(Siton17,Tloc16),Holds22)]).
 */


%; agent rises from physobj.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',204).
% event RiseFrom(agent,physobj)
 %  event(riseFrom(agent,physobj)).
 %  event(riseFrom(agent,physobj)).
actions([riseFrom/2]).
mpred_prop(riseFrom(agent,physobj),event).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',206).
%; agent is lying on physobj.

% fluent LyingOn(agent,physobj)
 %  fluent(lyingOn(agent,physobj)).
 %  fluent(lyingOn(agent,physobj)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',206).
fluents([lyingOn/2]).
mpred_prop(lyingOn(agent,physobj),fluent).


%; agent is sitting on physobj.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',209).
% fluent SittingOn(agent,physobj)
 %  fluent(sittingOn(agent,physobj)).
 %  fluent(sittingOn(agent,physobj)).
fluents([sittingOn/2]).
mpred_prop(sittingOn(agent,physobj),fluent).


%; agent is standing.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',211).
% fluent Standing(agent)
 %  fluent(standing(agent)).
 %  fluent(standing(agent)).
fluents([standing/1]).
mpred_prop(standing(agent),fluent).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',213).
%; agent is lying down.

% fluent Lying(agent)
 %  fluent(lying(agent)).
 %  fluent(lying(agent)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',213).
fluents([lying/1]).
mpred_prop(lying(agent),fluent).


%; agent is sitting.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',216).
% fluent Sitting(agent)
 %  fluent(sitting(agent)).
 %  fluent(sitting(agent)).
fluents([sitting/1]).
mpred_prop(sitting(agent),fluent).

% noninertial Lying
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',216).
noninertial(lying).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',218).
% noninertial Sitting
noninertial(sitting).
%; At any time, an agent is either lying, sitting, or standing:

% xor Lying, Sitting, Standing
 %  ==>xor[lying,sitting,standing].
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',220).
==>xor[lying,sitting,standing].


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',223).
% [agent,physobj,time]
% HoldsAt(LyingOn(agent,physobj),time) ->
% HoldsAt(Lying(agent),time).

 /*  holds_at(lyingOn(Agent, Physobj), Time) ->
       holds_at(lying(Agent), Time).
 */
if lyingOn(Agent, Physobj)at Time then lying(Agent)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',223).

 /*  reactive_rule([holds(lyingOn(Agent,Physobj),Time)],
   	      [holds(lying(Agent),Time)]).
 */


% [agent,physobj,time]
% HoldsAt(SittingOn(agent,physobj),time) ->
% HoldsAt(Sitting(agent),time).

 /*  holds_at(sittingOn(Agent, Physobj), Time) ->
       holds_at(sitting(Agent), Time).
 */
if sittingOn(Agent, Physobj)at Time then sitting(Agent)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',228).

 /*  reactive_rule([holds(sittingOn(Agent,Physobj),Time)],
   	      [holds(sitting(Agent),Time)]).
 */


%; State constraints represent that an agent can lie or sit
%; on at most one object at a time:
% [agent,physobj1,physobj2,time]
% HoldsAt(LyingOn(agent,physobj1),time) &
% HoldsAt(LyingOn(agent,physobj2),time) ->
% physobj1=physobj2.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',233).

 /*  (   holds_at(lyingOn(Agent, Physobj1), Time),
       holds_at(lyingOn(Agent, Physobj2), Time)
   ->  equals(Physobj1, Physobj2)
   ).
 */
if lyingOn(Agent, Physobj1)at Time, lyingOn(Agent, Physobj2)at Time then equals(Physobj1, Physobj2).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',233).

 /*  reactive_rule([ holds(lyingOn(Agent,Physobj1),Time),
   		holds(lyingOn(Agent,Physobj2),Time)
   	      ],
   	      [equals(Physobj1,Physobj2)]).
 */


% [agent,physobj1,physobj2,time]
% HoldsAt(SittingOn(agent,physobj1),time) &
% HoldsAt(SittingOn(agent,physobj2),time) ->
% physobj1=physobj2.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',239).

 /*  (   holds_at(sittingOn(Agent, Physobj1), Time),
       holds_at(sittingOn(Agent, Physobj2), Time)
   ->  equals(Physobj1, Physobj2)
   ).
 */
if sittingOn(Agent, Physobj1)at Time, sittingOn(Agent, Physobj2)at Time then equals(Physobj1, Physobj2).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',239).

 /*  reactive_rule([ holds(sittingOn(Agent,Physobj1),Time),
   		holds(sittingOn(Agent,Physobj2),Time)
   	      ],
   	      [equals(Physobj1,Physobj2)]).
 */


%; An effect axiom states that if an agent is standing and
%; lies on a physical object, the agent will be lying on
%; the physical object:
% [agent,physobj,time]
% HoldsAt(Standing(agent),time) ->
% Initiates(LieOn(agent,physobj),
%           LyingOn(agent,physobj),
%           time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',246).

 /*  axiom(initiates(lieOn(Agent, Physobj), lyingOn(Agent, Physobj), Time),
       [standing(Agent)]).
 */

 /*  standing(Standing) ->
       initiates(lieOn(Standing, Lieon),
                 lyingOn(Standing, Lieon),
                 Initiates).
 */
if standing(Standing)then initiates(lieOn(Standing, Lieon), lyingOn(Standing, Lieon)at Initiates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',246).

 /*  reactive_rule([holds(standing(Standing),Holds)],
   	      [ initiates(lieOn(Standing,Lieon),
   			  at(lyingOn(Standing,Lieon),
   			     Initiates),
   			  Initiates7)
   	      ]).
 */


%; An effect axiom states that if an agent
%; lies on a physical object, the agent will no longer
%; be standing:
% [agent,physobj,time]
% Terminates(LieOn(agent,physobj),
%            Standing(agent),
%            time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',255).

 /*  axiom(terminates(lieOn(Agent, Physobj), standing(Agent), Time),
       []).
 */

 /*  terminates(lieOn(Standing,Lieon),
   	   standing(Standing),
   	   Terminates).
 */
lieOn(Standing, Lieon)terminates standing(Standing).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',255).

 /*  terminated(happens(lieOn(Standing,Lieon),
   		   Time_From,
   		   Time_Until),
   	   standing(Standing),
   	   []).
 */


%; An effect axiom states that if an agent is standing and
%; sits on a physical object, the agent will be sitting on
%; the physical object:
% [agent,physobj,time]
% HoldsAt(Standing(agent),time) ->
% Initiates(SitOn(agent,physobj),
%           SittingOn(agent,physobj),
%           time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',263).

 /*  axiom(initiates(sitOn(Agent, Physobj), sittingOn(Agent, Physobj), Time),
       [standing(Agent)]).
 */

 /*  standing(Standing) ->
       initiates(sitOn(Standing, Siton),
                 sittingOn(Standing, Siton),
                 Initiates).
 */
if standing(Standing)then initiates(sitOn(Standing, Siton), sittingOn(Standing, Siton)at Initiates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',263).

 /*  reactive_rule([holds(standing(Standing),Holds)],
   	      [ initiates(sitOn(Standing,Siton),
   			  at(sittingOn(Standing,Siton),
   			     Initiates),
   			  Initiates7)
   	      ]).
 */


%; An effect axiom states that if an agent
%; sits on a physical object, the agent will no longer
%; be standing:
% [agent,physobj,time]
% Terminates(SitOn(agent,physobj),
%            Standing(agent),
%            time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',272).

 /*  axiom(terminates(sitOn(Agent, Physobj), standing(Agent), Time),
       []).
 */

 /*  terminates(sitOn(Standing,Siton),
   	   standing(Standing),
   	   Terminates).
 */
sitOn(Standing, Siton)terminates standing(Standing).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',272).

 /*  terminated(happens(sitOn(Standing,Siton),
   		   Time_From,
   		   Time_Until),
   	   standing(Standing),
   	   []).
 */


%; An effect axiom states that if an agent
%; is sitting or lying on a physical object and
%; the agent rises from the physical object,
%; the agent will be standing:
% [agent,physobj,time]
% (HoldsAt(SittingOn(agent,physobj),time) |
%  HoldsAt(LyingOn(agent,physobj),time)) ->
% Initiates(RiseFrom(agent,physobj),
%           Standing(agent),
%           time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',281).

 /*  axiom(initiates(riseFrom(Agent, Physobj), standing(Agent), Time),
       [  (sittingOn(Agent, Physobj);lyingOn(Agent, Physobj))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',281).

 /*  sittingOn(Standing, Sittingon);lyingOn(Standing, Sittingon) ->
       initiates(riseFrom(Standing, Sittingon),
                 standing(Standing),
                 Initiates).
 */
if sittingOn(Standing, Sittingon);lyingOn(Standing, Sittingon)then initiates(riseFrom(Standing, Sittingon), standing(Standing)at Initiates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',281).

 /*   reactive_rule([  (sittingOn(Standing, Sittingon);lyingOn(Standing, Sittingon))
                    ],
                    [ initiates(riseFrom(Standing, Sittingon),
                                at(standing(Standing), Initiates),
                                Initiates6)
                    ]).
 */


%; An effect axiom states that if an agent is sitting on
%; a physical object and the agent rises from the physical
%; object, the agent will no longer be sitting on the
%; physical object:
% [agent,physobj,time]
% HoldsAt(SittingOn(agent,physobj),time) ->
% Terminates(RiseFrom(agent,physobj),
%            SittingOn(agent,physobj),
%            time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',292).

 /*  axiom(terminates(riseFrom(Agent, Physobj), sittingOn(Agent, Physobj), Time),
       [sittingOn(Agent, Physobj)]).
 */

 /*  sittingOn(A, Sittingon) ->
       terminates(riseFrom(A, Sittingon),
                  sittingOn(A, Sittingon),
                  Terminates).
 */
if sittingOn(A, Sittingon)then terminates(riseFrom(A, Sittingon), sittingOn(A, Sittingon)at Terminates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',292).

 /*  reactive_rule([holds(sittingOn(A,Sittingon),Holds)],
   	      [ terminates(riseFrom(A,Sittingon),
   			   at(sittingOn(A,Sittingon),
   			      Terminates),
   			   Terminates6)
   	      ]).
 */


%; An effect axiom states that if an agent is lying on
%; a physical object and the agent rises from the physical
%; object, the agent will no longer be lying on the
%; physical object:
% [agent,physobj,time]
% HoldsAt(LyingOn(agent,physobj),time) ->
% Terminates(RiseFrom(agent,physobj),
%            LyingOn(agent,physobj),
%            time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',302).

 /*  axiom(terminates(riseFrom(Agent, Physobj), lyingOn(Agent, Physobj), Time),
       [lyingOn(Agent, Physobj)]).
 */

 /*  lyingOn(A, Lyingon) ->
       terminates(riseFrom(A, Lyingon),
                  lyingOn(A, Lyingon),
                  Terminates).
 */
if lyingOn(A, Lyingon)then terminates(riseFrom(A, Lyingon), lyingOn(A, Lyingon)at Terminates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',302).

 /*  reactive_rule([holds(lyingOn(A,Lyingon),Holds)],
   	      [ terminates(riseFrom(A,Lyingon),
   			   at(lyingOn(A,Lyingon),
   			      Terminates),
   			   Terminates6)
   	      ]).
 */


%; dressing
%; agent gets undressed.

% event GetDressed(agent)
 %  event(getDressed(agent)).
 %  event(getDressed(agent)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',310).
actions([getDressed/1]).
mpred_prop(getDressed(agent),event).


%; agent gets dressed.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',313).
% event GetUndressed(agent)
 %  event(getUndressed(agent)).
 %  event(getUndressed(agent)).
actions([getUndressed/1]).
mpred_prop(getUndressed(agent),event).


%; agent is dressed.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',315).
% fluent Dressed(agent)
 %  fluent(dressed(agent)).
 %  fluent(dressed(agent)).
fluents([dressed/1]).
mpred_prop(dressed(agent),fluent).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',317).
%; Effect axioms deal with getting dressed and undressed:
% [agent,time]
 % Initiates(GetDressed(agent),Dressed(agent),time).

 /*  axiom(initiates(getDressed(Agent), dressed(Agent), Time),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',317).

 /*  initiates(getDressed(Getdressed),
   	  dressed(Getdressed),
   	  Initiates).
 */
getDressed(Getdressed)initiates dressed(Getdressed).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',317).

 /*  initiated(happens(getDressed(Getdressed),
   		  Time_From,
   		  Time_Until),
   	  dressed(Getdressed),
   	  []).
 */


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',319).
% [agent,time]
 % Terminates(GetUndressed(agent),Dressed(agent),time).

 /*  axiom(terminates(getUndressed(Agent), dressed(Agent), Time),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',319).

 /*  terminates(getUndressed(Getundressed),
   	   dressed(Getundressed),
   	   Terminates).
 */
getUndressed(Getundressed)terminates dressed(Getundressed).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',319).

 /*  terminated(happens(getUndressed(Getundressed),
   		   Time_From,
   		   Time_Until),
   	   dressed(Getundressed),
   	   []).
 */


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',321).
%; End of file.
:- endif.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',41).
% fire Fire1
 %  t(fire,fire1).
fire(fire1).


% HoldsAt(At(Fire1,Outside1),0).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',41).

 /*  axiom(initially(at(fire1, outside1)),
       []).
 */
 %  initially(at(fire1,outside1)).
initially loc_at(fire1, outside1).
 %  initial_state([loc_at(fire1,outside1)]).

% agent Perp1
 %  t(agent,perp1).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',43).
agent(perp1).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',46).
% physobj PhysTarget1
 %  t(physobj,physTarget1).
physobj(physTarget1).


% HoldsAt(Intact(PhysTarget1),0).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',46).

 /*  axiom(initially(intact(physTarget1)),
       []).
 */
initially intact(physTarget1).
 %  initial_state([intact(physTarget1)]).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',48).
% HoldsAt(At(PhysTarget1,Outside1),0).

 /*  axiom(initially(at(physTarget1, outside1)),
       []).
 */
 %  initially(at(physTarget1,outside1)).
initially loc_at(physTarget1, outside1).
 %  initial_state([loc_at(physTarget1,outside1)]).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',50).
%; room-scale topological space

% outside Outside1
 %  t(outside,outside1).
outside(outside1).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',52).
% outside Outside2
 %  t(outside,outside2).
outside(outside2).

% room Inside1
 %  t(room,inside1).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',52).
room(inside1).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',54).
% door Door1
 %  t(door,door1).
door(door1).

% building Building1
 %  t(building,building1).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',54).
building(building1).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',56).
% street Street1
 %  t(street,street1).
street(street1).


% Side1(Door1)=Outside1.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',56).

 /*  axiom(side1Pred(door1, outside1),
       []).
 */
side1Pred(door1,outside1).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',58).
% Side2(Door1)=Inside1.

 /*  axiom(side2Pred(door1, inside1),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',58).
side2Pred(door1,inside1).


% LookOutOnto(Inside1)=Outside1.

 /*  axiom(lookOutOntoPred(inside1, outside1),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',58).
lookOutOntoPred(inside1,outside1).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',60).
% Floor(Inside1)=1.

 /*  axiom(floorPred(inside1, 1),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',60).
floorPred(inside1,1).


% BuildingOf(Inside1)=Building1.

 /*  axiom(building(inside1, building1),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',60).
building(inside1,building1).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',62).
% Side1(Street1)=Outside1.

 /*  axiom(side1Pred(street1, outside1),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',62).
side1Pred(street1,outside1).


% Side2(Street1)=Outside2.

 /*  axiom(side2Pred(street1, outside2),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',62).
side2Pred(street1,outside2).


% HoldsAt(Alive(Perp1),0).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',64).

 /*  axiom(initially(alive(perp1)),
       []).
 */
initially alive(perp1).
 %  initial_state([alive(perp1)]).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',66).
% HoldsAt(Awake(Perp1),0).

 /*  axiom(initially(awake(perp1)),
       []).
 */
initially awake(perp1).
 %  initial_state([awake(perp1)]).


% HoldsAt(Standing(Perp1),0).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',66).

 /*  axiom(initially(standing(perp1)),
       []).
 */
initially standing(perp1).
 %  initial_state([standing(perp1)]).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',68).
% HoldsAt(Sleep2(Perp1),0).

 /*  axiom(initially(sleep2(perp1)),
       []).
 */
initially sleep2(perp1).
 %  initial_state([sleep2(perp1)]).


% !HoldsAt(Injured(Perp1),0).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',68).

 /*  axiom(initially(neg(injured(perp1))),
       []).
 */
 %  initially(neg(injured(perp1))).
initially not injured(perp1).
 %  initial_state([not(injured(perp1))]).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',70).
% [object]
 % !HoldsAt(Holding(Perp1,object),0).

 /*  axiom(initially(neg(holding(perp1, Object))),
       []).
 */
 %  initially(neg(holding(perp1,Holding))).
initially not holding(perp1, Holding).
 %  initial_state([not(holding(perp1,Holding))]).


% HoldsAt(At(Perp1,Outside2),0).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',70).

 /*  axiom(initially(at(perp1, outside2)),
       []).
 */
 %  initially(at(perp1,outside2)).
initially loc_at(perp1, outside2).
 %  initial_state([loc_at(perp1,outside2)]).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',72).
% !HoldsAt(DoorIsOpen(Door1),0).

 /*  axiom(initially(neg(doorIsOpen(door1))),
       []).
 */
 %  initially(neg(doorIsOpen(door1))).
initially not doorIsOpen(door1).
 %  initial_state([not(doorIsOpen(door1))]).


% HoldsAt(DoorUnlocked(Door1),0).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',72).

 /*  axiom(initially(doorUnlocked(door1)),
       []).
 */
initially doorUnlocked(door1).
 %  initial_state([doorUnlocked(door1)]).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',74).
% [physobj,fire,offset]
 % !HoldsAt(Burning(physobj,fire,offset),0).

 /*  axiom(initially(neg(burning(Physobj, Fire, Offset))),
       []).
 */
 %  initially(neg(burning(BurningP_Num3_V,_,Burning))).
initially not burning(BurningP_Num3_V, _, Burning).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',74).

 /*  initial_state([ not(burning(BurningP_Num3_V,
   			    _,
   			    Burning))
   	      ]).
 */


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',76).
%; narrative


% Happens(WalkStreet21(Perp1,Street1),0).

 /*  axiom(happens(walkStreet21(perp1, street1), start),
       []).
 */
 %  happens(walkStreet21(perp1,street1),start).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',76).
observe(at(walkStreet21(perp1,street1),start)).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',78).
% Happens(SetFireTo(Perp1,PhysTarget1,Fire1,3),1).

 /*  axiom(happens(setFireTo(perp1, physTarget1, fire1, 3), When),
       [b(start, When)]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',78).

 /*  b(start, When1) ->
       happens(setFireTo(perp1, physTarget1, fire1, 3), When1).
 */
if b(start, When1)then happens(setFireTo(perp1, physTarget1, fire1, 3), When1).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',78).

 /*  reactive_rule([b(start,When1)],
   	      [ happens(setFireTo(perp1,physTarget1,fire1,3),
   			When1)
   	      ]).
 */


% Happens(WalkStreet12(Perp1,Street1),2).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',78).

 /*  axiom(happens(walkStreet12(perp1, street1), Start_Num2),
       [b(start, Start_Num2), toffset(start, 2, Start_Num2)]).
 */

 /*  (   b(start, When),
       toffset(start, 2, When)
   ->  happens(walkStreet12(perp1, street1), When)
   ).
 */
if b(start, When), toffset(start, 2, When)then happens(walkStreet12(perp1, street1), When).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',78).

 /*  reactive_rule([b(start,When),toffset(start,2,When)],
   	      [happens(walkStreet12(perp1,street1),When)]).
 */

% range time 0 6
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',80).
range(time,0,6).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',82).
% range offset 0 3
range(offset,0,3).

% range diameter 0 0
range(diameter,0,0).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e',85).
% completion Happens
completion(happens).
%; End of file.
% translate: ending  File: /pack/logicmoo_ec/ext/ec_sources/ecnet/Arson.e.lps 
