:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Fire.e',124).
% translate: unskipped  File: /pack/logicmoo_ec/ext/ec_sources/ecnet/GSpace.e.lps 
:-include(library('ec_planner/ec_test_incl')).
:-expects_dialect(lps).
% translate: begining  File: /pack/logicmoo_ec/ext/ec_sources/ecnet/GSpace.e.lps 
% Thu, 08 Oct 2020 21:36:18 GMT File: <stream>(0x55894c1dc800)%;
%; Copyright (c) 2005 IBM Corporation and others.
%; All rights reserved. This program and the accompanying materials
%; are made available under the terms of the Common Public License v1.0
%; which accompanies this distribution, and is available at
%; http://www.eclipse.org/legal/cpl-v10.html
%;
%; Contributors:
%; IBM - Initial implementation
%;
%; GSpace: grid space
%;
%; @book{Mueller:1998,
%;   author = "Erik T. Mueller",
%;   year = "1998",
%;   title = "Natural Language Processing with \uppercase{T}hought\uppercase{T}reasure",
%;   address = "New York",
%;   publisher = "Signiform",
%; }
%;

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/GSpace.e',22).
% sort coord: integer
% subsort(coord,integer).
subsort(coord,integer).

% sort grid
% sort(grid).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/GSpace.e',22).
sort(grid).
%; object is at (coord1, coord2) in grid.

% fluent GridAt(grid,object,coord,coord)
% fluent(
%    gridAt(grid,object,coord,coord)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/GSpace.e',25).
fluents([gridAt/4]).
% mpred_prop(
%    gridAt(grid,object,coord,coord), 
%    fluent).
mpred_prop(gridAt(grid,object,coord,coord),fluent).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/GSpace.e',28).
%; agent walks from (coord1, coord2)
%; to (coord3, coord4) in grid.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/GSpace.e',30).
% event GridWalk(grid,agent,coord,coord,coord,coord)
% event(
%    gridWalk(grid,agent,coord,coord,coord,coord)).
events([gridWalk/6]).
% mpred_prop(
%    gridWalk(grid,agent,coord,coord,coord,coord), 
%    event).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/GSpace.e',30).
mpred_prop(gridWalk(grid,agent,coord,coord,coord,coord),event).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/GSpace.e',32).
%; A state constraint says that for a given grid an
%; object is at one cell in that grid at a time:
% [grid,object,coord1,coord2,coord3,coord4,time]
% HoldsAt(GridAt(grid,object,coord1,coord2),time) &
% HoldsAt(GridAt(grid,object,coord3,coord4),time) ->
% coord1=coord3 & coord2=coord4.
% '->'(
%    ','(
%       gridAt(Grid,Object,Coord3,Coord4), 
%       ';'(
%          not(
%             equals(Coord1,Coord3)), 
%          not(
%             equals(Coord2,Coord4)))), 
%    not(
%       gridAt(Grid,Object,Coord1,Coord2))).
not gridAt(Grid, Object, Coord1, Coord2)if gridAt(Grid, Object, Coord3, Coord4), (not equals(Coord1, Coord3);not equals(Coord2, Coord4)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/GSpace.e',34).

 /*   l_int(holds(not(gridAt(Grid, Object, Coord1, Coord2)),
                  Time_At),
            [ holds(gridAt(Grid, Object, Coord3, Coord4),
                    Time_At),
               (not(equals(Coord1, Coord3));not(equals(Coord2, Coord4)))
            ]).
 */
 %  "% =================================".
% '->'(
%    ','(
%       gridAt(Grid,Object,Coord1,Coord2), 
%       ';'(
%          not(
%             equals(Coord3,Coord1)), 
%          not(
%             equals(Coord4,Coord2)))), 
%    not(
%       gridAt(Grid,Object,Coord3,Coord4))).
not gridAt(Grid, Object, Coord3, Coord4)if gridAt(Grid, Object, Coord1, Coord2), (not equals(Coord3, Coord1);not equals(Coord4, Coord2)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/GSpace.e',34).

 /*   l_int(holds(not(gridAt(Grid, Object, Coord3, Coord4)),
                  Time_At8),
            [ holds(gridAt(Grid, Object, Coord1, Coord2),
                    Time_At8),
               (not(equals(Coord3, Coord1));not(equals(Coord4, Coord2)))
            ]).
 */
 %  "% =================================".


%; An effect axiom states that
%; if an agent walks from one cell in a grid to another cell,
%; the agent will be at second cell:
% [grid,agent,coord1,coord2,coord3,coord4,time]
% Initiates(GridWalk(grid,agent,coord1,coord2,coord3,coord4),
%           GridAt(grid,agent,coord3,coord4),
%           time).
% initiates(
%    gridWalk(Grid,Agent,Coord1,Coord2,Coord3,Coord4), 
%    gridAt(Grid,Agent,Coord3,Coord4), 
%    Time).
gridWalk(Grid, Agent, Coord1, Coord2, Coord3, Coord4)initiates gridAt(Grid, Agent, Coord3, Coord4).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/GSpace.e',42).

 /*  initiated(happens(gridWalk(Grid,
   			   Agent,
   			   Coord1,
   			   Coord2,
   			   Coord3,
   			   Coord4),
   		  Time_From,
   		  Time_Until),
   	  gridAt(Grid,Agent,Coord3,Coord4),
   	  []).
 */
 %  "% =================================".


%; An effect axiom states that
%; if an agent walks from one cell in a grid to another cell,
%; the agent will no longer be at the first cell:
% [grid,agent,coord1,coord2,coord3,coord4,time]
% Terminates(GridWalk(grid,agent,coord1,coord2,coord3,coord4),
%            GridAt(grid,agent,coord1,coord2),
%            time).
% terminates(
%    gridWalk(Grid,Agent,Coord1,Coord2,Coord3,Coord4), 
%    gridAt(Grid,Agent,Coord1,Coord2), 
%    Time).
gridWalk(Grid, Agent, Coord1, Coord2, Coord3, Coord4)terminates gridAt(Grid, Agent, Coord1, Coord2).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/GSpace.e',50).

 /*  terminated(happens(gridWalk(Grid,
   			    Agent,
   			    Coord1,
   			    Coord2,
   			    Coord3,
   			    Coord4),
   		   Time_From,
   		   Time_Until),
   	   gridAt(Grid,Agent,Coord1,Coord2),
   	   []).
 */
 %  "% =================================".


%; A precondition axiom states that for an agent to walk
%; from one cell in a grid to another cell, the agent
%; must be at the first cell, the second cell must not
%; be occupied, and the first cell must be adjacent to
%; the second cell:
% [grid,agent,coord1,coord2,coord3,coord4,time]
% Happens(GridWalk(grid,agent,coord1,coord2,coord3,coord4),time) ->
% HoldsAt(GridAt(grid,agent,coord1,coord2),time) &
% (!{object} HoldsAt(GridAt(grid,object,coord3,coord4),time)) &
% (coord1=coord3 |
%  coord1=coord3+1 |
%  coord1=coord3-1) &
% (coord2=coord4 |
%  coord2=coord4+1 |
%  coord2=coord4-1).
% '->'(
%    ';'(
%       not(
%          gridAt(Grid,Agent,Coord1,Coord2)), 
%       ';'(
%          gridAt(Grid,Object,Coord3,Coord4), 
%          ';'(
%             ','(
%                not(
%                   equals(Coord1,Coord3)), 
%                ','(
%                   not(
%                      '+Pred'(Coord3,1,Coord1)), 
%                   not(
%                      '-Pred'(Coord3,1,Coord1)))), 
%             ','(
%                not(
%                   equals(Coord2,Coord4)), 
%                ','(
%                   not(
%                      '+Pred'(Coord4,1,Coord2)), 
%                   not(
%                      '-Pred'(Coord4,1,Coord2))))))), 
%    not(
%       gridWalk(Grid,Agent,Coord1,Coord2,Coord3,Coord4))).
if not gridAt(Grid, Agent, Coord1, Coord2);gridAt(Grid, Object, Coord3, Coord4);not equals(Coord1, Coord3), not'+Pred'(Coord3, 1, Coord1), not'-Pred'(Coord3, 1, Coord1);not equals(Coord2, Coord4), not'+Pred'(Coord4, 1, Coord2), not'-Pred'(Coord4, 1, Coord2)then not gridWalk(Grid, Agent, Coord1, Coord2, Coord3, Coord4).
 %  reactive_rule([(not(gridAt(Grid, Agent, Coord1, Coord2));gridAt(Grid, Object, Coord3, Coord4);not(equals(Coord1, Coord3)), not('+Pred'(Coord3, 1, Coord1)), not('-Pred'(Coord3, 1, Coord1));not(equals(Coord2, Coord4)), not('+Pred'(Coord4, 1, Coord2)), not('-Pred'(Coord4, 1, Coord2)))], [not(gridWalk(Grid, Agent, Coord1, Coord2, Coord3, Coord4))]).
 %  "% =================================".
% '->'(
%    metreqs(
%       gridWalk(Grid,Agent,Coord1,Coord2,Coord3,Coord4)), 
%    requires(
%       gridWalk(Grid,Agent,Coord1,Coord2,Coord3,Coord4), 
%       When_Time)).
if gridWalk(Grid, Agent, Coord1, Coord2, Coord3, Coord4)then requires(gridWalk(Grid, Agent, Coord1, Coord2, Coord3, Coord4), When_Time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/GSpace.e',60).

 /*  reactive_rule([ happens(gridWalk(Grid,
   				 Agent,
   				 Coord1,
   				 Coord2,
   				 Coord3,
   				 Coord4),
   			Time_From,
   			Time_Until)
   	      ],
   	      [ requires(gridWalk(Grid,
   				  Agent,
   				  Coord1,
   				  Coord2,
   				  Coord3,
   				  Coord4),
   			 When_Time)
   	      ]).
 */
 %  "% =================================".
% '->'(
%    gridAt(Grid,Agent,Coord1,Coord2), 
%    metreqs(
%       gridWalk(Grid,Agent,Coord1,Coord2,Coord3,Coord4))).
gridWalk(Grid, Agent, Coord1, Coord2, Coord3, Coord4)if gridAt(Grid, Agent, Coord1, Coord2).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/GSpace.e',60).

 /*  l_events(happens(gridWalk(Grid,
   			  Agent,
   			  Coord1,
   			  Coord2,
   			  Coord3,
   			  Coord4),
   		 Time_From11,
   		 Time_From11),
   	 [ holds(gridAt(Grid,
   			Agent,
   			Coord1,
   			Coord2),
   		 Time_From11)
   	 ]).
 */
 %  "% =================================".
% '->'(
%    metreqs(
%       gridWalk(Grid,Agent,Coord1,Coord2,Coord3,Coord4)), 
%    requires(
%       gridWalk(Grid,Agent,Coord1,Coord2,Coord3,Coord4), 
%       When_Time)).
if gridWalk(Grid, Agent, Coord1, Coord2, Coord3, Coord4)then requires(gridWalk(Grid, Agent, Coord1, Coord2, Coord3, Coord4), When_Time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/GSpace.e',60).

 /*  reactive_rule([ happens(gridWalk(Grid,
   				 Agent,
   				 Coord1,
   				 Coord2,
   				 Coord3,
   				 Coord4),
   			Time_From12,
   			Time_Until13)
   	      ],
   	      [ requires(gridWalk(Grid,
   				  Agent,
   				  Coord1,
   				  Coord2,
   				  Coord3,
   				  Coord4),
   			 When_Time)
   	      ]).
 */
 %  "% =================================".
% '->'(
%    not(
%       gridAt(Grid,Object,Coord3,Coord4)), 
%    metreqs(
%       gridWalk(Grid,Agent,Coord1,Coord2,Coord3,Coord4))).
gridWalk(Grid, Agent, Coord1, Coord2, Coord3, Coord4)if not gridAt(Grid, Object, Coord3, Coord4).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/GSpace.e',60).

 /*  l_events(happens(gridWalk(Grid,
   			  Agent,
   			  Coord1,
   			  Coord2,
   			  Coord3,
   			  Coord4),
   		 Time_From14,
   		 Time_From14),
   	 [ holds(not(gridAt(Grid,
   			    Object,
   			    Coord3,
   			    Coord4)),
   		 Time_From14)
   	 ]).
 */
 %  "% =================================".
% '->'(
%    ','(
%       not(
%          '-Pred'(Coord3,1,Coord1)), 
%       ','(
%          not(
%             equals(Coord1,Coord3)), 
%          gridWalk(Grid,Agent,Coord1,Coord2,Coord3,Coord4))), 
%    '+Pred'(Coord3,1,Coord1)).
if not'-Pred'(Coord3, 1, Coord1), not equals(Coord1, Coord3), gridWalk(Grid, Agent, Coord1, Coord2, Coord3, Coord4)then'+Pred'(Coord3, 1, Coord1).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/GSpace.e',60).

 /*  reactive_rule([ not('-Pred'(Coord3,1,Coord1)),
   		not(equals(Coord1,Coord3)),
   		happens(gridWalk(Grid,
   				 Agent,
   				 Coord1,
   				 Coord2,
   				 Coord3,
   				 Coord4),
   			Time_From15,
   			Time_Until16)
   	      ],
   	      ['+Pred'(Coord3,1,Coord1)]).
 */
 %  "% =================================".
% '->'(
%    ','(
%       not(
%          '+Pred'(Coord3,1,Coord1)), 
%       ','(
%          not(
%             equals(Coord1,Coord3)), 
%          gridWalk(Grid,Agent,Coord1,Coord2,Coord3,Coord4))), 
%    '-Pred'(Coord3,1,Coord1)).
if not'+Pred'(Coord3, 1, Coord1), not equals(Coord1, Coord3), gridWalk(Grid, Agent, Coord1, Coord2, Coord3, Coord4)then'-Pred'(Coord3, 1, Coord1).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/GSpace.e',60).

 /*  reactive_rule([ not('+Pred'(Coord3,1,Coord1)),
   		not(equals(Coord1,Coord3)),
   		happens(gridWalk(Grid,
   				 Agent,
   				 Coord1,
   				 Coord2,
   				 Coord3,
   				 Coord4),
   			Time_From17,
   			Time_Until18)
   	      ],
   	      ['-Pred'(Coord3,1,Coord1)]).
 */
 %  "% =================================".
% '->'(
%    ','(
%       not(
%          '-Pred'(Coord4,1,Coord2)), 
%       ','(
%          not(
%             equals(Coord2,Coord4)), 
%          gridWalk(Grid,Agent,Coord1,Coord2,Coord3,Coord4))), 
%    '+Pred'(Coord4,1,Coord2)).
if not'-Pred'(Coord4, 1, Coord2), not equals(Coord2, Coord4), gridWalk(Grid, Agent, Coord1, Coord2, Coord3, Coord4)then'+Pred'(Coord4, 1, Coord2).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/GSpace.e',60).

 /*  reactive_rule([ not('-Pred'(Coord4,1,Coord2)),
   		not(equals(Coord2,Coord4)),
   		happens(gridWalk(Grid,
   				 Agent,
   				 Coord1,
   				 Coord2,
   				 Coord3,
   				 Coord4),
   			Time_From19,
   			Time_Until20)
   	      ],
   	      ['+Pred'(Coord4,1,Coord2)]).
 */
 %  "% =================================".
% '->'(
%    ','(
%       not(
%          '+Pred'(Coord4,1,Coord2)), 
%       ','(
%          not(
%             equals(Coord2,Coord4)), 
%          gridWalk(Grid,Agent,Coord1,Coord2,Coord3,Coord4))), 
%    '-Pred'(Coord4,1,Coord2)).
if not'+Pred'(Coord4, 1, Coord2), not equals(Coord2, Coord4), gridWalk(Grid, Agent, Coord1, Coord2, Coord3, Coord4)then'-Pred'(Coord4, 1, Coord2).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/GSpace.e',60).

 /*  reactive_rule([ not('+Pred'(Coord4,1,Coord2)),
   		not(equals(Coord2,Coord4)),
   		happens(gridWalk(Grid,
   				 Agent,
   				 Coord1,
   				 Coord2,
   				 Coord3,
   				 Coord4),
   			Time_From21,
   			Time_Until22)
   	      ],
   	      ['-Pred'(Coord4,1,Coord2)]).
 */
 %  "% =================================".


%; End of file.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/GSpace.e',70).
% translate: ending  File: /pack/logicmoo_ec/ext/ec_sources/ecnet/GSpace.e.lps 
