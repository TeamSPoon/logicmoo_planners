:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Dress.e',57).
% translate: unskipped  File: /pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e.lps 
:-include(library('ec_planner/ec_test_incl')).
:-expects_dialect(lps).
% translate: begining  File: /pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e.lps 
% Wed, 07 Oct 2020 20:49:25 GMT File: <stream>(0x55afad5c4400)%;
%; Copyright (c) 2005 IBM Corporation and others.
%; All rights reserved. This program and the accompanying materials
%; are made available under the terms of the Common Public License v1.0
%; which accompanies this distribution, and is available at
%; http://www.eclipse.org/legal/cpl-v10.html
%;
%; Contributors:
%; IBM - Initial implementation
%;
%; @article{Mueller:2004c,
%;   author = "Erik T. Mueller",
%;   year = "2004",
%;   title = "Understanding script-based stories using commonsense reasoning",
%;   journal = "Cognitive Systems Research",
%;   volume = "5",
%;   number = "4",
%;   pages = "307--340",
%; }
%;

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',22).
% option modeldiff on
:- if(is_e_toplevel).
:- set_ec_option(modeldiff, on).
:- endif.

% option encoding 3
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',22).
:- if(is_e_toplevel).
:- set_ec_option(encoding, 3).
:- endif.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',24).
% option renaming off
:- if(is_e_toplevel).
:- set_ec_option(renaming, off).
:- endif.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',26).
% ignore Love, ThreatenedBy

 /*  axiom(ignore(love),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',26).
ignore(love).

 /*  axiom(ignore(threatenedBy),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',26).
ignore(threatenedBy).

% ignore LookOutOnto, Floor, BuildingOf, SkyOf, GroundOf

 /*  axiom(ignore(lookOutOnto),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',26).
ignore(lookOutOnto).

 /*  axiom(ignore(floor),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',26).
ignore(floor).

 /*  axiom(ignore(buildingOf),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',26).
ignore(buildingOf).

 /*  axiom(ignore(skyOf),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',26).
ignore(skyOf).

 /*  axiom(ignore(groundOf),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',26).
ignore(groundOf).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',28).
% ignore Inside

 /*  axiom(ignore(inside),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',28).
ignore(inside).

% ignore Near, WalkFrom, WalkFromTo, RunFromTo

 /*  axiom(ignore(near),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',28).
ignore(near).

 /*  axiom(ignore(walkFrom),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',28).
ignore(walkFrom).

 /*  axiom(ignore(walkFromTo),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',28).
ignore(walkFromTo).

 /*  axiom(ignore(runFromTo),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',28).
ignore(runFromTo).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',30).
% ignore BillOf, CookOf, TableOf, WaiterOf, KitchenDoorOf

 /*  axiom(ignore(billOf),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',30).
ignore(billOf).

 /*  axiom(ignore(cookOf),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',30).
ignore(cookOf).

 /*  axiom(ignore(tableOf),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',30).
ignore(tableOf).

 /*  axiom(ignore(waiterOf),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',30).
ignore(waiterOf).

 /*  axiom(ignore(kitchenDoorOf),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',30).
ignore(kitchenDoorOf).

% ignore BeWaiter0, BeWaiter1, BeWaiter2, BeWaiter3, BeWaiter4

 /*  axiom(ignore(beWaiter0),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',30).
ignore(beWaiter0).

 /*  axiom(ignore(beWaiter1),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',30).
ignore(beWaiter1).

 /*  axiom(ignore(beWaiter2),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',30).
ignore(beWaiter2).

 /*  axiom(ignore(beWaiter3),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',30).
ignore(beWaiter3).

 /*  axiom(ignore(beWaiter4),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',30).
ignore(beWaiter4).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',32).
% ignore BeWaiter5, BeWaiter6, BeWaiter7, BeWaiter8, BeWaiter9

 /*  axiom(ignore(beWaiter5),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',32).
ignore(beWaiter5).

 /*  axiom(ignore(beWaiter6),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',32).
ignore(beWaiter6).

 /*  axiom(ignore(beWaiter7),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',32).
ignore(beWaiter7).

 /*  axiom(ignore(beWaiter8),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',32).
ignore(beWaiter8).

 /*  axiom(ignore(beWaiter9),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',32).
ignore(beWaiter9).

% ignore BeCook0, BeCook1

 /*  axiom(ignore(beCook0),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',32).
ignore(beCook0).

 /*  axiom(ignore(beCook1),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',32).
ignore(beCook1).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',34).
% ignore InviteIn, InvitedIn, IntendToWalkIn, IntentionToWalkIn

 /*  axiom(ignore(inviteIn),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',34).
ignore(inviteIn).

 /*  axiom(ignore(invitedIn),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',34).
ignore(invitedIn).

 /*  axiom(ignore(intendToWalkIn),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',34).
ignore(intendToWalkIn).

 /*  axiom(ignore(intentionToWalkIn),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',34).
ignore(intentionToWalkIn).

% ignore ActOnIntentionToWalkIn, Greet, SayGoodbye, CryForJoy

 /*  axiom(ignore(actOnIntentionToWalkIn),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',34).
ignore(actOnIntentionToWalkIn).

 /*  axiom(ignore(greet),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',34).
ignore(greet).

 /*  axiom(ignore(sayGoodbye),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',34).
ignore(sayGoodbye).

 /*  axiom(ignore(cryForJoy),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',34).
ignore(cryForJoy).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',36).
% ignore Threaten, ReleaseFromThreat, ThreatenedBy

 /*  axiom(ignore(threaten),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',36).
ignore(threaten).

 /*  axiom(ignore(releaseFromThreat),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',36).
ignore(releaseFromThreat).

 /*  axiom(ignore(threatenedBy),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',36).
ignore(threatenedBy).

% ignore Order, KnowOrder, Request, KnowRequest

 /*  axiom(ignore(order),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',36).
ignore(order).

 /*  axiom(ignore(knowOrder),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',36).
ignore(knowOrder).

 /*  axiom(ignore(request),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',36).
ignore(request).

 /*  axiom(ignore(knowRequest),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',36).
ignore(knowRequest).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',38).
% ignore PutInside, TakeOutOf

 /*  axiom(ignore(putInside),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',38).
ignore(putInside).

 /*  axiom(ignore(takeOutOf),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',38).
ignore(takeOutOf).

% ignore SayPleaseToMeet, Move

 /*  axiom(ignore(sayPleaseToMeet),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',38).
ignore(sayPleaseToMeet).

 /*  axiom(ignore(move),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',38).
ignore(move).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',41).
% load foundations/Root.e
:- if(is_e_toplevel).
:- cond_convert_e(changed, 'foundations/Root.e').
:- endif.

% load foundations/EC.e
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',41).
:- if(is_e_toplevel).
:- cond_convert_e(changed, 'foundations/EC.e').
:- endif.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',43).
% load answers/Mueller2003/Ontology.e
:- if(is_e_toplevel).
:- cond_convert_e(changed, 'answers/Mueller2003/Ontology.e').
 %  loading(changed,'/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e').
%;
%; Copyright (c) 2005 IBM Corporation and others.
%; All rights reserved. This program and the accompanying materials
%; are made available under the terms of the Common Public License v1.0
%; which accompanies this distribution, and is available at
%; http://www.eclipse.org/legal/cpl-v10.html
%;
%; Contributors:
%; IBM - Initial implementation
%;
%; integer
%;

% sort diameter: integer
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',14).
subsort(diameter,integer).
%; object

% sort object
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',18).
sort(object).

% sort agent: object
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',20).
subsort(agent,object).

% sort physobj: object
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',22).
subsort(physobj,object).

% sort bed: physobj
subsort(bed,physobj).

% sort snowflake: physobj
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',24).
subsort(snowflake,physobj).

% sort sky: physobj
subsort(sky,physobj).

% sort stuff: physobj
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',27).
subsort(stuff,physobj).

% sort surface: physobj
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',29).
subsort(surface,physobj).

% sort ground: surface
subsort(ground,surface).

% sort snow: stuff
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',32).
subsort(snow,stuff).

% sort ball
sort(ball).

% sort food: physobj
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',35).
subsort(food,physobj).

% sort fruit: food
subsort(fruit,food).

% sort orange: fruit
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',37).
subsort(orange,fruit).

% sort salad: food
subsort(salad,food).

% sort clothing: physobj
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',40).
subsort(clothing,physobj).

% sort scarf: clothing
subsort(scarf,clothing).

% sort hat: clothing
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',42).
subsort(hat,clothing).

% sort vegetablematter: physobj
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',44).
subsort(vegetablematter,physobj).

% sort coal: vegetablematter
subsort(coal,vegetablematter).

% sort bodypart: physobj
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',47).
subsort(bodypart,physobj).

% sort hand: bodypart
subsort(hand,bodypart).

% sort papertowels: physobj
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',50).
subsort(papertowels,physobj).

% sort device: physobj
subsort(device,physobj).

% sort electronicdevice: device
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',52).
subsort(electronicdevice,device).

% sort lamp: electronicdevice
subsort(lamp,electronicdevice).

% sort cat: physobj
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',55).
subsort(cat,physobj).

% sort horse: physobj
subsort(horse,physobj).

% sort weapon: physobj
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',58).
subsort(weapon,physobj).

% sort gun: weapon
subsort(gun,weapon).

% sort bomb: weapon
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',60).
subsort(bomb,weapon).

% sort bullet: weapon
subsort(bullet,weapon).
%; location

% sort location
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',65).
sort(location).

% sort room: location, outside: location
subsort(room,location).
subsort(outside,location).
%; portal

% sort portal
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',70).
sort(portal).

% sort door: portal, staircase: portal
subsort(door,portal).
subsort(staircase,portal).

% sort street: portal
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',72).
subsort(street,portal).

% sort track: portal
subsort(track,portal).

% sort building
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',75).
sort(building).

% sort fire: object
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',77).
subsort(fire,object).

% sort smoke: physobj
subsort(smoke,physobj).

% sort furniture: physobj
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',80).
subsort(furniture,physobj).

% sort chair: furniture
subsort(chair,furniture).

% sort table: furniture
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',82).
subsort(table,furniture).

% sort bill: physobj
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',84).
subsort(bill,physobj).

% sort ticket: physobj
subsort(ticket,physobj).

% sort envelope: physobj
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',86).
subsort(envelope,physobj).

% sort text: physobj
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',88).
subsort(text,physobj).

% sort book: text
subsort(book,text).

% sort letter: text
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',90).
subsort(letter,text).

% sort menu: text
subsort(menu,text).

% sort paper: physobj
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',93).
subsort(paper,physobj).

% sort content
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',95).
sort(content).

% sort script
sort(script).

% sort container: physobj
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',98).
subsort(container,physobj).

% sort cigarette: physobj
subsort(cigarette,physobj).

% sort ashtray: physobj
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',100).
subsort(ashtray,physobj).

% sort umbrella: physobj
subsort(umbrella,physobj).

% sort pen: physobj
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',103).
subsort(pen,physobj).
%; End of file.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Ontology.e',105).
:- endif.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',44).
% load answers/Mueller2004c/RTSpaceM.e
:- if(is_e_toplevel).
:- cond_convert_e(changed, 'answers/Mueller2004c/RTSpaceM.e').
 %  loading(changed,'/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e').
%;
%; Copyright (c) 2005 IBM Corporation and others.
%; All rights reserved. This program and the accompanying materials
%; are made available under the terms of the Common Public License v1.0
%; which accompanies this distribution, and is available at
%; http://www.eclipse.org/legal/cpl-v10.html
%;
%; Contributors:
%; IBM - Initial implementation
%;
%; RTSpace: room-scale topological space
%;
%; We use topological and metric representations of space,
%; at two levels of granularity---room-scale and object-scale.
%; The RTSpace representation deals with topological space at
%; the scale of rooms and outdoor locations.
%; This representation of space consists of locations, which
%; are connected by portals. There are two types of locations:
%; rooms and outside areas (outsides).
%;
%; object is at location.

% fluent At(object,location)
 %  fluent(at(object,location)).
 %  fluent(at(object,location)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',22).
fluents([loc_at/2]).
 %  mpred_prop(at(object,location),fluent).
mpred_prop(loc_at(object,location),fluent).

% manualrelease At
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',24).

 /*  axiom(manualrelease(at),
       []).
 */
manualrelease(at).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',26).
% [object1,location,time]
% (% {object2} PartOf(object1,object2)) ->
% ReleasedAt(At(object1,location),time).
 %  clausify_pnf=exists([Object2],  (partOf(Object1, Object2)->releasedAt(at(Object1, Location), Time))).

 /*  releasedAt(at(Object1, Location), Time) :-
       partOf(Object1, Exists_Object2),
       some(Exists_Object2,
            '$kolem_Fn_78'(Object1, Location, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',26).

 /*  axiom(releasedAt(at(Object1, Location), Time),
       [ partOf(Object1, Exists_Object2),
         some(Exists_Object2,
              '$kolem_Fn_78'(Object1, Location, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',26).

 /*  (   partOf(Kolem_Fn_78P_Num3_V, Partof),
       some(Partof,
            '$kolem_Fn_78'(Kolem_Fn_78P_Num3_V, Tloc, Time_At))
   ->  releasedAt(at(Kolem_Fn_78P_Num3_V, Tloc), Time_At)
   ).
 */
if partOf(Kolem_Fn_78P_Num3_V, Partof), some(Partof, '$kolem_Fn_78'(Kolem_Fn_78P_Num3_V, Tloc, Time_At))then releasedAt(loc_at(Kolem_Fn_78P_Num3_V, Tloc), Time_At).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',26).

 /*  reactive_rule([ partOf(Kolem_Fn_78P_Num3_V,Partof),
   		some(Partof,
   		     '$kolem_Fn_78'(Kolem_Fn_78P_Num3_V,
   				    Tloc,
   				    Time_At))
   	      ],
   	      [ releasedAt(loc_at(Kolem_Fn_78P_Num3_V,Tloc),
   			   Time_At)
   	      ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',26).

 /*  not(partOf(Object1, Exists_Object2)) :-
       not(releasedAt(at(Object1, Location), Time)),
       some(Exists_Object2,
            '$kolem_Fn_78'(Object1, Location, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',26).

 /*  axiom(not(partOf(Object1, Exists_Object2)),
       [ not(releasedAt(at(Object1, Location), Time)),
         some(Exists_Object2,
              '$kolem_Fn_78'(Object1, Location, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',26).

 /*  (   not(releasedAt(at(Kolem_Fn_78P_Num3_V11, Tloc9),
                      Time_At10)),
       some(Partof12,
            '$kolem_Fn_78'(Kolem_Fn_78P_Num3_V11, Tloc9, Time_At10))
   ->  not(partOf(Kolem_Fn_78P_Num3_V11, Partof12))
   ).
 */
if not releasedAt(loc_at(Kolem_Fn_78P_Num3_V11, Tloc9), Time_At10), some(Partof12, '$kolem_Fn_78'(Kolem_Fn_78P_Num3_V11, Tloc9, Time_At10))then not partOf(Kolem_Fn_78P_Num3_V11, Partof12).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',26).

 /*  reactive_rule([ not(releasedAt(loc_at(Kolem_Fn_78P_Num3_V11,
   				      Tloc9),
   			       Time_At10)),
   		some(Partof12,
   		     '$kolem_Fn_78'(Kolem_Fn_78P_Num3_V11,
   				    Tloc9,
   				    Time_At10))
   	      ],
   	      [not(partOf(Kolem_Fn_78P_Num3_V11,Partof12))]).
 */


%; A state constraint says that an object
%; is at one location at a time:
% [object,location1,location2,time]
% HoldsAt(At(object,location1),time) &
% HoldsAt(At(object,location2),time) ->
% location1=location2.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',32).

 /*  (   holds_at(at(Object, Location1), Time),
       holds_at(at(Object, Location2), Time)
   ->  equals(Location1, Location2)
   ).
 */
if loc_at(Object, Location1)at Time, loc_at(Object, Location2)at Time then equals(Location1, Location2).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',32).

 /*  reactive_rule([ holds(loc_at(Object,Location1),Time),
   		holds(loc_at(Object,Location2),Time)
   	      ],
   	      [equals(Location1,Location2)]).
 */


%; connectivity
%; Side one of portal is location.

% function Side1(portal): location
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',39).

 /*  axiom(function_argtypes(Function_ArgtypesP_Num3_V, side1(portal), location),
       []).
 */
function_argtypes(Function_ArgtypesP_Num3_V1,
		  side1(portal),
		  location).
 %  predicate(side1Pred(portal,location)).
 %  predicate(side1Pred(portal,location)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',39).
predicates([side1Pred/2]).
mpred_prop(side1Pred(portal,location),predicate).

 /*  axiom(functional_predicate(side1, side1Pred),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',39).
functional_predicate(side1,side1Pred).
resultIsa(side1,location).
%; Side two of portal is location.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',42).
% function Side2(portal): location

 /*  axiom(function_argtypes(Function_ArgtypesP_Num3_V, side2(portal), location),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',42).
function_argtypes(Function_ArgtypesP_Num3_V1,
		  side2(portal),
		  location).
 %  predicate(side2Pred(portal,location)).
 %  predicate(side2Pred(portal,location)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',42).
predicates([side2Pred/2]).
mpred_prop(side2Pred(portal,location),predicate).

 /*  axiom(functional_predicate(side2, side2Pred),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',42).
functional_predicate(side2,side2Pred).
resultIsa(side2,location).
%; The building of room is building.

% function BuildingOf(room): building
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',44).

 /*  axiom(function_argtypes(Function_ArgtypesP_Num3_V, buildingOf(room), building),
       []).
 */
function_argtypes(Function_ArgtypesP_Num3_V1,
		  buildingOf(room),
		  building).
 %  predicate(building(room,building)).
 %  predicate(building(room,building)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',44).
predicates([building/2]).
mpred_prop(building(room,building),predicate).

 /*  axiom(functional_predicate(buildingOf, building),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',44).
functional_predicate(buildingOf,building).
resultIsa(buildingOf,building).
%; object is at a location that has portal.

% fluent NearPortal(object,portal)
 %  fluent(nearPortal(object,portal)).
 %  fluent(nearPortal(object,portal)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',47).
fluents([nearPortal/2]).
mpred_prop(nearPortal(object,portal),fluent).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',49).
% noninertial NearPortal
noninertial(nearPortal).
%; A state constraint says that an object is near
%; a portal if and only if there is a location such that
%; the object is at the location and one of the sides
%; of the portal is the location:
% [object,portal,time]
% HoldsAt(NearPortal(object,portal),time) <->
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',55).
% {location}% 
%  (Side1(portal)=location|
%   Side2(portal)=location) &
%  HoldsAt(At(object,location),time).
 %  clausify_pnf=exists([Location], <->(holds_at(nearPortal(Object, Portal), Time),  ((side1Pred(Portal, Location);side2Pred(Portal, Location)), holds_at(at(Object, Location), Time)))).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  not(holds_at(nearPortal(Object, Portal), Time)) :-
       (   not(side1Pred(Portal, Exists_Location)),
           not(side2Pred(Portal, Exists_Location))
       ;   not(holds_at(at(Object, Exists_Location), Time))
       ),
       some(Exists_Location,
            '$kolem_Fn_79'(Object, Portal, Time)).
 */
 %  axiom(not(nearPortal(Object, Portal)), [(not(side1Pred(Portal, Exists_Location)), not(side2Pred(Portal, Exists_Location));not(at(Object, Exists_Location))), some(Exists_Location, '$kolem_Fn_79'(Object, Portal, Time))]).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  (   (   not(side1Pred(Nearportal, Tloc)),
           not(side2Pred(Nearportal, Tloc))
       ;   not(at(Kolem_Fn_79P_Num3_V, Tloc))
       ),
       some(Tloc,
            '$kolem_Fn_79'(Kolem_Fn_79P_Num3_V,
                           Nearportal,
                           Kolem_Fn_79))
   ->  not(nearPortal(Kolem_Fn_79P_Num3_V, Nearportal))
   ).
 */
if (not side1Pred(Nearportal, Tloc), not side2Pred(Nearportal, Tloc);not loc_at(Kolem_Fn_79P_Num3_V, Tloc)), some(Tloc, '$kolem_Fn_79'(Kolem_Fn_79P_Num3_V, Nearportal, Kolem_Fn_79))then not nearPortal(Kolem_Fn_79P_Num3_V, Nearportal).
 %  reactive_rule([(not(side1Pred(Nearportal, Tloc)), not(side2Pred(Nearportal, Tloc));not(loc_at(Kolem_Fn_79P_Num3_V, Tloc))), some(Tloc, '$kolem_Fn_79'(Kolem_Fn_79P_Num3_V, Nearportal, Kolem_Fn_79))], [holds(not(nearPortal(Kolem_Fn_79P_Num3_V, Nearportal)), Holds)]).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  side1Pred(Portal, Exists_Location) :-
       not(side2Pred(Portal, Exists_Location)),
       holds_at(nearPortal(Object, Portal), Time),
       some(Exists_Location,
            '$kolem_Fn_79'(Object, Portal, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  fix_axiom_head(Time) ->
       [ holds_at(nearPortal(Object, Portal), Time),
          (->),
         nearPortal(Object, Portal)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  axiom(side1Pred(Portal, Exists_Location),
       [ not(side2Pred(Portal, Exists_Location)),
         nearPortal(Object, Portal),
         some(Exists_Location,
              '$kolem_Fn_79'(Object, Portal, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  (   not(side2Pred(Nearportal11, Side2pred)),
       nearPortal(Kolem_Fn_79P_Num3_V13, Nearportal11),
       some(Side2pred,
            '$kolem_Fn_79'(Kolem_Fn_79P_Num3_V13,
                           Nearportal11,
                           Kolem_Fn_7912))
   ->  side1Pred(Nearportal11, Side2pred)
   ).
 */
if not side2Pred(Nearportal11, Side2pred), nearPortal(Kolem_Fn_79P_Num3_V13, Nearportal11), some(Side2pred, '$kolem_Fn_79'(Kolem_Fn_79P_Num3_V13, Nearportal11, Kolem_Fn_7912))then side1Pred(Nearportal11, Side2pred).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  reactive_rule([ not(side2Pred(Nearportal11,Side2pred)),
   		holds(nearPortal(Kolem_Fn_79P_Num3_V13,
   				 Nearportal11),
   		      Holds14),
   		some(Side2pred,
   		     '$kolem_Fn_79'(Kolem_Fn_79P_Num3_V13,
   				    Nearportal11,
   				    Kolem_Fn_7912))
   	      ],
   	      [side1Pred(Nearportal11,Side2pred)]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  side2Pred(Portal, Exists_Location) :-
       not(side1Pred(Portal, Exists_Location)),
       holds_at(nearPortal(Object, Portal), Time),
       some(Exists_Location,
            '$kolem_Fn_79'(Object, Portal, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  fix_axiom_head(Time) ->
       [ holds_at(nearPortal(Object, Portal), Time),
          (->),
         nearPortal(Object, Portal)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  axiom(side2Pred(Portal, Exists_Location),
       [ not(side1Pred(Portal, Exists_Location)),
         nearPortal(Object, Portal),
         some(Exists_Location,
              '$kolem_Fn_79'(Object, Portal, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  (   not(side1Pred(Nearportal16, Side1pred)),
       nearPortal(Kolem_Fn_79P_Num3_V18, Nearportal16),
       some(Side1pred,
            '$kolem_Fn_79'(Kolem_Fn_79P_Num3_V18,
                           Nearportal16,
                           Kolem_Fn_7917))
   ->  side2Pred(Nearportal16, Side1pred)
   ).
 */
if not side1Pred(Nearportal16, Side1pred), nearPortal(Kolem_Fn_79P_Num3_V18, Nearportal16), some(Side1pred, '$kolem_Fn_79'(Kolem_Fn_79P_Num3_V18, Nearportal16, Kolem_Fn_7917))then side2Pred(Nearportal16, Side1pred).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  reactive_rule([ not(side1Pred(Nearportal16,Side1pred)),
   		holds(nearPortal(Kolem_Fn_79P_Num3_V18,
   				 Nearportal16),
   		      Holds19),
   		some(Side1pred,
   		     '$kolem_Fn_79'(Kolem_Fn_79P_Num3_V18,
   				    Nearportal16,
   				    Kolem_Fn_7917))
   	      ],
   	      [side2Pred(Nearportal16,Side1pred)]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  holds_at(at(Object, Exists_Location), Time) :-
       holds_at(nearPortal(Object, Portal), Time),
       some(Exists_Location,
            '$kolem_Fn_79'(Object, Portal, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Object, Exists_Location), Time),
          (->),
         at(Object, Exists_Location)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  axiom(at(Object, Exists_Location),
       [ nearPortal(Object, Portal),
         some(Exists_Location,
              '$kolem_Fn_79'(Object, Portal, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  (   nearPortal(Kolem_Fn_79P_Num3_V23, Nearportal21),
       some(Tloc20,
            '$kolem_Fn_79'(Kolem_Fn_79P_Num3_V23,
                           Nearportal21,
                           Kolem_Fn_7922))
   ->  at(Kolem_Fn_79P_Num3_V23, Tloc20)
   ).
 */
if nearPortal(Kolem_Fn_79P_Num3_V23, Nearportal21), some(Tloc20, '$kolem_Fn_79'(Kolem_Fn_79P_Num3_V23, Nearportal21, Kolem_Fn_7922))then loc_at(Kolem_Fn_79P_Num3_V23, Tloc20).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  reactive_rule([ holds(nearPortal(Kolem_Fn_79P_Num3_V23,
   				 Nearportal21),
   		      Holds24),
   		some(Tloc20,
   		     '$kolem_Fn_79'(Kolem_Fn_79P_Num3_V23,
   				    Nearportal21,
   				    Kolem_Fn_7922))
   	      ],
   	      [ holds(loc_at(Kolem_Fn_79P_Num3_V23,Tloc20),
   		      Holds25)
   	      ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  holds_at(nearPortal(Object, Portal), Time) :-
       holds_at(at(Object, Exists_Location), Time),
       (   side1Pred(Portal, Exists_Location)
       ;   side2Pred(Portal, Exists_Location)
       ),
       some(Exists_Location,
            '$kolem_Fn_79'(Object, Portal, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  fix_axiom_head(Time) ->
       [ holds_at(nearPortal(Object, Portal), Time),
          (->),
         nearPortal(Object, Portal)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  axiom(nearPortal(Object, Portal),
       [ at(Object, Exists_Location),
          (side1Pred(Portal, Exists_Location);side2Pred(Portal, Exists_Location)),
         some(Exists_Location,
              '$kolem_Fn_79'(Object, Portal, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  (   at(Kolem_Fn_79P_Num3_V28, Tloc26),
       (   side1Pred(Nearportal29, Tloc26)
       ;   side2Pred(Nearportal29, Tloc26)
       ),
       some(Tloc26,
            '$kolem_Fn_79'(Kolem_Fn_79P_Num3_V28,
                           Nearportal29,
                           Kolem_Fn_7927))
   ->  nearPortal(Kolem_Fn_79P_Num3_V28, Nearportal29)
   ).
 */
if loc_at(Kolem_Fn_79P_Num3_V28, Tloc26), (side1Pred(Nearportal29, Tloc26);side2Pred(Nearportal29, Tloc26)), some(Tloc26, '$kolem_Fn_79'(Kolem_Fn_79P_Num3_V28, Nearportal29, Kolem_Fn_7927))then nearPortal(Kolem_Fn_79P_Num3_V28, Nearportal29).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*   reactive_rule([ holds(loc_at(Kolem_Fn_79P_Num3_V28, Tloc26),
                            Holds30),
                       (side1Pred(Nearportal29, Tloc26);side2Pred(Nearportal29, Tloc26)),
                      some(Tloc26,
                           '$kolem_Fn_79'(Kolem_Fn_79P_Num3_V28,
                                          Nearportal29,
                                          Kolem_Fn_7927))
                    ],
                    [ holds(nearPortal(Kolem_Fn_79P_Num3_V28,
                                       Nearportal29),
                            Holds31)
                    ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  not(holds_at(at(Object, Exists_Location), Time)) :-
       (   side1Pred(Portal, Exists_Location)
       ;   side2Pred(Portal, Exists_Location)
       ),
       not(holds_at(nearPortal(Object, Portal), Time)),
       some(Exists_Location,
            '$kolem_Fn_79'(Object, Portal, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  axiom(not(at(Object, Exists_Location)),
       [  (side1Pred(Portal, Exists_Location);side2Pred(Portal, Exists_Location)),
         not(nearPortal(Object, Portal)),
         some(Exists_Location,
              '$kolem_Fn_79'(Object, Portal, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  (   (   side1Pred(Nearportal33, Tloc32)
       ;   side2Pred(Nearportal33, Tloc32)
       ),
       not(nearPortal(Kolem_Fn_79P_Num3_V35, Nearportal33)),
       some(Tloc32,
            '$kolem_Fn_79'(Kolem_Fn_79P_Num3_V35,
                           Nearportal33,
                           Kolem_Fn_7934))
   ->  not(at(Kolem_Fn_79P_Num3_V35, Tloc32))
   ).
 */
if (side1Pred(Nearportal33, Tloc32);side2Pred(Nearportal33, Tloc32)), not nearPortal(Kolem_Fn_79P_Num3_V35, Nearportal33), some(Tloc32, '$kolem_Fn_79'(Kolem_Fn_79P_Num3_V35, Nearportal33, Kolem_Fn_7934))then not loc_at(Kolem_Fn_79P_Num3_V35, Tloc32).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*   reactive_rule([  (side1Pred(Nearportal33, Tloc32);side2Pred(Nearportal33, Tloc32)),
                      holds(not(nearPortal(Kolem_Fn_79P_Num3_V35,
                                           Nearportal33)),
                            Holds36),
                      some(Tloc32,
                           '$kolem_Fn_79'(Kolem_Fn_79P_Num3_V35,
                                          Nearportal33,
                                          Kolem_Fn_7934))
                    ],
                    [ holds(not(loc_at(Kolem_Fn_79P_Num3_V35, Tloc32)),
                            Holds37)
                    ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  not(side1Pred(Portal, Exists_Location)) :-
       holds_at(at(Object, Exists_Location), Time),
       not(holds_at(nearPortal(Object, Portal), Time)),
       some(Exists_Location,
            '$kolem_Fn_79'(Object, Portal, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Object, Exists_Location), Time),
          (->),
         at(Object, Exists_Location)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  axiom(not(side1Pred(Portal, Exists_Location)),
       [ at(Object, Exists_Location),
         not(nearPortal(Object, Portal)),
         some(Exists_Location,
              '$kolem_Fn_79'(Object, Portal, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  (   at(Kolem_Fn_79P_Num3_V41, Tloc38),
       not(nearPortal(Kolem_Fn_79P_Num3_V41, Nearportal39)),
       some(Tloc38,
            '$kolem_Fn_79'(Kolem_Fn_79P_Num3_V41,
                           Nearportal39,
                           Kolem_Fn_7940))
   ->  not(side1Pred(Nearportal39, Tloc38))
   ).
 */
if loc_at(Kolem_Fn_79P_Num3_V41, Tloc38), not nearPortal(Kolem_Fn_79P_Num3_V41, Nearportal39), some(Tloc38, '$kolem_Fn_79'(Kolem_Fn_79P_Num3_V41, Nearportal39, Kolem_Fn_7940))then not side1Pred(Nearportal39, Tloc38).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  reactive_rule([ holds(loc_at(Kolem_Fn_79P_Num3_V41,Tloc38),
   		      Holds42),
   		holds(not(nearPortal(Kolem_Fn_79P_Num3_V41,
   				     Nearportal39)),
   		      Holds42),
   		some(Tloc38,
   		     '$kolem_Fn_79'(Kolem_Fn_79P_Num3_V41,
   				    Nearportal39,
   				    Kolem_Fn_7940))
   	      ],
   	      [not(side1Pred(Nearportal39,Tloc38))]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  not(side2Pred(Portal, Exists_Location)) :-
       holds_at(at(Object, Exists_Location), Time),
       not(holds_at(nearPortal(Object, Portal), Time)),
       some(Exists_Location,
            '$kolem_Fn_79'(Object, Portal, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Object, Exists_Location), Time),
          (->),
         at(Object, Exists_Location)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  axiom(not(side2Pred(Portal, Exists_Location)),
       [ at(Object, Exists_Location),
         not(nearPortal(Object, Portal)),
         some(Exists_Location,
              '$kolem_Fn_79'(Object, Portal, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  (   at(Kolem_Fn_79P_Num3_V46, Tloc43),
       not(nearPortal(Kolem_Fn_79P_Num3_V46, Nearportal44)),
       some(Tloc43,
            '$kolem_Fn_79'(Kolem_Fn_79P_Num3_V46,
                           Nearportal44,
                           Kolem_Fn_7945))
   ->  not(side2Pred(Nearportal44, Tloc43))
   ).
 */
if loc_at(Kolem_Fn_79P_Num3_V46, Tloc43), not nearPortal(Kolem_Fn_79P_Num3_V46, Nearportal44), some(Tloc43, '$kolem_Fn_79'(Kolem_Fn_79P_Num3_V46, Nearportal44, Kolem_Fn_7945))then not side2Pred(Nearportal44, Tloc43).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',57).

 /*  reactive_rule([ holds(loc_at(Kolem_Fn_79P_Num3_V46,Tloc43),
   		      Holds47),
   		holds(not(nearPortal(Kolem_Fn_79P_Num3_V46,
   				     Nearportal44)),
   		      Holds47),
   		some(Tloc43,
   		     '$kolem_Fn_79'(Kolem_Fn_79P_Num3_V46,
   				    Nearportal44,
   				    Kolem_Fn_7945))
   	      ],
   	      [not(side2Pred(Nearportal44,Tloc43))]).
 */


%; locking and unlocking doors
%; agent unlocks door.

% event DoorUnlock(agent,door)
 %  event(doorUnlock(agent,door)).
 %  event(doorUnlock(agent,door)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',64).
actions([doorUnlock/2]).
mpred_prop(doorUnlock(agent,door),event).


%; agent locks door.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',67).
% event DoorLock(agent,door)
 %  event(doorLock(agent,door)).
 %  event(doorLock(agent,door)).
actions([doorLock/2]).
mpred_prop(doorLock(agent,door),event).


%; door is unlocked.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',69).
% fluent DoorUnlocked(door)
 %  fluent(doorUnlocked(door)).
 %  fluent(doorUnlocked(door)).
fluents([doorUnlocked/1]).
mpred_prop(doorUnlocked(door),fluent).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',71).
%; A precondition axiom states that
%; for an agent to unlock a door,
%; the agent must be awake,
%; the door must not already be unlocked, and
%; the agent must be near the door:
% [agent,door,time]
% Happens(DoorUnlock(agent,door),time) ->
% HoldsAt(Awake(agent),time) &
% !HoldsAt(DoorUnlocked(door),time) &
% HoldsAt(NearPortal(agent,door),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',76).

 /*  (   happens(doorUnlock(Agent, Door), Time)
   ->  holds_at(awake(Agent), Time),
       holds_at(neg(doorUnlocked(Door)), Time),
       holds_at(nearPortal(Agent, Door), Time)
   ).
 */
if happens(doorUnlock(Agent, Door), Time)then awake(Agent)at Time, not doorUnlocked(Door)at Time, nearPortal(Agent, Door)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',76).

 /*  reactive_rule([happens(doorUnlock(Agent,Door),Time)],
   	      [ holds(awake(Agent),Time),
   		holds(not(doorUnlocked(Door)),Time),
   		holds(nearPortal(Agent,Door),Time)
   	      ]).
 */


%; An effect axiom states that
%; if an agent unlocks a door,
%; the door will be unlocked:
% [agent,door,time]
% Initiates(DoorUnlock(agent,door),DoorUnlocked(door),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',85).

 /*  axiom(initiates(doorUnlock(Agent, Door), doorUnlocked(Door), Time),
       []).
 */

 /*  initiates(doorUnlock(_,Doorunlock),
   	  doorUnlocked(Doorunlock),
   	  Initiates).
 */
doorUnlock(_, Doorunlock)initiates doorUnlocked(Doorunlock).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',85).

 /*  initiated(happens(doorUnlock(_,Doorunlock),
   		  Time_From,
   		  Time_Until),
   	  doorUnlocked(Doorunlock),
   	  []).
 */


%; A precondition axiom states that
%; for an agent to lock a door,
%; the agent must be awake,
%; the door must be unlocked, and
%; the agent must be near the door:
% [agent,door,time]
% Happens(DoorLock(agent,door),time) ->
% HoldsAt(Awake(agent),time) &
% HoldsAt(DoorUnlocked(door),time) &
% HoldsAt(NearPortal(agent,door),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',93).

 /*  (   happens(doorLock(Agent, Door), Time)
   ->  holds_at(awake(Agent), Time),
       holds_at(doorUnlocked(Door), Time),
       holds_at(nearPortal(Agent, Door), Time)
   ).
 */
if happens(doorLock(Agent, Door), Time)then awake(Agent)at Time, doorUnlocked(Door)at Time, nearPortal(Agent, Door)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',93).

 /*  reactive_rule([happens(doorLock(Agent,Door),Time)],
   	      [ holds(awake(Agent),Time),
   		holds(doorUnlocked(Door),Time),
   		holds(nearPortal(Agent,Door),Time)
   	      ]).
 */


%; An effect axiom states that
%; if an agent locks a door,
%; the door will no longer be unlocked.
% [agent,door,time]
% Terminates(DoorLock(agent,door),DoorUnlocked(door),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',102).

 /*  axiom(terminates(doorLock(Agent, Door), doorUnlocked(Door), Time),
       []).
 */

 /*  terminates(doorLock(_,Doorlock),
   	   doorUnlocked(Doorlock),
   	   Terminates).
 */
doorLock(_, Doorlock)terminates doorUnlocked(Doorlock).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',102).

 /*  terminated(happens(doorLock(_,Doorlock),
   		   Time_From,
   		   Time_Until),
   	   doorUnlocked(Doorlock),
   	   []).
 */


%; A state constraint says that if a door is open,
%; it is unlocked:
% [door,time]
% HoldsAt(DoorIsOpen(door),time) -> HoldsAt(DoorUnlocked(door),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',107).

 /*  holds_at(doorIsOpen(Door), Time) ->
       holds_at(doorUnlocked(Door), Time).
 */
if doorIsOpen(Door)at Time then doorUnlocked(Door)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',107).

 /*  reactive_rule([holds(doorIsOpen(Door),Time)],
   	      [holds(doorUnlocked(Door),Time)]).
 */


%; opening and closing doors
%; agent opens door.

% event DoorOpen(agent,door)
 %  event(doorOpen(agent,door)).
 %  event(doorOpen(agent,door)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',112).
actions([doorOpen/2]).
mpred_prop(doorOpen(agent,door),event).


%; agent closes door.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',115).
% event DoorClose(agent,door)
 %  event(doorClose(agent,door)).
 %  event(doorClose(agent,door)).
actions([doorClose/2]).
mpred_prop(doorClose(agent,door),event).


%; door is open.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',117).
% fluent DoorIsOpen(door)
 %  fluent(doorIsOpen(door)).
 %  fluent(doorIsOpen(door)).
fluents([doorIsOpen/1]).
mpred_prop(doorIsOpen(door),fluent).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',119).
%; A precondition axiom states that
%; for an agent to open a door,
%; the agent must be awake,
%; the door must not already be open,
%; the door must be unlocked, and
%; the agent must be near the door:
% [agent,door,time]
% Happens(DoorOpen(agent,door),time) ->
% HoldsAt(Awake(agent),time) &
% !HoldsAt(DoorIsOpen(door),time) &
% HoldsAt(DoorUnlocked(door),time) &
% HoldsAt(NearPortal(agent,door),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',125).

 /*  (   happens(doorOpen(Agent, Door), Time)
   ->  holds_at(awake(Agent), Time),
       holds_at(neg(doorIsOpen(Door)), Time),
       holds_at(doorUnlocked(Door), Time),
       holds_at(nearPortal(Agent, Door), Time)
   ).
 */
if happens(doorOpen(Agent, Door), Time)then awake(Agent)at Time, not doorIsOpen(Door)at Time, doorUnlocked(Door)at Time, nearPortal(Agent, Door)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',125).

 /*  reactive_rule([happens(doorOpen(Agent,Door),Time)],
   	      [ holds(awake(Agent),Time),
   		holds(not(doorIsOpen(Door)),Time),
   		holds(doorUnlocked(Door),Time),
   		holds(nearPortal(Agent,Door),Time)
   	      ]).
 */


%; An effect axiom states that
%; if an agent opens a door,
%; the door will be open:
% [agent,door,time]
% Initiates(DoorOpen(agent,door),DoorIsOpen(door),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',135).

 /*  axiom(initiates(doorOpen(Agent, Door), doorIsOpen(Door), Time),
       []).
 */

 /*  initiates(doorOpen(_,Dooropen),
   	  doorIsOpen(Dooropen),
   	  Initiates).
 */
doorOpen(_, Dooropen)initiates doorIsOpen(Dooropen).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',135).

 /*  initiated(happens(doorOpen(_,Dooropen),
   		  Time_From,
   		  Time_Until),
   	  doorIsOpen(Dooropen),
   	  []).
 */


%; A precondition axiom states that
%; for an agent to close a door,
%; the agent must be awake,
%; the door must be open,
%; the door must be unlocked, and
%; the agent must be near the door:
% [agent,door,time]
% Happens(DoorClose(agent,door),time) ->
% HoldsAt(Awake(agent),time) &
% HoldsAt(DoorIsOpen(door),time) &
% HoldsAt(DoorUnlocked(door),time) &
% HoldsAt(NearPortal(agent,door),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',144).

 /*  (   happens(doorClose(Agent, Door), Time)
   ->  holds_at(awake(Agent), Time),
       holds_at(doorIsOpen(Door), Time),
       holds_at(doorUnlocked(Door), Time),
       holds_at(nearPortal(Agent, Door), Time)
   ).
 */
if happens(doorClose(Agent, Door), Time)then awake(Agent)at Time, doorIsOpen(Door)at Time, doorUnlocked(Door)at Time, nearPortal(Agent, Door)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',144).

 /*  reactive_rule([happens(doorClose(Agent,Door),Time)],
   	      [ holds(awake(Agent),Time),
   		holds(doorIsOpen(Door),Time),
   		holds(doorUnlocked(Door),Time),
   		holds(nearPortal(Agent,Door),Time)
   	      ]).
 */


%; An effect axiom states that
%; if an agent closes a door,
%; the door will no longer be open:
% [agent,door,time]
% Terminates(DoorClose(agent,door),DoorIsOpen(door),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',154).

 /*  axiom(terminates(doorClose(Agent, Door), doorIsOpen(Door), Time),
       []).
 */

 /*  terminates(doorClose(_,Doorclose),
   	   doorIsOpen(Doorclose),
   	   Terminates).
 */
doorClose(_, Doorclose)terminates doorIsOpen(Doorclose).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',154).

 /*  terminated(happens(doorClose(_,Doorclose),
   		   Time_From,
   		   Time_Until),
   	   doorIsOpen(Doorclose),
   	   []).
 */


%; passing through doors
%; agent walks through side one of door.

% event WalkThroughDoor12(agent,door)
 %  event(walkThroughDoor12(agent,door)).
 %  event(walkThroughDoor12(agent,door)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',159).
actions([walkThroughDoor12/2]).
mpred_prop(walkThroughDoor12(agent,door),event).


%; agent walks through side two of door.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',162).
% event WalkThroughDoor21(agent,door)
 %  event(walkThroughDoor21(agent,door)).
 %  event(walkThroughDoor21(agent,door)).
actions([walkThroughDoor21/2]).
mpred_prop(walkThroughDoor21(agent,door),event).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',164).
%; Precondition axioms state that
%; for an agent to walk through a side of a door,
%; the agent must be awake and standing,
%; the door must be open, and
%; the agent must be at the side of the door that
%; the agent walks through:
% [agent,door,time]
% Happens(WalkThroughDoor12(agent,door),time) ->
% HoldsAt(Awake(agent),time) &
% HoldsAt(Standing(agent),time) &
% HoldsAt(DoorIsOpen(door),time) &
% HoldsAt(At(agent,Side1(door)),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',170).

 /*  (   happens(walkThroughDoor12(Agent, Door), Time)
   ->  holds_at(awake(Agent), Time),
       holds_at(standing(Agent), Time),
       holds_at(doorIsOpen(Door), Time),
       holds_at(at(Agent, side1(Door)), Time)
   ).
 */
if happens(walkThroughDoor12(Agent, Door), Time)then awake(Agent)at Time, standing(Agent)at Time, doorIsOpen(Door)at Time, loc_at(Agent, side1(Door))at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',170).

 /*  reactive_rule([ happens(walkThroughDoor12(Agent,Door),
   			Time)
   	      ],
   	      [ holds(awake(Agent),Time),
   		holds(standing(Agent),Time),
   		holds(doorIsOpen(Door),Time),
   		holds(loc_at(Agent,side1(Door)),Time)
   	      ]).
 */


% [agent,door,time]
% Happens(WalkThroughDoor21(agent,door),time) ->
% HoldsAt(Awake(agent),time) &
% HoldsAt(Standing(agent),time) &
% HoldsAt(DoorIsOpen(door),time) &
% HoldsAt(At(agent,Side2(door)),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',178).

 /*  (   happens(walkThroughDoor21(Agent, Door), Time)
   ->  holds_at(awake(Agent), Time),
       holds_at(standing(Agent), Time),
       holds_at(doorIsOpen(Door), Time),
       holds_at(at(Agent, side2(Door)), Time)
   ).
 */
if happens(walkThroughDoor21(Agent, Door), Time)then awake(Agent)at Time, standing(Agent)at Time, doorIsOpen(Door)at Time, loc_at(Agent, side2(Door))at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',178).

 /*  reactive_rule([ happens(walkThroughDoor21(Agent,Door),
   			Time)
   	      ],
   	      [ holds(awake(Agent),Time),
   		holds(standing(Agent),Time),
   		holds(doorIsOpen(Door),Time),
   		holds(loc_at(Agent,side2(Door)),Time)
   	      ]).
 */


%; Effect axioms state that
%; if an agent walks through one side of a door,
%; the agent will be at the other side of the door:
% [agent,door,location,time]
% Side2(door)=location ->
% Initiates(WalkThroughDoor12(agent,door),At(agent,location),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',187).

 /*  axiom(initiates(walkThroughDoor12(Agent, Door), at(Agent, Location), Time),
       [side2Pred(Door, Location)]).
 */

 /*  side2Pred(Walkthroughdoor12, Tloc) ->
       initiates(walkThroughDoor12(A, Walkthroughdoor12),
                 at(A, Tloc),
                 Initiates).
 */
if side2Pred(Walkthroughdoor12, Tloc)then initiates(walkThroughDoor12(A, Walkthroughdoor12), loc_at(A, Tloc)at Initiates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',187).

 /*  reactive_rule([side2Pred(Walkthroughdoor12,Tloc)],
   	      [ initiates(walkThroughDoor12(A,
   					    Walkthroughdoor12),
   			  at(loc_at(A,Tloc),
   			     Initiates),
   			  Initiates7)
   	      ]).
 */


% [agent,door,location,time]
% Side1(door)=location ->
% Initiates(WalkThroughDoor21(agent,door),At(agent,location),time).

 /*  axiom(initiates(walkThroughDoor21(Agent, Door), at(Agent, Location), Time),
       [side1Pred(Door, Location)]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',192).

 /*  side1Pred(Walkthroughdoor21, Tloc) ->
       initiates(walkThroughDoor21(A, Walkthroughdoor21),
                 at(A, Tloc),
                 Initiates).
 */
if side1Pred(Walkthroughdoor21, Tloc)then initiates(walkThroughDoor21(A, Walkthroughdoor21), loc_at(A, Tloc)at Initiates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',192).

 /*  reactive_rule([side1Pred(Walkthroughdoor21,Tloc)],
   	      [ initiates(walkThroughDoor21(A,
   					    Walkthroughdoor21),
   			  at(loc_at(A,Tloc),
   			     Initiates),
   			  Initiates7)
   	      ]).
 */


% [agent,door,location,time]
% Side1(door)=location ->
% Terminates(WalkThroughDoor12(agent,door),At(agent,location),time).

 /*  axiom(terminates(walkThroughDoor12(Agent, Door), at(Agent, Location), Time),
       [side1Pred(Door, Location)]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',196).

 /*  side1Pred(Walkthroughdoor12, Tloc) ->
       terminates(walkThroughDoor12(A, Walkthroughdoor12),
                  at(A, Tloc),
                  Terminates).
 */
if side1Pred(Walkthroughdoor12, Tloc)then terminates(walkThroughDoor12(A, Walkthroughdoor12), loc_at(A, Tloc)at Terminates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',196).

 /*  reactive_rule([side1Pred(Walkthroughdoor12,Tloc)],
   	      [ terminates(walkThroughDoor12(A,
   					     Walkthroughdoor12),
   			   at(loc_at(A,Tloc),
   			      Terminates),
   			   Terminates7)
   	      ]).
 */


% [agent,door,location,time]
% Side2(door)=location ->
% Terminates(WalkThroughDoor21(agent,door),At(agent,location),time).

 /*  axiom(terminates(walkThroughDoor21(Agent, Door), at(Agent, Location), Time),
       [side2Pred(Door, Location)]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',200).

 /*  side2Pred(Walkthroughdoor21, Tloc) ->
       terminates(walkThroughDoor21(A, Walkthroughdoor21),
                  at(A, Tloc),
                  Terminates).
 */
if side2Pred(Walkthroughdoor21, Tloc)then terminates(walkThroughDoor21(A, Walkthroughdoor21), loc_at(A, Tloc)at Terminates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',200).

 /*  reactive_rule([side2Pred(Walkthroughdoor21,Tloc)],
   	      [ terminates(walkThroughDoor21(A,
   					     Walkthroughdoor21),
   			   at(loc_at(A,Tloc),
   			      Terminates),
   			   Terminates7)
   	      ]).
 */


%; walking from one end of a street to another
%; agent walks from the first end of street to the second end.

% event WalkStreet12(agent,street)
 %  event(walkStreet12(agent,street)).
 %  event(walkStreet12(agent,street)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',205).
actions([walkStreet12/2]).
mpred_prop(walkStreet12(agent,street),event).


%; agent walks from the second end of street to the first end.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',208).
% event WalkStreet21(agent,street)
 %  event(walkStreet21(agent,street)).
 %  event(walkStreet21(agent,street)).
actions([walkStreet21/2]).
mpred_prop(walkStreet21(agent,street),event).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',210).
%; Precondition axioms state that
%; for an agent to walk from one end of a street to another,
%; the agent must be awake,
%; the agent must be standing, and
%; the agent must be at the first end of the street:
% [agent,street,time]
% Happens(WalkStreet12(agent,street),time) ->
% HoldsAt(Awake(agent),time) &
% HoldsAt(Standing(agent),time) &
% HoldsAt(At(agent,Side1(street)),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',215).

 /*  (   happens(walkStreet12(Agent, Street), Time)
   ->  holds_at(awake(Agent), Time),
       holds_at(standing(Agent), Time),
       holds_at(at(Agent, side1(Street)), Time)
   ).
 */
if happens(walkStreet12(Agent, Street), Time)then awake(Agent)at Time, standing(Agent)at Time, loc_at(Agent, side1(Street))at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',215).

 /*  reactive_rule([ happens(walkStreet12(Agent,Street),
   			Time)
   	      ],
   	      [ holds(awake(Agent),Time),
   		holds(standing(Agent),Time),
   		holds(loc_at(Agent,side1(Street)),
   		      Time)
   	      ]).
 */


% [agent,street,time]
% Happens(WalkStreet21(agent,street),time) ->
% HoldsAt(Awake(agent),time) &
% HoldsAt(Standing(agent),time) &
% HoldsAt(At(agent,Side2(street)),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',222).

 /*  (   happens(walkStreet21(Agent, Street), Time)
   ->  holds_at(awake(Agent), Time),
       holds_at(standing(Agent), Time),
       holds_at(at(Agent, side2(Street)), Time)
   ).
 */
if happens(walkStreet21(Agent, Street), Time)then awake(Agent)at Time, standing(Agent)at Time, loc_at(Agent, side2(Street))at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',222).

 /*  reactive_rule([ happens(walkStreet21(Agent,Street),
   			Time)
   	      ],
   	      [ holds(awake(Agent),Time),
   		holds(standing(Agent),Time),
   		holds(loc_at(Agent,side2(Street)),
   		      Time)
   	      ]).
 */


%; Effect axioms state that
%; if an agent walks from one end of a street to another,
%; the agent will be at the other end of the street:
% [agent,street,location,time]
% Side2(street)=location ->
% Initiates(WalkStreet12(agent,street),At(agent,location),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',230).

 /*  axiom(initiates(walkStreet12(Agent, Street), at(Agent, Location), Time),
       [side2Pred(Street, Location)]).
 */

 /*  side2Pred(Walkstreet12, Tloc) ->
       initiates(walkStreet12(A, Walkstreet12),
                 at(A, Tloc),
                 Initiates).
 */
if side2Pred(Walkstreet12, Tloc)then initiates(walkStreet12(A, Walkstreet12), loc_at(A, Tloc)at Initiates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',230).

 /*  reactive_rule([side2Pred(Walkstreet12,Tloc)],
   	      [ initiates(walkStreet12(A,Walkstreet12),
   			  at(loc_at(A,Tloc),
   			     Initiates),
   			  Initiates7)
   	      ]).
 */


% [agent,street,location,time]
% Side1(street)=location ->
% Initiates(WalkStreet21(agent,street),At(agent,location),time).

 /*  axiom(initiates(walkStreet21(Agent, Street), at(Agent, Location), Time),
       [side1Pred(Street, Location)]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',235).

 /*  side1Pred(Walkstreet21, Tloc) ->
       initiates(walkStreet21(A, Walkstreet21),
                 at(A, Tloc),
                 Initiates).
 */
if side1Pred(Walkstreet21, Tloc)then initiates(walkStreet21(A, Walkstreet21), loc_at(A, Tloc)at Initiates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',235).

 /*  reactive_rule([side1Pred(Walkstreet21,Tloc)],
   	      [ initiates(walkStreet21(A,Walkstreet21),
   			  at(loc_at(A,Tloc),
   			     Initiates),
   			  Initiates7)
   	      ]).
 */


% [agent,street,location,time]
% Side1(street)=location ->
% Terminates(WalkStreet12(agent,street),At(agent,location),time).

 /*  axiom(terminates(walkStreet12(Agent, Street), at(Agent, Location), Time),
       [side1Pred(Street, Location)]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',239).

 /*  side1Pred(Walkstreet12, Tloc) ->
       terminates(walkStreet12(A, Walkstreet12),
                  at(A, Tloc),
                  Terminates).
 */
if side1Pred(Walkstreet12, Tloc)then terminates(walkStreet12(A, Walkstreet12), loc_at(A, Tloc)at Terminates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',239).

 /*  reactive_rule([side1Pred(Walkstreet12,Tloc)],
   	      [ terminates(walkStreet12(A,Walkstreet12),
   			   at(loc_at(A,Tloc),
   			      Terminates),
   			   Terminates7)
   	      ]).
 */


% [agent,street,location,time]
% Side2(street)=location ->
% Terminates(WalkStreet21(agent,street),At(agent,location),time).

 /*  axiom(terminates(walkStreet21(Agent, Street), at(Agent, Location), Time),
       [side2Pred(Street, Location)]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',243).

 /*  side2Pred(Walkstreet21, Tloc) ->
       terminates(walkStreet21(A, Walkstreet21),
                  at(A, Tloc),
                  Terminates).
 */
if side2Pred(Walkstreet21, Tloc)then terminates(walkStreet21(A, Walkstreet21), loc_at(A, Tloc)at Terminates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',243).

 /*  reactive_rule([side2Pred(Walkstreet21,Tloc)],
   	      [ terminates(walkStreet21(A,Walkstreet21),
   			   at(loc_at(A,Tloc),
   			      Terminates),
   			   Terminates7)
   	      ]).
 */


%; floors
%; The floor of room is integer.

% function Floor(room): integer
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',248).

 /*  axiom(function_argtypes(Function_ArgtypesP_Num3_V, floor(room), integer),
       []).
 */
function_argtypes(Function_ArgtypesP_Num3_V1,floor(room),integer).
 %  predicate(floorPred(room,integer)).
 %  predicate(floorPred(room,integer)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',248).
predicates([floorPred/2]).
mpred_prop(floorPred(room,integer),predicate).

 /*  axiom(functional_predicate(floor, floorPred),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',248).
functional_predicate(floor,floorPred).
resultIsa(floor,integer).
%; walking up and down staircases
%; agent walks down staircase.

% event WalkDownStaircase(agent,staircase)
 %  event(walkDownStaircase(agent,staircase)).
 %  event(walkDownStaircase(agent,staircase)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',253).
actions([walkDownStaircase/2]).
mpred_prop(walkDownStaircase(agent,staircase),event).


%; agent walks up staircase.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',256).
% event WalkUpStaircase(agent,staircase)
 %  event(walkUpStaircase(agent,staircase)).
 %  event(walkUpStaircase(agent,staircase)).
actions([walkUpStaircase/2]).
mpred_prop(walkUpStaircase(agent,staircase),event).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',258).
%; Precondition axioms state that
%; for an agent to walk down (up) a staircase,
%; the agent must be awake, standing, and
%; at the top (bottom) of the staircase:
% [agent,staircase,time]
% Happens(WalkDownStaircase(agent,staircase),time) ->
% HoldsAt(Awake(agent),time) &
% HoldsAt(Standing(agent),time) &
% HoldsAt(At(agent,Side2(staircase)),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',262).

 /*  (   happens(walkDownStaircase(Agent, Staircase), Time)
   ->  holds_at(awake(Agent), Time),
       holds_at(standing(Agent), Time),
       holds_at(at(Agent, side2(Staircase)), Time)
   ).
 */
if happens(walkDownStaircase(Agent, Staircase), Time)then awake(Agent)at Time, standing(Agent)at Time, loc_at(Agent, side2(Staircase))at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',262).

 /*  reactive_rule([ happens(walkDownStaircase(Agent,Staircase),
   			Time)
   	      ],
   	      [ holds(awake(Agent),Time),
   		holds(standing(Agent),Time),
   		holds(loc_at(Agent,side2(Staircase)),
   		      Time)
   	      ]).
 */


% [agent,staircase,time]
% Happens(WalkUpStaircase(agent,staircase),time) ->
% HoldsAt(Awake(agent),time) &
% HoldsAt(Standing(agent),time) &
% HoldsAt(At(agent,Side1(staircase)),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',269).

 /*  (   happens(walkUpStaircase(Agent, Staircase), Time)
   ->  holds_at(awake(Agent), Time),
       holds_at(standing(Agent), Time),
       holds_at(at(Agent, side1(Staircase)), Time)
   ).
 */
if happens(walkUpStaircase(Agent, Staircase), Time)then awake(Agent)at Time, standing(Agent)at Time, loc_at(Agent, side1(Staircase))at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',269).

 /*  reactive_rule([ happens(walkUpStaircase(Agent,Staircase),
   			Time)
   	      ],
   	      [ holds(awake(Agent),Time),
   		holds(standing(Agent),Time),
   		holds(loc_at(Agent,side1(Staircase)),
   		      Time)
   	      ]).
 */


%; Effect axioms state that
%; if an agent walks down (up) a staircase,
%; the agent will be at the bottom (top) of the staircase:
% [agent,staircase,room,time]
% Side1(staircase)=room ->
% Initiates(WalkDownStaircase(agent,staircase),At(agent,room),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',277).

 /*  axiom(initiates(walkDownStaircase(Agent, Staircase), at(Agent, Room), Time),
       [side1Pred(Staircase, Room)]).
 */

 /*  side1Pred(Walkdownstaircase, Tloc) ->
       initiates(walkDownStaircase(A, Walkdownstaircase),
                 at(A, Tloc),
                 Initiates).
 */
if side1Pred(Walkdownstaircase, Tloc)then initiates(walkDownStaircase(A, Walkdownstaircase), loc_at(A, Tloc)at Initiates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',277).

 /*  reactive_rule([side1Pred(Walkdownstaircase,Tloc)],
   	      [ initiates(walkDownStaircase(A,
   					    Walkdownstaircase),
   			  at(loc_at(A,Tloc),
   			     Initiates),
   			  Initiates7)
   	      ]).
 */


% [agent,staircase,room,time]
% Side2(staircase)=room ->
% Terminates(WalkDownStaircase(agent,staircase),At(agent,room),time).

 /*  axiom(terminates(walkDownStaircase(Agent, Staircase), at(Agent, Room), Time),
       [side2Pred(Staircase, Room)]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',282).

 /*  side2Pred(Walkdownstaircase, Tloc) ->
       terminates(walkDownStaircase(A, Walkdownstaircase),
                  at(A, Tloc),
                  Terminates).
 */
if side2Pred(Walkdownstaircase, Tloc)then terminates(walkDownStaircase(A, Walkdownstaircase), loc_at(A, Tloc)at Terminates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',282).

 /*  reactive_rule([side2Pred(Walkdownstaircase,Tloc)],
   	      [ terminates(walkDownStaircase(A,
   					     Walkdownstaircase),
   			   at(loc_at(A,Tloc),
   			      Terminates),
   			   Terminates7)
   	      ]).
 */


% [agent,staircase,room,time]
% Side2(staircase)=room ->
% Initiates(WalkUpStaircase(agent,staircase),At(agent,room),time).

 /*  axiom(initiates(walkUpStaircase(Agent, Staircase), at(Agent, Room), Time),
       [side2Pred(Staircase, Room)]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',286).

 /*  side2Pred(Walkupstaircase, Tloc) ->
       initiates(walkUpStaircase(A, Walkupstaircase),
                 at(A, Tloc),
                 Initiates).
 */
if side2Pred(Walkupstaircase, Tloc)then initiates(walkUpStaircase(A, Walkupstaircase), loc_at(A, Tloc)at Initiates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',286).

 /*  reactive_rule([side2Pred(Walkupstaircase,Tloc)],
   	      [ initiates(walkUpStaircase(A,
   					  Walkupstaircase),
   			  at(loc_at(A,Tloc),
   			     Initiates),
   			  Initiates7)
   	      ]).
 */


% [agent,staircase,room,time]
% Side1(staircase)=room ->
% Terminates(WalkUpStaircase(agent,staircase),At(agent,room),time).

 /*  axiom(terminates(walkUpStaircase(Agent, Staircase), at(Agent, Room), Time),
       [side1Pred(Staircase, Room)]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',290).

 /*  side1Pred(Walkupstaircase, Tloc) ->
       terminates(walkUpStaircase(A, Walkupstaircase),
                  at(A, Tloc),
                  Terminates).
 */
if side1Pred(Walkupstaircase, Tloc)then terminates(walkUpStaircase(A, Walkupstaircase), loc_at(A, Tloc)at Terminates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',290).

 /*  reactive_rule([side1Pred(Walkupstaircase,Tloc)],
   	      [ terminates(walkUpStaircase(A,
   					   Walkupstaircase),
   			   at(loc_at(A,Tloc),
   			      Terminates),
   			   Terminates7)
   	      ]).
 */


%; A state constraint says that if an agent is outside,
%; the agent is dressed.
% [agent,outside,time]
% HoldsAt(At(agent,outside),time) ->
% HoldsAt(Dressed(agent),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',295).

 /*  holds_at(at(Agent, Outside), Time) ->
       holds_at(dressed(Agent), Time).
 */
if loc_at(Agent, Outside)at Time then dressed(Agent)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',295).

 /*  reactive_rule([holds(loc_at(Agent,Outside),Time)],
   	      [holds(dressed(Agent),Time)]).
 */


%; room looks out onto outside.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',300).
% function LookOutOnto(room): outside

 /*  axiom(function_argtypes(Function_ArgtypesP_Num3_V, lookOutOnto(room), outside),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',300).
function_argtypes(Function_ArgtypesP_Num3_V1,
		  lookOutOnto(room),
		  outside).
 %  predicate(lookOutOntoPred(room,outside)).
 %  predicate(lookOutOntoPred(room,outside)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',300).
predicates([lookOutOntoPred/2]).
mpred_prop(lookOutOntoPred(room,outside),predicate).

 /*  axiom(functional_predicate(lookOutOnto, lookOutOntoPred),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',300).
functional_predicate(lookOutOnto,lookOutOntoPred).
resultIsa(lookOutOnto,outside).
%; location1 is adjacent to location2.

% predicate Adjacent(location,location)
 %  predicate(adjacent(location,location)).
 %  predicate(adjacent(location,location)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',302).
predicates([adjacent/2]).
mpred_prop(adjacent(location,location),predicate).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',305).
%; A state constraint says that
%; two locations are adjacent if and only if
%; they have a portal in common:
% [location1,location2]
 
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).
% Adjacent(location1,location2) <->
% {portal}% 
% (Side1(portal)=location1 &
%  Side2(portal)=location2) |
% (Side2(portal)=location1 &
%  Side1(portal)=location2).
 %  clausify_pnf=exists([Portal], <->(adjacent(Location1, Location2),  (side1Pred(Portal, Location1), side2Pred(Portal, Location2);side2Pred(Portal, Location1), side1Pred(Portal, Location2)))).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*  adjacent(Location1, Location2) :-
       (   side1Pred(Exists_Portal, Location1),
           side2Pred(Exists_Portal, Location2)
       ;   side2Pred(Exists_Portal, Location1),
           side1Pred(Exists_Portal, Location2)
       ),
       some(Exists_Portal, '$kolem_Fn_80'(Location1, Location2)).
 */
 %  axiom(adjacent(Location1, Location2), [(side1Pred(Exists_Portal, Location1), side2Pred(Exists_Portal, Location2);side2Pred(Exists_Portal, Location1), side1Pred(Exists_Portal, Location2)), some(Exists_Portal, '$kolem_Fn_80'(Location1, Location2))]).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*  (   (   side1Pred(A, Side1pred),
           side2Pred(A, Side2pred)
       ;   side2Pred(A, Side1pred),
           side1Pred(A, Side2pred)
       ),
       some(A, '$kolem_Fn_80'(Side1pred, Side2pred))
   ->  adjacent(Side1pred, Side2pred)
   ).
 */
if (side1Pred(A, Side1pred), side2Pred(A, Side2pred);side2Pred(A, Side1pred), side1Pred(A, Side2pred)), some(A, '$kolem_Fn_80'(Side1pred, Side2pred))then adjacent(Side1pred, Side2pred).
 %  reactive_rule([(side1Pred(A, Side1pred), side2Pred(A, Side2pred);side2Pred(A, Side1pred), side1Pred(A, Side2pred)), some(A, '$kolem_Fn_80'(Side1pred, Side2pred))], [adjacent(Side1pred, Side2pred)]).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*  not(side1Pred(Exists_Portal, Location1)) :-
       side2Pred(Exists_Portal, Location2),
       not(adjacent(Location1, Location2)),
       some(Exists_Portal, '$kolem_Fn_80'(Location1, Location2)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*  axiom(not(side1Pred(Exists_Portal, Location1)),
       [ side2Pred(Exists_Portal, Location2),
         not(adjacent(Location1, Location2)),
         some(Exists_Portal, '$kolem_Fn_80'(Location1, Location2))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*  (   side2Pred(A, Side2pred6),
       not(adjacent(Side1pred7, Side2pred6)),
       some(A, '$kolem_Fn_80'(Side1pred7, Side2pred6))
   ->  not(side1Pred(A, Side1pred7))
   ).
 */
if side2Pred(A, Side2pred6), not adjacent(Side1pred7, Side2pred6), some(A, '$kolem_Fn_80'(Side1pred7, Side2pred6))then not side1Pred(A, Side1pred7).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*  reactive_rule([ side2Pred(A,Side2pred6),
   		not(adjacent(Side1pred7,Side2pred6)),
   		some(A,
   		     '$kolem_Fn_80'(Side1pred7,Side2pred6))
   	      ],
   	      [not(side1Pred(A,Side1pred7))]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*  not(side2Pred(Exists_Portal, Location2)) :-
       side1Pred(Exists_Portal, Location1),
       not(adjacent(Location1, Location2)),
       some(Exists_Portal, '$kolem_Fn_80'(Location1, Location2)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*  axiom(not(side2Pred(Exists_Portal, Location2)),
       [ side1Pred(Exists_Portal, Location1),
         not(adjacent(Location1, Location2)),
         some(Exists_Portal, '$kolem_Fn_80'(Location1, Location2))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*  (   side1Pred(A, Side1pred8),
       not(adjacent(Side1pred8, Adjacent)),
       some(A, '$kolem_Fn_80'(Side1pred8, Adjacent))
   ->  not(side2Pred(A, Adjacent))
   ).
 */
if side1Pred(A, Side1pred8), not adjacent(Side1pred8, Adjacent), some(A, '$kolem_Fn_80'(Side1pred8, Adjacent))then not side2Pred(A, Adjacent).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*  reactive_rule([ side1Pred(A,Side1pred8),
   		not(adjacent(Side1pred8,Adjacent)),
   		some(A,
   		     '$kolem_Fn_80'(Side1pred8,Adjacent))
   	      ],
   	      [not(side2Pred(A,Adjacent))]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*  not(side2Pred(Exists_Portal, Location1)) :-
       side1Pred(Exists_Portal, Location2),
       not(adjacent(Location1, Location2)),
       some(Exists_Portal, '$kolem_Fn_80'(Location1, Location2)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*  axiom(not(side2Pred(Exists_Portal, Location1)),
       [ side1Pred(Exists_Portal, Location2),
         not(adjacent(Location1, Location2)),
         some(Exists_Portal, '$kolem_Fn_80'(Location1, Location2))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*  (   side1Pred(A, Side1pred10),
       not(adjacent(Side2pred11, Side1pred10)),
       some(A, '$kolem_Fn_80'(Side2pred11, Side1pred10))
   ->  not(side2Pred(A, Side2pred11))
   ).
 */
if side1Pred(A, Side1pred10), not adjacent(Side2pred11, Side1pred10), some(A, '$kolem_Fn_80'(Side2pred11, Side1pred10))then not side2Pred(A, Side2pred11).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*  reactive_rule([ side1Pred(A,Side1pred10),
   		not(adjacent(Side2pred11,Side1pred10)),
   		some(A,
   		     '$kolem_Fn_80'(Side2pred11,Side1pred10))
   	      ],
   	      [not(side2Pred(A,Side2pred11))]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*  not(side1Pred(Exists_Portal, Location2)) :-
       side2Pred(Exists_Portal, Location1),
       not(adjacent(Location1, Location2)),
       some(Exists_Portal, '$kolem_Fn_80'(Location1, Location2)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*  axiom(not(side1Pred(Exists_Portal, Location2)),
       [ side2Pred(Exists_Portal, Location1),
         not(adjacent(Location1, Location2)),
         some(Exists_Portal, '$kolem_Fn_80'(Location1, Location2))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*  (   side2Pred(A, Side2pred12),
       not(adjacent(Side2pred12, Adjacent13)),
       some(A, '$kolem_Fn_80'(Side2pred12, Adjacent13))
   ->  not(side1Pred(A, Adjacent13))
   ).
 */
if side2Pred(A, Side2pred12), not adjacent(Side2pred12, Adjacent13), some(A, '$kolem_Fn_80'(Side2pred12, Adjacent13))then not side1Pred(A, Adjacent13).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*  reactive_rule([ side2Pred(A,Side2pred12),
   		not(adjacent(Side2pred12,Adjacent13)),
   		some(A,
   		     '$kolem_Fn_80'(Side2pred12,Adjacent13))
   	      ],
   	      [not(side1Pred(A,Adjacent13))]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*  not(adjacent(Location1, Location2)) :-
       (   not(side1Pred(Exists_Portal, Location1))
       ;   not(side2Pred(Exists_Portal, Location2))
       ),
       (   not(side2Pred(Exists_Portal, Location1))
       ;   not(side1Pred(Exists_Portal, Location2))
       ),
       some(Exists_Portal, '$kolem_Fn_80'(Location1, Location2)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*  axiom(not(adjacent(Location1, Location2)),
       [  (not(side1Pred(Exists_Portal, Location1));not(side2Pred(Exists_Portal, Location2))),
          (not(side2Pred(Exists_Portal, Location1));not(side1Pred(Exists_Portal, Location2))),
         some(Exists_Portal, '$kolem_Fn_80'(Location1, Location2))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*  (   (   not(side1Pred(A, Side1pred14))
       ;   not(side2Pred(A, Side2pred15))
       ),
       (   not(side2Pred(A, Side1pred14))
       ;   not(side1Pred(A, Side2pred15))
       ),
       some(A, '$kolem_Fn_80'(Side1pred14, Side2pred15))
   ->  not(adjacent(Side1pred14, Side2pred15))
   ).
 */
if (not side1Pred(A, Side1pred14);not side2Pred(A, Side2pred15)), (not side2Pred(A, Side1pred14);not side1Pred(A, Side2pred15)), some(A, '$kolem_Fn_80'(Side1pred14, Side2pred15))then not adjacent(Side1pred14, Side2pred15).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*   reactive_rule([  (not(side1Pred(A, Side1pred14));not(side2Pred(A, Side2pred15))),
                       (not(side2Pred(A, Side1pred14));not(side1Pred(A, Side2pred15))),
                      some(A,
                           '$kolem_Fn_80'(Side1pred14, Side2pred15))
                    ],
                    [not(adjacent(Side1pred14, Side2pred15))]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*  side1Pred(Exists_Portal, Location1) :-
       (   not(side2Pred(Exists_Portal, Location1))
       ;   not(side1Pred(Exists_Portal, Location2))
       ),
       adjacent(Location1, Location2),
       some(Exists_Portal, '$kolem_Fn_80'(Location1, Location2)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*  axiom(side1Pred(Exists_Portal, Location1),
       [  (not(side2Pred(Exists_Portal, Location1));not(side1Pred(Exists_Portal, Location2))),
         adjacent(Location1, Location2),
         some(Exists_Portal, '$kolem_Fn_80'(Location1, Location2))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*  (   (   not(side2Pred(A, Side2pred16))
       ;   not(side1Pred(A, Side1pred17))
       ),
       adjacent(Side2pred16, Side1pred17),
       some(A, '$kolem_Fn_80'(Side2pred16, Side1pred17))
   ->  side1Pred(A, Side2pred16)
   ).
 */
if (not side2Pred(A, Side2pred16);not side1Pred(A, Side1pred17)), adjacent(Side2pred16, Side1pred17), some(A, '$kolem_Fn_80'(Side2pred16, Side1pred17))then side1Pred(A, Side2pred16).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*   reactive_rule([  (not(side2Pred(A, Side2pred16));not(side1Pred(A, Side1pred17))),
                      adjacent(Side2pred16, Side1pred17),
                      some(A,
                           '$kolem_Fn_80'(Side2pred16, Side1pred17))
                    ],
                    [side1Pred(A, Side2pred16)]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*  side2Pred(Exists_Portal, Location2) :-
       (   not(side2Pred(Exists_Portal, Location1))
       ;   not(side1Pred(Exists_Portal, Location2))
       ),
       adjacent(Location1, Location2),
       some(Exists_Portal, '$kolem_Fn_80'(Location1, Location2)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*  axiom(side2Pred(Exists_Portal, Location2),
       [  (not(side2Pred(Exists_Portal, Location1));not(side1Pred(Exists_Portal, Location2))),
         adjacent(Location1, Location2),
         some(Exists_Portal, '$kolem_Fn_80'(Location1, Location2))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*  (   (   not(side2Pred(A, Side2pred18))
       ;   not(side1Pred(A, Side1pred19))
       ),
       adjacent(Side2pred18, Side1pred19),
       some(A, '$kolem_Fn_80'(Side2pred18, Side1pred19))
   ->  side2Pred(A, Side1pred19)
   ).
 */
if (not side2Pred(A, Side2pred18);not side1Pred(A, Side1pred19)), adjacent(Side2pred18, Side1pred19), some(A, '$kolem_Fn_80'(Side2pred18, Side1pred19))then side2Pred(A, Side1pred19).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*   reactive_rule([  (not(side2Pred(A, Side2pred18));not(side1Pred(A, Side1pred19))),
                      adjacent(Side2pred18, Side1pred19),
                      some(A,
                           '$kolem_Fn_80'(Side2pred18, Side1pred19))
                    ],
                    [side2Pred(A, Side1pred19)]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*  side2Pred(Exists_Portal, Location1) :-
       (   not(side1Pred(Exists_Portal, Location1))
       ;   not(side2Pred(Exists_Portal, Location2))
       ),
       adjacent(Location1, Location2),
       some(Exists_Portal, '$kolem_Fn_80'(Location1, Location2)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*  axiom(side2Pred(Exists_Portal, Location1),
       [  (not(side1Pred(Exists_Portal, Location1));not(side2Pred(Exists_Portal, Location2))),
         adjacent(Location1, Location2),
         some(Exists_Portal, '$kolem_Fn_80'(Location1, Location2))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*  (   (   not(side1Pred(A, Side1pred20))
       ;   not(side2Pred(A, Side2pred21))
       ),
       adjacent(Side1pred20, Side2pred21),
       some(A, '$kolem_Fn_80'(Side1pred20, Side2pred21))
   ->  side2Pred(A, Side1pred20)
   ).
 */
if (not side1Pred(A, Side1pred20);not side2Pred(A, Side2pred21)), adjacent(Side1pred20, Side2pred21), some(A, '$kolem_Fn_80'(Side1pred20, Side2pred21))then side2Pred(A, Side1pred20).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*   reactive_rule([  (not(side1Pred(A, Side1pred20));not(side2Pred(A, Side2pred21))),
                      adjacent(Side1pred20, Side2pred21),
                      some(A,
                           '$kolem_Fn_80'(Side1pred20, Side2pred21))
                    ],
                    [side2Pred(A, Side1pred20)]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*  side1Pred(Exists_Portal, Location2) :-
       (   not(side1Pred(Exists_Portal, Location1))
       ;   not(side2Pred(Exists_Portal, Location2))
       ),
       adjacent(Location1, Location2),
       some(Exists_Portal, '$kolem_Fn_80'(Location1, Location2)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*  axiom(side1Pred(Exists_Portal, Location2),
       [  (not(side1Pred(Exists_Portal, Location1));not(side2Pred(Exists_Portal, Location2))),
         adjacent(Location1, Location2),
         some(Exists_Portal, '$kolem_Fn_80'(Location1, Location2))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*  (   (   not(side1Pred(A, Side1pred22))
       ;   not(side2Pred(A, Side2pred23))
       ),
       adjacent(Side1pred22, Side2pred23),
       some(A, '$kolem_Fn_80'(Side1pred22, Side2pred23))
   ->  side1Pred(A, Side2pred23)
   ).
 */
if (not side1Pred(A, Side1pred22);not side2Pred(A, Side2pred23)), adjacent(Side1pred22, Side2pred23), some(A, '$kolem_Fn_80'(Side1pred22, Side2pred23))then side1Pred(A, Side2pred23).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',308).

 /*   reactive_rule([  (not(side1Pred(A, Side1pred22));not(side2Pred(A, Side2pred23))),
                      adjacent(Side1pred22, Side2pred23),
                      some(A,
                           '$kolem_Fn_80'(Side1pred22, Side2pred23))
                    ],
                    [side1Pred(A, Side2pred23)]).
 */


%; The ground of outside is ground.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',316).
% function GroundOf(outside): ground

 /*  axiom(function_argtypes(Function_ArgtypesP_Num3_V, groundOf(outside), ground),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',316).
function_argtypes(Function_ArgtypesP_Num3_V1,
		  groundOf(outside),
		  ground).
 %  predicate(ground(outside,ground)).
 %  predicate(ground(outside,ground)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',316).
predicates([ground/2]).
mpred_prop(ground(outside,ground),predicate).

 /*  axiom(functional_predicate(groundOf, ground),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',316).
functional_predicate(groundOf,ground).
resultIsa(groundOf,ground).
%; The sky of outside is sky.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',318).
% function SkyOf(outside): sky

 /*  axiom(function_argtypes(Function_ArgtypesP_Num3_V, skyOf(outside), sky),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',318).
function_argtypes(Function_ArgtypesP_Num3_V1,skyOf(outside),sky).
 %  predicate(sky(outside,sky)).
 %  predicate(sky(outside,sky)).
predicates([sky/2]).
mpred_prop(sky(outside,sky),predicate).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',318).

 /*  axiom(functional_predicate(skyOf, sky),
       []).
 */
functional_predicate(skyOf,sky).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',318).
resultIsa(skyOf,sky).
 %; State constraints fix the location of ground and sky:
% [outside,ground,time]
% GroundOf(outside) = ground ->
% HoldsAt(At(ground,outside),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',322).

 /*  ground(Outside, Ground) ->
       holds_at(at(Ground, Outside), Time).
 */
if ground(Outside, Ground)then loc_at(Ground, Outside)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',322).

 /*  reactive_rule([ground(Outside,Ground)],
   	      [holds(loc_at(Ground,Outside),Time)]).
 */


% [outside,sky,time]
% SkyOf(outside) = sky ->
% HoldsAt(At(sky,outside),time).

 /*  sky(Outside, Sky) ->
       holds_at(at(Sky, Outside), Time).
 */
if sky(Outside, Sky)then loc_at(Sky, Outside)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',327).

 /*  reactive_rule([sky(Outside,Sky)],
   	      [holds(loc_at(Sky,Outside),Time)]).
 */


%; End of file.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/RTSpace.e',329).
:- endif.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',45).
% load answers/Mueller2004c/OTSpaceM.e
:- if(is_e_toplevel).
:- cond_convert_e(changed, 'answers/Mueller2004c/OTSpaceM.e').
 %  loading(changed,'/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e').
%;
%; Copyright (c) 2005 IBM Corporation and others.
%; All rights reserved. This program and the accompanying materials
%; are made available under the terms of the Common Public License v1.0
%; which accompanies this distribution, and is available at
%; http://www.eclipse.org/legal/cpl-v10.html
%;
%; Contributors:
%; IBM - Initial implementation
%;
%; OTSpace: object-scale topological space
%;
%; The OTSpace representation deals with topological space at
%; the scale of objects such as agents (humans and animals)
%; and physical objects.
%;
%; PartOf
%; physobj is a part of object.

% predicate PartOf(physobj,object)
 %  predicate(partOf(physobj,object)).
 %  predicate(partOf(physobj,object)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',20).
predicates([partOf/2]).
mpred_prop(partOf(physobj,object),predicate).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',23).
%; A state constraint says that if a physical object
%; is part of an object, the location of the
%; physical object is the same as the location of the object:
% [physobj,object,location,time]
% PartOf(physobj,object) &
% HoldsAt(At(object,location),time) ->
% HoldsAt(At(physobj,location),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',26).

 /*  (   partOf(Physobj, Object),
       holds_at(at(Object, Location), Time)
   ->  holds_at(at(Physobj, Location), Time)
   ).
 */
if partOf(Physobj, Object), loc_at(Object, Location)at Time then loc_at(Physobj, Location)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',26).

 /*  reactive_rule([ partOf(Physobj,Object),
   		holds(loc_at(Object,Location),Time)
   	      ],
   	      [holds(loc_at(Physobj,Location),Time)]).
 */


%; rolling a snowball bigger
%; agent rolls stuff1 along stuff2.

% event RollAlong(agent,stuff,stuff)
 %  event(rollAlong(agent,stuff,stuff)).
 %  event(rollAlong(agent,stuff,stuff)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',33).
actions([rollAlong/3]).
mpred_prop(rollAlong(agent,stuff,stuff),event).


%; The diameter of ball is diameter.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',36).
% fluent Diameter(ball,diameter)
 %  fluent(diameter(ball,diameter)).
 %  fluent(diameter(ball,diameter)).
fluents([diameter/2]).
mpred_prop(diameter(ball,diameter),fluent).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',38).
%; A state constraint says that a ball has a unique diameter:
% [ball,diameter1,diameter2,time]
% HoldsAt(Diameter(ball,diameter1),time) &
% HoldsAt(Diameter(ball,diameter2),time) ->
% diameter1=diameter2.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',40).

 /*  (   holds_at(diameter(Ball, Diameter1), Time),
       holds_at(diameter(Ball, Diameter2), Time)
   ->  equals(Diameter1, Diameter2)
   ).
 */
if diameter(Ball, Diameter1)at Time, diameter(Ball, Diameter2)at Time then equals(Diameter1, Diameter2).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',40).

 /*  reactive_rule([ holds(diameter(Ball,Diameter1),Time),
   		holds(diameter(Ball,Diameter2),Time)
   	      ],
   	      [equals(Diameter1,Diameter2)]).
 */


%; Effect axiom state that if an agent rolls some snow along
%; some other snow, the diameter of the first snow will increase:
% [agent,snow1,snow2,diameter1,diameter2,time]
% HoldsAt(Diameter(snow1,diameter1),time) &
% diameter2 = diameter1+1 ->
% Initiates(RollAlong(agent,snow1,snow2),
%           Diameter(snow1,diameter2),
%           time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',46).

 /*  axiom(initiates(rollAlong(Agent, Snow1, Snow2), diameter(Snow1, Diameter2), Time),
       [ diameter(Snow1, Diameter1),
         '+Pred'(Diameter1, 1, Diameter2)
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',46).

 /*  (   diameter(A, Diameter),
       '+Pred'(Diameter, 1, Pred)
   ->  initiates(rollAlong(RollalongP_Num3_V, A, Rollalong),
                 diameter(A, Pred),
                 Initiates)
   ).
 */
if diameter(A, Diameter), '+Pred'(Diameter, 1, Pred)then initiates(rollAlong(RollalongP_Num3_V, A, Rollalong), diameter(A, Pred)at Initiates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',46).

 /*  reactive_rule([ holds(diameter(A,Diameter),Holds),
   		'+Pred'(Diameter,1,Pred)
   	      ],
   	      [ initiates(rollAlong(RollalongP_Num3_V,
   				    A,
   				    Rollalong),
   			  at(diameter(A,Pred),
   			     Initiates),
   			  Initiates12)
   	      ]).
 */


% [agent,snow1,snow2,diameter1,time]
% HoldsAt(Diameter(snow1,diameter1),time) ->
% Terminates(RollAlong(agent,snow1,snow2),
%            Diameter(snow1,diameter1),
%            time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',54).

 /*  axiom(terminates(rollAlong(Agent, Snow1, Snow2), diameter(Snow1, Diameter1), Time),
       [diameter(Snow1, Diameter1)]).
 */

 /*  diameter(A, Diameter) ->
       terminates(rollAlong(RollalongP_Num3_V, A, Rollalong),
                  diameter(A, Diameter),
                  Terminates).
 */
if diameter(A, Diameter)then terminates(rollAlong(RollalongP_Num3_V, A, Rollalong), diameter(A, Diameter)at Terminates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',54).

 /*  reactive_rule([holds(diameter(A,Diameter),Holds)],
   	      [ terminates(rollAlong(RollalongP_Num3_V,
   				     A,
   				     Rollalong),
   			   at(diameter(A,Diameter),
   			      Terminates),
   			   Terminates10)
   	      ]).
 */


%; A precondition axiom states that
%; for an agent to roll some snow along some other snow,
%; there must be a location such that
%; the agent is at the location,
%; the first snow is at the location, and
%; the second snow is at the location:
%;[agent,snow1,snow2,time]
%;Happens(RollAlong(agent,snow1,snow2),time) ->
%;{location}
%;HoldsAt(At(agent,location),time) &
%;HoldsAt(At(snow1,location),time) &
%;HoldsAt(At(snow2,location),time).
%; motion
%; object moves (in place).

% event Move(object)
 %  event(move(object)).
 %  event(move(object)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',74).
events([move/1]).
mpred_prop(move(object),event).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',77).
%; Holding
%; agent is holding physobj.

% fluent Holding(agent,physobj)
 %  fluent(holding(agent,physobj)).
 %  fluent(holding(agent,physobj)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',79).
fluents([holding/2]).
mpred_prop(holding(agent,physobj),fluent).


%; agent holds or picks up physobj.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',82).
% event Hold(agent,physobj)
 %  event(hold(agent,physobj)).
 %  event(hold(agent,physobj)).
actions([hold/2]).
mpred_prop(hold(agent,physobj),event).


%; agent picks up some stuff1 from stuff2.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',84).
% event HoldSome(agent,stuff,stuff)
 %  event(holdSome(agent,stuff,stuff)).
 %  event(holdSome(agent,stuff,stuff)).
actions([holdSome/3]).
mpred_prop(holdSome(agent,stuff,stuff),event).


%; agent releases or lets go of physobj.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',86).
% event LetGoOf(agent,physobj)
 %  event(letGoOf(agent,physobj)).
 %  event(letGoOf(agent,physobj)).
actions([letGoOf/2]).
mpred_prop(letGoOf(agent,physobj),event).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',88).
%; An effect axiom states that if an agent holds
%; a physical object, the agent will be holding the
%; physical object:
% [agent,physobj,time]
% Initiates(Hold(agent,physobj),Holding(agent,physobj),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',91).

 /*  axiom(initiates(hold(Agent, Physobj), holding(Agent, Physobj), Time),
       []).
 */

 /*  initiates(hold(A,Hold),
   	  holding(A,Hold),
   	  Initiates).
 */
hold(A, Hold)initiates holding(A, Hold).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',91).

 /*  initiated(happens(hold(A,Hold),
   		  Time_From,
   		  Time_Until),
   	  holding(A,Hold),
   	  []).
 */


%; A precondition axiom states that
%; for an agent to hold a physical object,
%; there must be a location such that
%; the agent is at the location and
%; the physical object is at the location:
%;[agent,physobj,time]
%;Happens(Hold(agent,physobj),time) ->
%;{location}
%;  HoldsAt(At(agent,location),time) &
%;  HoldsAt(At(physobj,location),time).
%; An effect axiom states that if an agent
%; lets go of a physical object, the agent is no longer holding
%; the physical object:
% [agent,physobj,time]
% Terminates(LetGoOf(agent,physobj),Holding(agent,physobj),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',108).

 /*  axiom(terminates(letGoOf(Agent, Physobj), holding(Agent, Physobj), Time),
       []).
 */

 /*  terminates(letGoOf(A,Letgoof),
   	   holding(A,Letgoof),
   	   Terminates).
 */
letGoOf(A, Letgoof)terminates holding(A, Letgoof).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',108).

 /*  terminated(happens(letGoOf(A,Letgoof),
   		   Time_From,
   		   Time_Until),
   	   holding(A,Letgoof),
   	   []).
 */


%; A precondition axiom states that
%; for an agent to let go of a physical object,
%; the agent must be holding the physical object:
% [agent,physobj,time]
% Happens(LetGoOf(agent,physobj),time) ->
% HoldsAt(Holding(agent,physobj),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',114).

 /*  happens(letGoOf(Agent, Physobj), Time) ->
       holds_at(holding(Agent, Physobj), Time).
 */
if happens(letGoOf(Agent, Physobj), Time)then holding(Agent, Physobj)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',114).

 /*  reactive_rule([happens(letGoOf(Agent,Physobj),Time)],
   	      [holds(holding(Agent,Physobj),Time)]).
 */


%; A releases axiom states that if an agent holds
%; a physical object,
%; the physical object's location will be released
%; from inertia:
% [agent,physobj,location,time]
% Releases(Hold(agent,physobj),At(physobj,location),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',122).

 /*  axiom(releases(hold(Agent, Physobj), at(Physobj, Location), Time),
       []).
 */

 /*  releases(hold(_,Hold),
   	 at(Hold,Tloc),
   	 Releases).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',122).
releases(hold(_,Hold),
	 loc_at(Hold,Tloc),
	 Releases).


%; A state constraint says that if an agent is holding
%; a physical object and the agent is at a location,
%; the physical object is also at the location:
% [agent,physobj,location,time]
% HoldsAt(Holding(agent,physobj),time) &
% HoldsAt(At(agent,location),time) ->
% HoldsAt(At(physobj,location),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',128).

 /*  (   holds_at(holding(Agent, Physobj), Time),
       holds_at(at(Agent, Location), Time)
   ->  holds_at(at(Physobj, Location), Time)
   ).
 */
if holding(Agent, Physobj)at Time, loc_at(Agent, Location)at Time then loc_at(Physobj, Location)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',128).

 /*  reactive_rule([ holds(holding(Agent,Physobj),Time),
   		holds(loc_at(Agent,Location),Time)
   	      ],
   	      [holds(loc_at(Physobj,Location),Time)]).
 */


%; A releases axiom states that if an agent holds
%; a physical object,
%; the locations of the parts of the physical object
%; will be released from inertia:
% [agent,physobj1,physobj2,location,time]
% PartOf(physobj1,physobj2) ->
% Releases(Hold(agent,physobj2),At(physobj1,location),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',137).

 /*  axiom(releases(hold(Agent, Physobj2), at(Physobj1, Location), Time),
       [partOf(Physobj1, Physobj2)]).
 */

 /*  partOf(A, Partof) ->
       releases(hold(_, Partof), at(A, Tloc), Releases).
 */
if partOf(A, Partof)then releases(hold(_, Partof), loc_at(A, Tloc), Releases).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',137).

 /*  reactive_rule([partOf(A,Partof)],
   	      [ releases(hold(_,Partof),
   			 loc_at(A,Tloc),
   			 Releases)
   	      ]).
 */


%; Further, if an agent holds a physical object,
%; the locations of the physical objects of which
%; the physical object is a part
%; will be released from inertia:
% [agent,physobj1,physobj2,location,time]
% PartOf(physobj1,physobj2) ->
% Releases(Hold(agent,physobj1),At(physobj2,location),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',145).

 /*  axiom(releases(hold(Agent, Physobj1), at(Physobj2, Location), Time),
       [partOf(Physobj1, Physobj2)]).
 */

 /*  partOf(Hold, Partof) ->
       releases(hold(_, Hold),
                at(Partof, Tloc),
                Releases).
 */
if partOf(Hold, Partof)then releases(hold(_, Hold), loc_at(Partof, Tloc), Releases).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',145).

 /*  reactive_rule([partOf(Hold,Partof)],
   	      [ releases(hold(_,Hold),
   			 loc_at(Partof,Tloc),
   			 Releases)
   	      ]).
 */


%;[agent,physobj,location1,location2,time]
%;(!{object} PartOf(physobj,object)) &
%;HoldsAt(At(agent,location1),time) &
%;location1 != location2 ->
%;Terminates(LetGoOf(agent,physobj),At(physobj,location2),time).
% [agent,physobj,location,time]
% (!{object} PartOf(physobj,object)) &
% HoldsAt(At(agent,location),time) ->
% Initiates(LetGoOf(agent,physobj),At(physobj,location),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',155).

 /*  axiom(initiates(letGoOf(Agent, Physobj), at(Physobj, Location), Time),
       [not(partOf(Physobj, Object)), at(Agent, Location)]).
 */

 /*  (   not(partOf(Letgoof, Partof)),
       at(A, Tloc)
   ->  initiates(letGoOf(A, Letgoof),
                 at(Letgoof, Tloc),
                 Initiates)
   ).
 */
if not partOf(Letgoof, Partof), loc_at(A, Tloc)then initiates(letGoOf(A, Letgoof), loc_at(Letgoof, Tloc)at Initiates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',155).

 /*  reactive_rule([ not(partOf(Letgoof,Partof)),
   		holds(loc_at(A,Tloc),Holds)
   	      ],
   	      [ initiates(letGoOf(A,Letgoof),
   			  at(loc_at(Letgoof,Tloc),
   			     Initiates),
   			  Initiates10)
   	      ]).
 */


%;[agent,physobj1,physobj2,location1,location2,time]
%;PartOf(physobj1,physobj2) &
%;(!{object} PartOf(physobj2,object)) &
%;HoldsAt(At(agent,location1),time) &
%;location1 != location2 ->
%;Terminates(LetGoOf(agent,physobj1),At(physobj2,location2),time).
% [agent,physobj1,physobj2,location,time]
% PartOf(physobj1,physobj2) &
% (!{object} PartOf(physobj2,object)) &
% HoldsAt(At(agent,location),time) ->
% Initiates(LetGoOf(agent,physobj1),At(physobj2,location),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',167).

 /*  axiom(initiates(letGoOf(Agent, Physobj1), at(Physobj2, Location), Time),
       [ partOf(Physobj1, Physobj2),
         not(partOf(Physobj2, Object)),
         at(Agent, Location)
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',167).

 /*  (   partOf(Letgoof, Partof),
       not(partOf(Partof, Partof8)),
       at(A, Tloc)
   ->  initiates(letGoOf(A, Letgoof),
                 at(Partof, Tloc),
                 Initiates)
   ).
 */
if partOf(Letgoof, Partof), not partOf(Partof, Partof8), loc_at(A, Tloc)then initiates(letGoOf(A, Letgoof), loc_at(Partof, Tloc)at Initiates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',167).

 /*  reactive_rule([ partOf(Letgoof,Partof),
   		not(partOf(Partof,Partof8)),
   		holds(loc_at(A,Tloc),Holds)
   	      ],
   	      [ initiates(letGoOf(A,Letgoof),
   			  at(loc_at(Partof,Tloc),
   			     Initiates),
   			  Initiates12)
   	      ]).
 */


%; An effect axiom states that if an agent is at a location
%; and lets go of a physical object, the physical object
%; will be at the location:
% [agent,physobj,location,time]
% HoldsAt(At(agent,location),time) ->
% Initiates(LetGoOf(agent,physobj),At(physobj,location),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',176).

 /*  axiom(initiates(letGoOf(Agent, Physobj), at(Physobj, Location), Time),
       [at(Agent, Location)]).
 */

 /*  at(A, Tloc) ->
       initiates(letGoOf(A, Letgoof),
                 at(Letgoof, Tloc),
                 Initiates).
 */
if loc_at(A, Tloc)then initiates(letGoOf(A, Letgoof), loc_at(Letgoof, Tloc)at Initiates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',176).

 /*  reactive_rule([holds(loc_at(A,Tloc),Holds)],
   	      [ initiates(letGoOf(A,Letgoof),
   			  at(loc_at(Letgoof,Tloc),
   			     Initiates),
   			  Initiates8)
   	      ]).
 */


%; An effect axiom states that if an agent picks up
%; some stuff out of some other stuff, the agent will
%; be holding the first stuff:
% [agent,stuff1,stuff2,time]
% Initiates(HoldSome(agent,stuff1,stuff2),
%           Holding(agent,stuff1),
%           time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',183).

 /*  axiom(initiates(holdSome(Agent, Stuff1, Stuff2), holding(Agent, Stuff1), Time),
       []).
 */

 /*  initiates(holdSome(HoldsomeP_Num3_V,Holding,Holdsome),
   	  holding(HoldsomeP_Num3_V,Holding),
   	  Initiates).
 */
holdSome(HoldsomeP_Num3_V, Holding, Holdsome)initiates holding(HoldsomeP_Num3_V, Holding).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',183).

 /*  initiated(happens(holdSome(HoldsomeP_Num3_V,
   			   Holding,
   			   Holdsome),
   		  Time_From,
   		  Time_Until),
   	  holding(HoldsomeP_Num3_V,Holding),
   	  []).
 */


%; A precondition axiom states that
%; for an agent to pick up some stuff out of some other stuff,
%; the first stuff must be a part of the second stuff and
%; there must be a location such that the agent is at the location,
%; the first stuff is at the location, and the second stuff is
%; at the location:
% [agent,stuff1,stuff2,time]
% Happens(HoldSome(agent,stuff1,stuff2),time) ->
% PartOf(stuff1,stuff2) &
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',194).
% {location}% 
%   HoldsAt(At(agent,location),time) &
%   HoldsAt(At(stuff1,location),time) &
%   HoldsAt(At(stuff2,location),time).
 %  clausify_pnf=exists([Location],  (happens(holdSome(Agent, Stuff1, Stuff2), Time)->partOf(Stuff1, Stuff2), holds_at(at(Agent, Location), Time), holds_at(at(Stuff1, Location), Time), holds_at(at(Stuff2, Location), Time))).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',197).

 /*  not(happens(holdSome(Agent, Stuff1, Stuff2), Time)) :-
       (   not(partOf(Stuff1, Stuff2))
       ;   not(holds_at(at(Agent, Exists_Location), Time))
       ;   not(holds_at(at(Stuff1, Exists_Location), Time))
       ;   not(holds_at(at(Stuff2, Exists_Location), Time))
       ),
       some(Exists_Location,
            '$kolem_Fn_83'(Agent, Stuff1, Stuff2, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',197).

 /*  fix_axiom_head(Time) ->
       [ not(happens(holdSome(Agent, Stuff1, Stuff2), Time)),
          (->),
         not(holdSome(Agent, Stuff1, Stuff2))
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',197).

 /*  axiom(not(holdSome(Agent, Stuff1, Stuff2)),
       [  (not(partOf(Stuff1, Stuff2));not(at(Agent, Exists_Location));not(at(Stuff1, Exists_Location));not(at(Stuff2, Exists_Location))),
         some(Exists_Location,
              '$kolem_Fn_83'(Agent, Stuff1, Stuff2, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',197).

 /*  (   (   not(partOf(A, Partof))
       ;   not(at(Kolem_Fn_83P_Num4_V, Tloc))
       ;   not(at(A, Tloc))
       ;   not(at(Partof, Tloc))
       ),
       some(Tloc,
            '$kolem_Fn_83'(Kolem_Fn_83P_Num4_V,
                           A,
                           Partof,
                           Kolem_Fn_83))
   ->  not(holdSome(Kolem_Fn_83P_Num4_V, A, Partof))
   ).
 */
if (not partOf(A, Partof);not loc_at(Kolem_Fn_83P_Num4_V, Tloc);not loc_at(A, Tloc);not loc_at(Partof, Tloc)), some(Tloc, '$kolem_Fn_83'(Kolem_Fn_83P_Num4_V, A, Partof, Kolem_Fn_83))then not holdSome(Kolem_Fn_83P_Num4_V, A, Partof).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',197).

 /*   reactive_rule([  (not(partOf(A, Partof));not(loc_at(Kolem_Fn_83P_Num4_V, Tloc));not(loc_at(A, Tloc));not(loc_at(Partof, Tloc))),
                      some(Tloc,
                           '$kolem_Fn_83'(Kolem_Fn_83P_Num4_V,
                                          A,
                                          Partof,
                                          Kolem_Fn_83))
                    ],
                    [ not(holdSome(Kolem_Fn_83P_Num4_V,
                                   A,
                                   Partof))
                    ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',197).

 /*  partOf(Stuff1, Stuff2) :-
       happens(holdSome(Agent, Stuff1, Stuff2), Time),
       some(Exists_Location,
            '$kolem_Fn_83'(Agent, Stuff1, Stuff2, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',197).

 /*  fix_axiom_head(Time) ->
       [ happens(holdSome(Agent, Stuff1, Stuff2), Time),
          (->),
         holdSome(Agent, Stuff1, Stuff2)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',197).

 /*  axiom(partOf(Stuff1, Stuff2),
       [ holdSome(Agent, Stuff1, Stuff2),
         some(Exists_Location,
              '$kolem_Fn_83'(Agent, Stuff1, Stuff2, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',197).

 /*  (   holdSome(HoldsomeP_Num3_V, A, Holdsome),
       some(_,
            '$kolem_Fn_83'(HoldsomeP_Num3_V,
                           A,
                           Holdsome,
                           Kolem_Fn_8312))
   ->  partOf(A, Holdsome)
   ).
 */
if holdSome(HoldsomeP_Num3_V, A, Holdsome), some(_, '$kolem_Fn_83'(HoldsomeP_Num3_V, A, Holdsome, Kolem_Fn_8312))then partOf(A, Holdsome).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',197).

 /*  reactive_rule([ happens(holdSome(HoldsomeP_Num3_V,
   				 A,
   				 Holdsome),
   			Time_From,
   			Time_Until),
   		some(_,
   		     '$kolem_Fn_83'(HoldsomeP_Num3_V,
   				    A,
   				    Holdsome,
   				    Kolem_Fn_8312))
   	      ],
   	      [partOf(A,Holdsome)]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',197).

 /*  holds_at(at(Agent, Exists_Location), Time) :-
       happens(holdSome(Agent, Stuff1, Stuff2), Time),
       some(Exists_Location,
            '$kolem_Fn_83'(Agent, Stuff1, Stuff2, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',197).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Agent, Exists_Location), Time),
          (->),
         at(Agent, Exists_Location)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',197).

 /*  axiom(at(Agent, Exists_Location),
       [ holdSome(Agent, Stuff1, Stuff2),
         some(Exists_Location,
              '$kolem_Fn_83'(Agent, Stuff1, Stuff2, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',197).

 /*  (   holdSome(HoldsomeP_Num3_V17, A, Holdsome16),
       some(Tloc15,
            '$kolem_Fn_83'(HoldsomeP_Num3_V17,
                           A,
                           Holdsome16,
                           Kolem_Fn_8318))
   ->  at(HoldsomeP_Num3_V17, Tloc15)
   ).
 */
if holdSome(HoldsomeP_Num3_V17, A, Holdsome16), some(Tloc15, '$kolem_Fn_83'(HoldsomeP_Num3_V17, A, Holdsome16, Kolem_Fn_8318))then loc_at(HoldsomeP_Num3_V17, Tloc15).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',197).

 /*  reactive_rule([ happens(holdSome(HoldsomeP_Num3_V17,
   				 A,
   				 Holdsome16),
   			Time_From19,
   			Time_Until20),
   		some(Tloc15,
   		     '$kolem_Fn_83'(HoldsomeP_Num3_V17,
   				    A,
   				    Holdsome16,
   				    Kolem_Fn_8318))
   	      ],
   	      [ holds(loc_at(HoldsomeP_Num3_V17,Tloc15),
   		      Holds)
   	      ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',197).

 /*  holds_at(at(Stuff1, Exists_Location), Time) :-
       happens(holdSome(Agent, Stuff1, Stuff2), Time),
       some(Exists_Location,
            '$kolem_Fn_83'(Agent, Stuff1, Stuff2, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',197).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Stuff1, Exists_Location), Time),
          (->),
         at(Stuff1, Exists_Location)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',197).

 /*  axiom(at(Stuff1, Exists_Location),
       [ holdSome(Agent, Stuff1, Stuff2),
         some(Exists_Location,
              '$kolem_Fn_83'(Agent, Stuff1, Stuff2, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',197).

 /*  (   holdSome(HoldsomeP_Num3_V24, A, Holdsome23),
       some(Tloc22,
            '$kolem_Fn_83'(HoldsomeP_Num3_V24,
                           A,
                           Holdsome23,
                           Kolem_Fn_8325))
   ->  at(A, Tloc22)
   ).
 */
if holdSome(HoldsomeP_Num3_V24, A, Holdsome23), some(Tloc22, '$kolem_Fn_83'(HoldsomeP_Num3_V24, A, Holdsome23, Kolem_Fn_8325))then loc_at(A, Tloc22).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',197).

 /*  reactive_rule([ happens(holdSome(HoldsomeP_Num3_V24,
   				 A,
   				 Holdsome23),
   			Time_From26,
   			Time_Until27),
   		some(Tloc22,
   		     '$kolem_Fn_83'(HoldsomeP_Num3_V24,
   				    A,
   				    Holdsome23,
   				    Kolem_Fn_8325))
   	      ],
   	      [holds(loc_at(A,Tloc22),Holds28)]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',197).

 /*  holds_at(at(Stuff2, Exists_Location), Time) :-
       happens(holdSome(Agent, Stuff1, Stuff2), Time),
       some(Exists_Location,
            '$kolem_Fn_83'(Agent, Stuff1, Stuff2, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',197).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Stuff2, Exists_Location), Time),
          (->),
         at(Stuff2, Exists_Location)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',197).

 /*  axiom(at(Stuff2, Exists_Location),
       [ holdSome(Agent, Stuff1, Stuff2),
         some(Exists_Location,
              '$kolem_Fn_83'(Agent, Stuff1, Stuff2, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',197).

 /*  (   holdSome(HoldsomeP_Num3_V31, A, Holdsome30),
       some(Tloc29,
            '$kolem_Fn_83'(HoldsomeP_Num3_V31,
                           A,
                           Holdsome30,
                           Kolem_Fn_8332))
   ->  at(Holdsome30, Tloc29)
   ).
 */
if holdSome(HoldsomeP_Num3_V31, A, Holdsome30), some(Tloc29, '$kolem_Fn_83'(HoldsomeP_Num3_V31, A, Holdsome30, Kolem_Fn_8332))then loc_at(Holdsome30, Tloc29).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',197).

 /*  reactive_rule([ happens(holdSome(HoldsomeP_Num3_V31,
   				 A,
   				 Holdsome30),
   			Time_From33,
   			Time_Until34),
   		some(Tloc29,
   		     '$kolem_Fn_83'(HoldsomeP_Num3_V31,
   				    A,
   				    Holdsome30,
   				    Kolem_Fn_8332))
   	      ],
   	      [ holds(loc_at(Holdsome30,Tloc29),
   		      Holds35)
   	      ]).
 */


%; A releases axiom states that if an agent picks up some
%; stuff out of some other stuff,
%; the first stuff's location will be released
%; from inertia:
% [agent,stuff1,stuff2,location,time]
% Releases(HoldSome(agent,stuff1,stuff2),At(stuff1,location),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',206).

 /*  axiom(releases(holdSome(Agent, Stuff1, Stuff2), at(Stuff1, Location), Time),
       []).
 */

 /*  releases(holdSome(HoldsomeP_Num3_V,A,Holdsome),
   	 at(A,Tloc),
   	 Releases).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',206).
releases(holdSome(HoldsomeP_Num3_V,A,Holdsome),
	 loc_at(A,Tloc),
	 Releases).


%; Inside
%; physobj1 is inside physobj2.

% fluent Inside(physobj,physobj)
 %  fluent(inside(physobj,physobj)).
 %  fluent(inside(physobj,physobj)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',211).
fluents([inside/2]).
mpred_prop(inside(physobj,physobj),fluent).


%; agent puts physobj1 inside physobj2.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',214).
% event PutInside(agent,physobj,physobj)
 %  event(putInside(agent,physobj,physobj)).
 %  event(putInside(agent,physobj,physobj)).
actions([putInside/3]).
mpred_prop(putInside(agent,physobj,physobj),event).


%; agent takes physobj1 out of physobj2.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',216).
% event TakeOutOf(agent,physobj,physobj)
 %  event(takeOutOf(agent,physobj,physobj)).
 %  event(takeOutOf(agent,physobj,physobj)).
actions([takeOutOf/3]).
mpred_prop(takeOutOf(agent,physobj,physobj),event).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',218).
%; A state constraint says that a physical object cannot
%; be inside itself:
% [physobj1,physobj2,time]
% HoldsAt(Inside(physobj1,physobj2),time) ->
% physobj1!=physobj2.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',220).

 /*  holds_at(inside(Physobj1, Physobj2), Time) ->
       diff(Physobj1, Physobj2).
 */
if inside(Physobj1, Physobj2)at Time then diff(Physobj1, Physobj2).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',220).

 /*  reactive_rule([holds(inside(Physobj1,Physobj2),Time)],
   	      [diff(Physobj1,Physobj2)]).
 */


%; A state constraint says that if a physical object is
%; inside another physical object, the second physical object
%; is not inside the first physical object:
% [physobj1,physobj2,time]
% HoldsAt(Inside(physobj1,physobj2),time) ->
% !HoldsAt(Inside(physobj2,physobj1),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',227).

 /*  holds_at(inside(Physobj1, Physobj2), Time) ->
       holds_at(neg(inside(Physobj2, Physobj1)), Time).
 */
if inside(Physobj1, Physobj2)at Time then not inside(Physobj2, Physobj1)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',227).

 /*  reactive_rule([holds(inside(Physobj1,Physobj2),Time)],
   	      [ holds(not(inside(Physobj2,Physobj1)),
   		      Time)
   	      ]).
 */


%; An effect axiom states that if an agent puts a physical
%; object inside another physical object, the first
%; physical object will be inside the second physical object:
% [agent,physobj1,physobj2,time]
% Initiates(PutInside(agent,physobj1,physobj2),
%           Inside(physobj1,physobj2),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',234).

 /*  axiom(initiates(putInside(Agent, Physobj1, Physobj2), inside(Physobj1, Physobj2), Time),
       []).
 */

 /*  initiates(putInside(PutinsideP_Num3_V,A,Putinside),
   	  inside(A,Putinside),
   	  Initiates).
 */
putInside(PutinsideP_Num3_V, A, Putinside)initiates inside(A, Putinside).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',234).

 /*  initiated(happens(putInside(PutinsideP_Num3_V,
   			    A,
   			    Putinside),
   		  Time_From,
   		  Time_Until),
   	  inside(A,Putinside),
   	  []).
 */


%; An effect axiom states that if an agent puts a physical
%; object inside another physical object, the agent will
%; no longer be holding the first physical object:
% [agent,physobj1,physobj2,time]
% Terminates(PutInside(agent,physobj1,physobj2),
%            Holding(agent,physobj1),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',241).

 /*  axiom(terminates(putInside(Agent, Physobj1, Physobj2), holding(Agent, Physobj1), Time),
       []).
 */

 /*  terminates(putInside(PutinsideP_Num3_V,
   		     Holding,
   		     Putinside),
   	   holding(PutinsideP_Num3_V,Holding),
   	   Terminates).
 */
putInside(PutinsideP_Num3_V, Holding, Putinside)terminates holding(PutinsideP_Num3_V, Holding).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',241).

 /*  terminated(happens(putInside(PutinsideP_Num3_V,
   			     Holding,
   			     Putinside),
   		   Time_From,
   		   Time_Until),
   	   holding(PutinsideP_Num3_V,Holding),
   	   []).
 */


%; A precondition axiom states that
%; for an agent to put a physical object inside another
%; physical object,
%; the agent must be holding the first physical object
%; and there must be a location such that
%; the agent is at the location and
%; the second physical object is at the location:
%;[agent,physobj1,physobj2,time]
%;Happens(PutInside(agent,physobj1,physobj2),time) ->
%;HoldsAt(Holding(agent,physobj1),time) &
%;{location}
%; HoldsAt(At(agent,location),time) &
%; HoldsAt(At(physobj2,location),time).
%; An effect axiom states that
%; if an agent takes a physical object out of another
%; physical object, the first physical object
%; will no longer be inside the second physical object:
% [agent,physobj1,physobj2,time]
% Terminates(TakeOutOf(agent,physobj1,physobj2),
%            Inside(physobj1,physobj2),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',263).

 /*  axiom(terminates(takeOutOf(Agent, Physobj1, Physobj2), inside(Physobj1, Physobj2), Time),
       []).
 */

 /*  terminates(takeOutOf(TakeoutofP_Num3_V,A,Takeoutof),
   	   inside(A,Takeoutof),
   	   Terminates).
 */
takeOutOf(TakeoutofP_Num3_V, A, Takeoutof)terminates inside(A, Takeoutof).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',263).

 /*  terminated(happens(takeOutOf(TakeoutofP_Num3_V,
   			     A,
   			     Takeoutof),
   		   Time_From,
   		   Time_Until),
   	   inside(A,Takeoutof),
   	   []).
 */


%; A precondition axiom states that
%; for an agent to take a physical object out of another
%; physical object,
%; the first physical object must be inside the second physical object
%; and there must be a location such that
%; the agent is at the location,
%; the first physical object is at the location, and
%; the second physical object is at the location:
% [agent,physobj1,physobj2,time]
% Happens(TakeOutOf(agent,physobj1,physobj2),time) ->
% HoldsAt(Inside(physobj1,physobj2),time) &
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',275).
% {location}% 
%  HoldsAt(At(agent,location),time) &
%  HoldsAt(At(physobj1,location),time) &
%  HoldsAt(At(physobj2,location),time).
 %  clausify_pnf=exists([Location],  (happens(takeOutOf(Agent, Physobj1, Physobj2), Time)->holds_at(inside(Physobj1, Physobj2), Time), holds_at(at(Agent, Location), Time), holds_at(at(Physobj1, Location), Time), holds_at(at(Physobj2, Location), Time))).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',278).

 /*  not(happens(takeOutOf(Agent, Physobj1, Physobj2), Time)) :-
       (   not(holds_at(inside(Physobj1, Physobj2), Time))
       ;   not(holds_at(at(Agent, Exists_Location), Time))
       ;   not(holds_at(at(Physobj1, Exists_Location), Time))
       ;   not(holds_at(at(Physobj2, Exists_Location), Time))
       ),
       some(Exists_Location,
            '$kolem_Fn_84'(Agent, Physobj1, Physobj2, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',278).

 /*  fix_axiom_head(Time) ->
       [ not(happens(takeOutOf(Agent, Physobj1, Physobj2),
                     Time)),
          (->),
         not(takeOutOf(Agent, Physobj1, Physobj2))
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',278).

 /*  axiom(not(takeOutOf(Agent, Physobj1, Physobj2)),
       [  (not(inside(Physobj1, Physobj2));not(at(Agent, Exists_Location));not(at(Physobj1, Exists_Location));not(at(Physobj2, Exists_Location))),
         some(Exists_Location,
              '$kolem_Fn_84'(Agent, Physobj1, Physobj2, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',278).

 /*  (   (   not(inside(A, Inside))
       ;   not(at(Kolem_Fn_84P_Num4_V, Tloc))
       ;   not(at(A, Tloc))
       ;   not(at(Inside, Tloc))
       ),
       some(Tloc,
            '$kolem_Fn_84'(Kolem_Fn_84P_Num4_V,
                           A,
                           Inside,
                           Kolem_Fn_84))
   ->  not(takeOutOf(Kolem_Fn_84P_Num4_V, A, Inside))
   ).
 */
if (not inside(A, Inside);not loc_at(Kolem_Fn_84P_Num4_V, Tloc);not loc_at(A, Tloc);not loc_at(Inside, Tloc)), some(Tloc, '$kolem_Fn_84'(Kolem_Fn_84P_Num4_V, A, Inside, Kolem_Fn_84))then not takeOutOf(Kolem_Fn_84P_Num4_V, A, Inside).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',278).

 /*   reactive_rule([  (not(inside(A, Inside));not(loc_at(Kolem_Fn_84P_Num4_V, Tloc));not(loc_at(A, Tloc));not(loc_at(Inside, Tloc))),
                      some(Tloc,
                           '$kolem_Fn_84'(Kolem_Fn_84P_Num4_V,
                                          A,
                                          Inside,
                                          Kolem_Fn_84))
                    ],
                    [ not(takeOutOf(Kolem_Fn_84P_Num4_V,
                                    A,
                                    Inside))
                    ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',278).

 /*  holds_at(inside(Physobj1, Physobj2), Time) :-
       happens(takeOutOf(Agent, Physobj1, Physobj2), Time),
       some(Exists_Location,
            '$kolem_Fn_84'(Agent, Physobj1, Physobj2, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',278).

 /*  fix_axiom_head(Time) ->
       [ holds_at(inside(Physobj1, Physobj2), Time),
          (->),
         inside(Physobj1, Physobj2)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',278).

 /*  axiom(inside(Physobj1, Physobj2),
       [ takeOutOf(Agent, Physobj1, Physobj2),
         some(Exists_Location,
              '$kolem_Fn_84'(Agent, Physobj1, Physobj2, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',278).

 /*  (   takeOutOf(TakeoutofP_Num3_V, A, Takeoutof),
       some(_,
            '$kolem_Fn_84'(TakeoutofP_Num3_V,
                           A,
                           Takeoutof,
                           Kolem_Fn_8412))
   ->  inside(A, Takeoutof)
   ).
 */
if takeOutOf(TakeoutofP_Num3_V, A, Takeoutof), some(_, '$kolem_Fn_84'(TakeoutofP_Num3_V, A, Takeoutof, Kolem_Fn_8412))then inside(A, Takeoutof).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',278).

 /*  reactive_rule([ happens(takeOutOf(TakeoutofP_Num3_V,
   				  A,
   				  Takeoutof),
   			Time_From,
   			Time_Until),
   		some(_,
   		     '$kolem_Fn_84'(TakeoutofP_Num3_V,
   				    A,
   				    Takeoutof,
   				    Kolem_Fn_8412))
   	      ],
   	      [holds(inside(A,Takeoutof),Holds)]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',278).

 /*  holds_at(at(Agent, Exists_Location), Time) :-
       happens(takeOutOf(Agent, Physobj1, Physobj2), Time),
       some(Exists_Location,
            '$kolem_Fn_84'(Agent, Physobj1, Physobj2, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',278).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Agent, Exists_Location), Time),
          (->),
         at(Agent, Exists_Location)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',278).

 /*  axiom(at(Agent, Exists_Location),
       [ takeOutOf(Agent, Physobj1, Physobj2),
         some(Exists_Location,
              '$kolem_Fn_84'(Agent, Physobj1, Physobj2, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',278).

 /*  (   takeOutOf(TakeoutofP_Num3_V18, A, Takeoutof17),
       some(Tloc16,
            '$kolem_Fn_84'(TakeoutofP_Num3_V18,
                           A,
                           Takeoutof17,
                           Kolem_Fn_8419))
   ->  at(TakeoutofP_Num3_V18, Tloc16)
   ).
 */
if takeOutOf(TakeoutofP_Num3_V18, A, Takeoutof17), some(Tloc16, '$kolem_Fn_84'(TakeoutofP_Num3_V18, A, Takeoutof17, Kolem_Fn_8419))then loc_at(TakeoutofP_Num3_V18, Tloc16).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',278).

 /*  reactive_rule([ happens(takeOutOf(TakeoutofP_Num3_V18,
   				  A,
   				  Takeoutof17),
   			Time_From20,
   			Time_Until21),
   		some(Tloc16,
   		     '$kolem_Fn_84'(TakeoutofP_Num3_V18,
   				    A,
   				    Takeoutof17,
   				    Kolem_Fn_8419))
   	      ],
   	      [ holds(loc_at(TakeoutofP_Num3_V18,Tloc16),
   		      Holds22)
   	      ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',278).

 /*  holds_at(at(Physobj1, Exists_Location), Time) :-
       happens(takeOutOf(Agent, Physobj1, Physobj2), Time),
       some(Exists_Location,
            '$kolem_Fn_84'(Agent, Physobj1, Physobj2, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',278).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Physobj1, Exists_Location), Time),
          (->),
         at(Physobj1, Exists_Location)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',278).

 /*  axiom(at(Physobj1, Exists_Location),
       [ takeOutOf(Agent, Physobj1, Physobj2),
         some(Exists_Location,
              '$kolem_Fn_84'(Agent, Physobj1, Physobj2, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',278).

 /*  (   takeOutOf(TakeoutofP_Num3_V25, A, Takeoutof24),
       some(Tloc23,
            '$kolem_Fn_84'(TakeoutofP_Num3_V25,
                           A,
                           Takeoutof24,
                           Kolem_Fn_8426))
   ->  at(A, Tloc23)
   ).
 */
if takeOutOf(TakeoutofP_Num3_V25, A, Takeoutof24), some(Tloc23, '$kolem_Fn_84'(TakeoutofP_Num3_V25, A, Takeoutof24, Kolem_Fn_8426))then loc_at(A, Tloc23).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',278).

 /*  reactive_rule([ happens(takeOutOf(TakeoutofP_Num3_V25,
   				  A,
   				  Takeoutof24),
   			Time_From27,
   			Time_Until28),
   		some(Tloc23,
   		     '$kolem_Fn_84'(TakeoutofP_Num3_V25,
   				    A,
   				    Takeoutof24,
   				    Kolem_Fn_8426))
   	      ],
   	      [holds(loc_at(A,Tloc23),Holds29)]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',278).

 /*  holds_at(at(Physobj2, Exists_Location), Time) :-
       happens(takeOutOf(Agent, Physobj1, Physobj2), Time),
       some(Exists_Location,
            '$kolem_Fn_84'(Agent, Physobj1, Physobj2, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',278).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Physobj2, Exists_Location), Time),
          (->),
         at(Physobj2, Exists_Location)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',278).

 /*  axiom(at(Physobj2, Exists_Location),
       [ takeOutOf(Agent, Physobj1, Physobj2),
         some(Exists_Location,
              '$kolem_Fn_84'(Agent, Physobj1, Physobj2, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',278).

 /*  (   takeOutOf(TakeoutofP_Num3_V32, A, Takeoutof31),
       some(Tloc30,
            '$kolem_Fn_84'(TakeoutofP_Num3_V32,
                           A,
                           Takeoutof31,
                           Kolem_Fn_8433))
   ->  at(Takeoutof31, Tloc30)
   ).
 */
if takeOutOf(TakeoutofP_Num3_V32, A, Takeoutof31), some(Tloc30, '$kolem_Fn_84'(TakeoutofP_Num3_V32, A, Takeoutof31, Kolem_Fn_8433))then loc_at(Takeoutof31, Tloc30).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',278).

 /*  reactive_rule([ happens(takeOutOf(TakeoutofP_Num3_V32,
   				  A,
   				  Takeoutof31),
   			Time_From34,
   			Time_Until35),
   		some(Tloc30,
   		     '$kolem_Fn_84'(TakeoutofP_Num3_V32,
   				    A,
   				    Takeoutof31,
   				    Kolem_Fn_8433))
   	      ],
   	      [ holds(loc_at(Takeoutof31,Tloc30),
   		      Holds36)
   	      ]).
 */


%; A releases axiom states that if an agent puts a physical
%; object inside another physical object,
%; the first physical object's location will be released
%; from inertia:
% [agent,physobj1,physobj2,location,time]
% Releases(PutInside(agent,physobj1,physobj2),
%          At(physobj1,location),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',287).

 /*  axiom(releases(putInside(Agent, Physobj1, Physobj2), at(Physobj1, Location), Time),
       []).
 */

 /*  releases(putInside(PutinsideP_Num3_V,A,Putinside),
   	 at(A,Tloc),
   	 Releases).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',287).
releases(putInside(PutinsideP_Num3_V,A,Putinside),
	 loc_at(A,Tloc),
	 Releases).


%; A state constraint says that if a physical object is inside
%; another physical object and the second physical object is
%; at a location, the first physical object is also at the location:
% [physobj1,physobj2,location,time]
% HoldsAt(Inside(physobj1,physobj2),time) &
% HoldsAt(At(physobj2,location),time) ->
% HoldsAt(At(physobj1,location),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',294).

 /*  (   holds_at(inside(Physobj1, Physobj2), Time),
       holds_at(at(Physobj2, Location), Time)
   ->  holds_at(at(Physobj1, Location), Time)
   ).
 */
if inside(Physobj1, Physobj2)at Time, loc_at(Physobj2, Location)at Time then loc_at(Physobj1, Location)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',294).

 /*  reactive_rule([ holds(inside(Physobj1,Physobj2),Time),
   		holds(loc_at(Physobj2,Location),Time)
   	      ],
   	      [holds(loc_at(Physobj1,Location),Time)]).
 */


%; An effect axiom states that if an agent takes a physical
%; object out of another physical object,
%; the agent will be holding the first physical object:
% [agent,physobj1,physobj2,time]
% Initiates(TakeOutOf(agent,physobj1,physobj2),
%           Holding(agent,physobj1),
%           time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',302).

 /*  axiom(initiates(takeOutOf(Agent, Physobj1, Physobj2), holding(Agent, Physobj1), Time),
       []).
 */

 /*  initiates(takeOutOf(TakeoutofP_Num3_V,
   		    Holding,
   		    Takeoutof),
   	  holding(TakeoutofP_Num3_V,Holding),
   	  Initiates).
 */
takeOutOf(TakeoutofP_Num3_V, Holding, Takeoutof)initiates holding(TakeoutofP_Num3_V, Holding).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',302).

 /*  initiated(happens(takeOutOf(TakeoutofP_Num3_V,
   			    Holding,
   			    Takeoutof),
   		  Time_From,
   		  Time_Until),
   	  holding(TakeoutofP_Num3_V,Holding),
   	  []).
 */


%; On
%; physobj1 is on physobj2.

% fluent On(physobj,physobj)
 %  fluent(on(physobj,physobj)).
 %  fluent(on(physobj,physobj)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',309).
fluents([on/2]).
mpred_prop(on(physobj,physobj),fluent).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',312).
%; agent places physobj1 on physobj2.

% event PlaceOn(agent,physobj,physobj)
 %  event(placeOn(agent,physobj,physobj)).
 %  event(placeOn(agent,physobj,physobj)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',312).
actions([placeOn/3]).
mpred_prop(placeOn(agent,physobj,physobj),event).


%; agent takes physobj1 off of physobj2.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',315).
% event TakeOffOf(agent,physobj,physobj)
 %  event(takeOffOf(agent,physobj,physobj)).
 %  event(takeOffOf(agent,physobj,physobj)).
actions([takeOffOf/3]).
mpred_prop(takeOffOf(agent,physobj,physobj),event).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',317).
%; A state constraint says that a physical object cannot
%; be on itself:
% [physobj1,physobj2,time]
% HoldsAt(On(physobj1,physobj2),time) ->
% physobj1!=physobj2.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',319).

 /*  holds_at(on(Physobj1, Physobj2), Time) ->
       diff(Physobj1, Physobj2).
 */
if on(Physobj1, Physobj2)at Time then diff(Physobj1, Physobj2).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',319).

 /*  reactive_rule([holds(on(Physobj1,Physobj2),Time)],
   	      [diff(Physobj1,Physobj2)]).
 */


%; A state constraint says that if a physical object is
%; on another physical object, the second physical object
%; is not on the first physical object:
% [physobj1,physobj2,time]
% HoldsAt(On(physobj1,physobj2),time) ->
% !HoldsAt(On(physobj2,physobj1),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',326).

 /*  holds_at(on(Physobj1, Physobj2), Time) ->
       holds_at(neg(on(Physobj2, Physobj1)), Time).
 */
if on(Physobj1, Physobj2)at Time then not on(Physobj2, Physobj1)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',326).

 /*  reactive_rule([holds(on(Physobj1,Physobj2),Time)],
   	      [ holds(not(on(Physobj2,Physobj1)),
   		      Time)
   	      ]).
 */


%; An effect axiom states that if an agent places a physical
%; object on another physical object, the first
%; physical object will be on the second physical object:
% [agent,physobj1,physobj2,time]
% Initiates(PlaceOn(agent,physobj1,physobj2),
%           On(physobj1,physobj2),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',333).

 /*  axiom(initiates(placeOn(Agent, Physobj1, Physobj2), on(Physobj1, Physobj2), Time),
       []).
 */

 /*  initiates(placeOn(PlaceonP_Num3_V,A,Placeon),
   	  on(A,Placeon),
   	  Initiates).
 */
placeOn(PlaceonP_Num3_V, A, Placeon)initiates on(A, Placeon).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',333).

 /*  initiated(happens(placeOn(PlaceonP_Num3_V,A,Placeon),
   		  Time_From,
   		  Time_Until),
   	  on(A,Placeon),
   	  []).
 */


%; An effect axiom states that if an agent places a physical
%; object on another physical object, the agent will
%; no longer be holding the first physical object:
% [agent,physobj1,physobj2,time]
% Terminates(PlaceOn(agent,physobj1,physobj2),
%            Holding(agent,physobj1),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',340).

 /*  axiom(terminates(placeOn(Agent, Physobj1, Physobj2), holding(Agent, Physobj1), Time),
       []).
 */

 /*  terminates(placeOn(PlaceonP_Num3_V,Holding,Placeon),
   	   holding(PlaceonP_Num3_V,Holding),
   	   Terminates).
 */
placeOn(PlaceonP_Num3_V, Holding, Placeon)terminates holding(PlaceonP_Num3_V, Holding).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',340).

 /*  terminated(happens(placeOn(PlaceonP_Num3_V,
   			   Holding,
   			   Placeon),
   		   Time_From,
   		   Time_Until),
   	   holding(PlaceonP_Num3_V,Holding),
   	   []).
 */


%; A precondition axiom states that
%; for an agent to place a physical object on another
%; physical object,
%; the agent must be holding the first physical object
%; and there must be a location such that
%; the agent is at the location and
%; the second physical object is at the location:
%;[agent,physobj1,physobj2,time]
%;Happens(PlaceOn(agent,physobj1,physobj2),time) ->
%;HoldsAt(Holding(agent,physobj1),time) &
%;{location}
%; HoldsAt(At(agent,location),time) &
%; HoldsAt(At(physobj2,location),time).
%; An effect axiom states that
%; if an agent takes a physical object off of another
%; physical object, the first physical object
%; will no longer be on the second physical object:
% [agent,physobj1,physobj2,time]
% Terminates(TakeOffOf(agent,physobj1,physobj2),
%            On(physobj1,physobj2),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',362).

 /*  axiom(terminates(takeOffOf(Agent, Physobj1, Physobj2), on(Physobj1, Physobj2), Time),
       []).
 */

 /*  terminates(takeOffOf(TakeoffofP_Num3_V,A,Takeoffof),
   	   on(A,Takeoffof),
   	   Terminates).
 */
takeOffOf(TakeoffofP_Num3_V, A, Takeoffof)terminates on(A, Takeoffof).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',362).

 /*  terminated(happens(takeOffOf(TakeoffofP_Num3_V,
   			     A,
   			     Takeoffof),
   		   Time_From,
   		   Time_Until),
   	   on(A,Takeoffof),
   	   []).
 */


%; An effect axiom states that if an agent takes a physical
%; object off of another physical object,
%; the agent will be holding the first physical object:
% [agent,physobj1,physobj2,time]
% Initiates(TakeOffOf(agent,physobj1,physobj2),
%           Holding(agent,physobj1),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',369).

 /*  axiom(initiates(takeOffOf(Agent, Physobj1, Physobj2), holding(Agent, Physobj1), Time),
       []).
 */

 /*  initiates(takeOffOf(TakeoffofP_Num3_V,
   		    Holding,
   		    Takeoffof),
   	  holding(TakeoffofP_Num3_V,Holding),
   	  Initiates).
 */
takeOffOf(TakeoffofP_Num3_V, Holding, Takeoffof)initiates holding(TakeoffofP_Num3_V, Holding).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',369).

 /*  initiated(happens(takeOffOf(TakeoffofP_Num3_V,
   			    Holding,
   			    Takeoffof),
   		  Time_From,
   		  Time_Until),
   	  holding(TakeoffofP_Num3_V,Holding),
   	  []).
 */


%; A precondition axiom states that
%; for an agent to take a physical object off of another
%; physical object,
%; the first physical object must be on the second physical object
%; and there must be a location such that
%; the agent is at the location and
%; the first physical object is at the location:
%; the second physical object is at the location:
% [agent,physobj1,physobj2,time]
% Happens(TakeOffOf(agent,physobj1,physobj2),time) ->
% HoldsAt(On(physobj1,physobj2),time) &
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',381).
% {location}% 
%  HoldsAt(At(agent,location),time) &
%  HoldsAt(At(physobj1,location),time) &
%  HoldsAt(At(physobj2,location),time).
 %  clausify_pnf=exists([Location],  (happens(takeOffOf(Agent, Physobj1, Physobj2), Time)->holds_at(on(Physobj1, Physobj2), Time), holds_at(at(Agent, Location), Time), holds_at(at(Physobj1, Location), Time), holds_at(at(Physobj2, Location), Time))).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',384).

 /*  not(happens(takeOffOf(Agent, Physobj1, Physobj2), Time)) :-
       (   not(holds_at(on(Physobj1, Physobj2), Time))
       ;   not(holds_at(at(Agent, Exists_Location), Time))
       ;   not(holds_at(at(Physobj1, Exists_Location), Time))
       ;   not(holds_at(at(Physobj2, Exists_Location), Time))
       ),
       some(Exists_Location,
            '$kolem_Fn_85'(Agent, Physobj1, Physobj2, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',384).

 /*  fix_axiom_head(Time) ->
       [ not(happens(takeOffOf(Agent, Physobj1, Physobj2),
                     Time)),
          (->),
         not(takeOffOf(Agent, Physobj1, Physobj2))
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',384).

 /*  axiom(not(takeOffOf(Agent, Physobj1, Physobj2)),
       [  (not(on(Physobj1, Physobj2));not(at(Agent, Exists_Location));not(at(Physobj1, Exists_Location));not(at(Physobj2, Exists_Location))),
         some(Exists_Location,
              '$kolem_Fn_85'(Agent, Physobj1, Physobj2, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',384).

 /*  (   (   not(on(A, On))
       ;   not(at(Kolem_Fn_85P_Num4_V, Tloc))
       ;   not(at(A, Tloc))
       ;   not(at(On, Tloc))
       ),
       some(Tloc,
            '$kolem_Fn_85'(Kolem_Fn_85P_Num4_V,
                           A,
                           On,
                           Kolem_Fn_85))
   ->  not(takeOffOf(Kolem_Fn_85P_Num4_V, A, On))
   ).
 */
if (not on(A, On);not loc_at(Kolem_Fn_85P_Num4_V, Tloc);not loc_at(A, Tloc);not loc_at(On, Tloc)), some(Tloc, '$kolem_Fn_85'(Kolem_Fn_85P_Num4_V, A, On, Kolem_Fn_85))then not takeOffOf(Kolem_Fn_85P_Num4_V, A, On).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',384).

 /*   reactive_rule([  (not(on(A, On));not(loc_at(Kolem_Fn_85P_Num4_V, Tloc));not(loc_at(A, Tloc));not(loc_at(On, Tloc))),
                      some(Tloc,
                           '$kolem_Fn_85'(Kolem_Fn_85P_Num4_V,
                                          A,
                                          On,
                                          Kolem_Fn_85))
                    ],
                    [not(takeOffOf(Kolem_Fn_85P_Num4_V, A, On))]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',384).

 /*  holds_at(on(Physobj1, Physobj2), Time) :-
       happens(takeOffOf(Agent, Physobj1, Physobj2), Time),
       some(Exists_Location,
            '$kolem_Fn_85'(Agent, Physobj1, Physobj2, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',384).

 /*  fix_axiom_head(Time) ->
       [ holds_at(on(Physobj1, Physobj2), Time),
          (->),
         on(Physobj1, Physobj2)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',384).

 /*  axiom(on(Physobj1, Physobj2),
       [ takeOffOf(Agent, Physobj1, Physobj2),
         some(Exists_Location,
              '$kolem_Fn_85'(Agent, Physobj1, Physobj2, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',384).

 /*  (   takeOffOf(TakeoffofP_Num3_V, A, Takeoffof),
       some(_,
            '$kolem_Fn_85'(TakeoffofP_Num3_V,
                           A,
                           Takeoffof,
                           Kolem_Fn_8512))
   ->  on(A, Takeoffof)
   ).
 */
if takeOffOf(TakeoffofP_Num3_V, A, Takeoffof), some(_, '$kolem_Fn_85'(TakeoffofP_Num3_V, A, Takeoffof, Kolem_Fn_8512))then on(A, Takeoffof).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',384).

 /*  reactive_rule([ happens(takeOffOf(TakeoffofP_Num3_V,
   				  A,
   				  Takeoffof),
   			Time_From,
   			Time_Until),
   		some(_,
   		     '$kolem_Fn_85'(TakeoffofP_Num3_V,
   				    A,
   				    Takeoffof,
   				    Kolem_Fn_8512))
   	      ],
   	      [holds(on(A,Takeoffof),Holds)]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',384).

 /*  holds_at(at(Agent, Exists_Location), Time) :-
       happens(takeOffOf(Agent, Physobj1, Physobj2), Time),
       some(Exists_Location,
            '$kolem_Fn_85'(Agent, Physobj1, Physobj2, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',384).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Agent, Exists_Location), Time),
          (->),
         at(Agent, Exists_Location)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',384).

 /*  axiom(at(Agent, Exists_Location),
       [ takeOffOf(Agent, Physobj1, Physobj2),
         some(Exists_Location,
              '$kolem_Fn_85'(Agent, Physobj1, Physobj2, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',384).

 /*  (   takeOffOf(TakeoffofP_Num3_V18, A, Takeoffof17),
       some(Tloc16,
            '$kolem_Fn_85'(TakeoffofP_Num3_V18,
                           A,
                           Takeoffof17,
                           Kolem_Fn_8519))
   ->  at(TakeoffofP_Num3_V18, Tloc16)
   ).
 */
if takeOffOf(TakeoffofP_Num3_V18, A, Takeoffof17), some(Tloc16, '$kolem_Fn_85'(TakeoffofP_Num3_V18, A, Takeoffof17, Kolem_Fn_8519))then loc_at(TakeoffofP_Num3_V18, Tloc16).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',384).

 /*  reactive_rule([ happens(takeOffOf(TakeoffofP_Num3_V18,
   				  A,
   				  Takeoffof17),
   			Time_From20,
   			Time_Until21),
   		some(Tloc16,
   		     '$kolem_Fn_85'(TakeoffofP_Num3_V18,
   				    A,
   				    Takeoffof17,
   				    Kolem_Fn_8519))
   	      ],
   	      [ holds(loc_at(TakeoffofP_Num3_V18,Tloc16),
   		      Holds22)
   	      ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',384).

 /*  holds_at(at(Physobj1, Exists_Location), Time) :-
       happens(takeOffOf(Agent, Physobj1, Physobj2), Time),
       some(Exists_Location,
            '$kolem_Fn_85'(Agent, Physobj1, Physobj2, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',384).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Physobj1, Exists_Location), Time),
          (->),
         at(Physobj1, Exists_Location)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',384).

 /*  axiom(at(Physobj1, Exists_Location),
       [ takeOffOf(Agent, Physobj1, Physobj2),
         some(Exists_Location,
              '$kolem_Fn_85'(Agent, Physobj1, Physobj2, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',384).

 /*  (   takeOffOf(TakeoffofP_Num3_V25, A, Takeoffof24),
       some(Tloc23,
            '$kolem_Fn_85'(TakeoffofP_Num3_V25,
                           A,
                           Takeoffof24,
                           Kolem_Fn_8526))
   ->  at(A, Tloc23)
   ).
 */
if takeOffOf(TakeoffofP_Num3_V25, A, Takeoffof24), some(Tloc23, '$kolem_Fn_85'(TakeoffofP_Num3_V25, A, Takeoffof24, Kolem_Fn_8526))then loc_at(A, Tloc23).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',384).

 /*  reactive_rule([ happens(takeOffOf(TakeoffofP_Num3_V25,
   				  A,
   				  Takeoffof24),
   			Time_From27,
   			Time_Until28),
   		some(Tloc23,
   		     '$kolem_Fn_85'(TakeoffofP_Num3_V25,
   				    A,
   				    Takeoffof24,
   				    Kolem_Fn_8526))
   	      ],
   	      [holds(loc_at(A,Tloc23),Holds29)]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',384).

 /*  holds_at(at(Physobj2, Exists_Location), Time) :-
       happens(takeOffOf(Agent, Physobj1, Physobj2), Time),
       some(Exists_Location,
            '$kolem_Fn_85'(Agent, Physobj1, Physobj2, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',384).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Physobj2, Exists_Location), Time),
          (->),
         at(Physobj2, Exists_Location)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',384).

 /*  axiom(at(Physobj2, Exists_Location),
       [ takeOffOf(Agent, Physobj1, Physobj2),
         some(Exists_Location,
              '$kolem_Fn_85'(Agent, Physobj1, Physobj2, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',384).

 /*  (   takeOffOf(TakeoffofP_Num3_V32, A, Takeoffof31),
       some(Tloc30,
            '$kolem_Fn_85'(TakeoffofP_Num3_V32,
                           A,
                           Takeoffof31,
                           Kolem_Fn_8533))
   ->  at(Takeoffof31, Tloc30)
   ).
 */
if takeOffOf(TakeoffofP_Num3_V32, A, Takeoffof31), some(Tloc30, '$kolem_Fn_85'(TakeoffofP_Num3_V32, A, Takeoffof31, Kolem_Fn_8533))then loc_at(Takeoffof31, Tloc30).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',384).

 /*  reactive_rule([ happens(takeOffOf(TakeoffofP_Num3_V32,
   				  A,
   				  Takeoffof31),
   			Time_From34,
   			Time_Until35),
   		some(Tloc30,
   		     '$kolem_Fn_85'(TakeoffofP_Num3_V32,
   				    A,
   				    Takeoffof31,
   				    Kolem_Fn_8533))
   	      ],
   	      [ holds(loc_at(Takeoffof31,Tloc30),
   		      Holds36)
   	      ]).
 */


%; A releases axiom states that if an agent places a physical
%; object on another physical object,
%; the first physical object's location will be released
%; from inertia:
% [agent,physobj1,physobj2,location,time]
% Releases(PlaceOn(agent,physobj1,physobj2),
%          At(physobj1,location),
%          time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',393).

 /*  axiom(releases(placeOn(Agent, Physobj1, Physobj2), at(Physobj1, Location), Time),
       []).
 */

 /*  releases(placeOn(PlaceonP_Num3_V,A,Placeon),
   	 at(A,Tloc),
   	 Releases).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',393).
releases(placeOn(PlaceonP_Num3_V,A,Placeon),
	 loc_at(A,Tloc),
	 Releases).


%; A state constraint says that if a physical object is on
%; another physical object and the second physical object is
%; at a location, the first physical object is also at the location:
% [physobj1,physobj2,location,time]
% HoldsAt(On(physobj1,physobj2),time) &
% HoldsAt(At(physobj2,location),time) ->
% HoldsAt(At(physobj1,location),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',401).

 /*  (   holds_at(on(Physobj1, Physobj2), Time),
       holds_at(at(Physobj2, Location), Time)
   ->  holds_at(at(Physobj1, Location), Time)
   ).
 */
if on(Physobj1, Physobj2)at Time, loc_at(Physobj2, Location)at Time then loc_at(Physobj1, Location)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',401).

 /*  reactive_rule([ holds(on(Physobj1,Physobj2),Time),
   		holds(loc_at(Physobj2,Location),Time)
   	      ],
   	      [holds(loc_at(Physobj1,Location),Time)]).
 */

% fluent Near(agent,object)
 %  fluent(near(agent,object)).
 %  fluent(near(agent,object)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',405).
fluents([near/2]).
mpred_prop(near(agent,object),fluent).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',407).
% event WalkFromTo(agent,object,object)
 %  event(walkFromTo(agent,object,object)).
 %  event(walkFromTo(agent,object,object)).
actions([walkFromTo/3]).
mpred_prop(walkFromTo(agent,object,object),event).

% event WalkFrom(agent,object)
 %  event(walkFrom(agent,object)).
 %  event(walkFrom(agent,object)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',407).
actions([walkFrom/2]).
mpred_prop(walkFrom(agent,object),event).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',409).
% event RunFromTo(agent,object,object)
 %  event(runFromTo(agent,object,object)).
 %  event(runFromTo(agent,object,object)).
actions([runFromTo/3]).
mpred_prop(runFromTo(agent,object,object),event).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',411).
% [agent,object1,object2,time]
% Initiates(WalkFromTo(agent,object1,object2),
%           Near(agent,object2),
%           time).

 /*  axiom(initiates(walkFromTo(Agent, Object1, Object2), near(Agent, Object2), Time),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',411).

 /*  initiates(walkFromTo(WalkfromtoP_Num3_V,_,Walkfromto),
   	  near(WalkfromtoP_Num3_V,Walkfromto),
   	  Initiates).
 */
walkFromTo(WalkfromtoP_Num3_V, _, Walkfromto)initiates near(WalkfromtoP_Num3_V, Walkfromto).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',411).

 /*  initiated(happens(walkFromTo(WalkfromtoP_Num3_V,
   			     _,
   			     Walkfromto),
   		  Time_From,
   		  Time_Until),
   	  near(WalkfromtoP_Num3_V,Walkfromto),
   	  []).
 */


% [agent,object1,object2,time]
% Terminates(WalkFromTo(agent,object1,object2),
%            Near(agent,object1),
%            time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',417).

 /*  axiom(terminates(walkFromTo(Agent, Object1, Object2), near(Agent, Object1), Time),
       []).
 */

 /*  terminates(walkFromTo(WalkfromtoP_Num3_V,
   		      Near,
   		      Walkfromto),
   	   near(WalkfromtoP_Num3_V,Near),
   	   Terminates).
 */
walkFromTo(WalkfromtoP_Num3_V, Near, Walkfromto)terminates near(WalkfromtoP_Num3_V, Near).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',417).

 /*  terminated(happens(walkFromTo(WalkfromtoP_Num3_V,
   			      Near,
   			      Walkfromto),
   		   Time_From,
   		   Time_Until),
   	   near(WalkfromtoP_Num3_V,Near),
   	   []).
 */


% [agent,object1,object2,time]
% Happens(WalkFromTo(agent,object1,object2),time) ->
% {location}% 
% HoldsAt(At(agent,location),time) &
% HoldsAt(At(object1,location),time) &
% HoldsAt(At(object2,location),time).
 %  clausify_pnf=exists([Location],  (happens(walkFromTo(Agent, Object1, Object2), Time)->holds_at(at(Agent, Location), Time), holds_at(at(Object1, Location), Time), holds_at(at(Object2, Location), Time))).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',422).

 /*  not(happens(walkFromTo(Agent, Object1, Object2), Time)) :-
       (   not(holds_at(at(Agent, Exists_Location), Time))
       ;   not(holds_at(at(Object1, Exists_Location), Time))
       ;   not(holds_at(at(Object2, Exists_Location), Time))
       ),
       some(Exists_Location,
            '$kolem_Fn_86'(Agent, Object1, Object2, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',422).

 /*  fix_axiom_head(Time) ->
       [ not(happens(walkFromTo(Agent, Object1, Object2),
                     Time)),
          (->),
         not(walkFromTo(Agent, Object1, Object2))
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',422).

 /*  axiom(not(walkFromTo(Agent, Object1, Object2)),
       [  (not(at(Agent, Exists_Location));not(at(Object1, Exists_Location));not(at(Object2, Exists_Location))),
         some(Exists_Location,
              '$kolem_Fn_86'(Agent, Object1, Object2, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',422).

 /*  (   (   not(at(Kolem_Fn_86P_Num4_V, Tloc))
       ;   not(at(A, Tloc))
       ;   not(at(Walkfromto, Tloc))
       ),
       some(Tloc,
            '$kolem_Fn_86'(Kolem_Fn_86P_Num4_V,
                           A,
                           Walkfromto,
                           Kolem_Fn_86))
   ->  not(walkFromTo(Kolem_Fn_86P_Num4_V, A, Walkfromto))
   ).
 */
if (not loc_at(Kolem_Fn_86P_Num4_V, Tloc);not loc_at(A, Tloc);not loc_at(Walkfromto, Tloc)), some(Tloc, '$kolem_Fn_86'(Kolem_Fn_86P_Num4_V, A, Walkfromto, Kolem_Fn_86))then not walkFromTo(Kolem_Fn_86P_Num4_V, A, Walkfromto).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',422).

 /*   reactive_rule([  (not(loc_at(Kolem_Fn_86P_Num4_V, Tloc));not(loc_at(A, Tloc));not(loc_at(Walkfromto, Tloc))),
                      some(Tloc,
                           '$kolem_Fn_86'(Kolem_Fn_86P_Num4_V,
                                          A,
                                          Walkfromto,
                                          Kolem_Fn_86))
                    ],
                    [ not(walkFromTo(Kolem_Fn_86P_Num4_V,
                                     A,
                                     Walkfromto))
                    ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',422).

 /*  holds_at(at(Agent, Exists_Location), Time) :-
       happens(walkFromTo(Agent, Object1, Object2), Time),
       some(Exists_Location,
            '$kolem_Fn_86'(Agent, Object1, Object2, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',422).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Agent, Exists_Location), Time),
          (->),
         at(Agent, Exists_Location)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',422).

 /*  axiom(at(Agent, Exists_Location),
       [ walkFromTo(Agent, Object1, Object2),
         some(Exists_Location,
              '$kolem_Fn_86'(Agent, Object1, Object2, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',422).

 /*  (   walkFromTo(WalkfromtoP_Num3_V, A, Walkfromto11),
       some(Tloc10,
            '$kolem_Fn_86'(WalkfromtoP_Num3_V,
                           A,
                           Walkfromto11,
                           Kolem_Fn_8613))
   ->  at(WalkfromtoP_Num3_V, Tloc10)
   ).
 */
if walkFromTo(WalkfromtoP_Num3_V, A, Walkfromto11), some(Tloc10, '$kolem_Fn_86'(WalkfromtoP_Num3_V, A, Walkfromto11, Kolem_Fn_8613))then loc_at(WalkfromtoP_Num3_V, Tloc10).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',422).

 /*  reactive_rule([ happens(walkFromTo(WalkfromtoP_Num3_V,
   				   A,
   				   Walkfromto11),
   			Time_From,
   			Time_Until),
   		some(Tloc10,
   		     '$kolem_Fn_86'(WalkfromtoP_Num3_V,
   				    A,
   				    Walkfromto11,
   				    Kolem_Fn_8613))
   	      ],
   	      [ holds(loc_at(WalkfromtoP_Num3_V,Tloc10),
   		      Holds)
   	      ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',422).

 /*  holds_at(at(Object1, Exists_Location), Time) :-
       happens(walkFromTo(Agent, Object1, Object2), Time),
       some(Exists_Location,
            '$kolem_Fn_86'(Agent, Object1, Object2, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',422).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Object1, Exists_Location), Time),
          (->),
         at(Object1, Exists_Location)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',422).

 /*  axiom(at(Object1, Exists_Location),
       [ walkFromTo(Agent, Object1, Object2),
         some(Exists_Location,
              '$kolem_Fn_86'(Agent, Object1, Object2, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',422).

 /*  (   walkFromTo(WalkfromtoP_Num3_V19, A, Walkfromto18),
       some(Tloc17,
            '$kolem_Fn_86'(WalkfromtoP_Num3_V19,
                           A,
                           Walkfromto18,
                           Kolem_Fn_8620))
   ->  at(A, Tloc17)
   ).
 */
if walkFromTo(WalkfromtoP_Num3_V19, A, Walkfromto18), some(Tloc17, '$kolem_Fn_86'(WalkfromtoP_Num3_V19, A, Walkfromto18, Kolem_Fn_8620))then loc_at(A, Tloc17).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',422).

 /*  reactive_rule([ happens(walkFromTo(WalkfromtoP_Num3_V19,
   				   A,
   				   Walkfromto18),
   			Time_From21,
   			Time_Until22),
   		some(Tloc17,
   		     '$kolem_Fn_86'(WalkfromtoP_Num3_V19,
   				    A,
   				    Walkfromto18,
   				    Kolem_Fn_8620))
   	      ],
   	      [holds(loc_at(A,Tloc17),Holds23)]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',422).

 /*  holds_at(at(Object2, Exists_Location), Time) :-
       happens(walkFromTo(Agent, Object1, Object2), Time),
       some(Exists_Location,
            '$kolem_Fn_86'(Agent, Object1, Object2, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',422).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Object2, Exists_Location), Time),
          (->),
         at(Object2, Exists_Location)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',422).

 /*  axiom(at(Object2, Exists_Location),
       [ walkFromTo(Agent, Object1, Object2),
         some(Exists_Location,
              '$kolem_Fn_86'(Agent, Object1, Object2, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',422).

 /*  (   walkFromTo(WalkfromtoP_Num3_V26, A, Walkfromto25),
       some(Tloc24,
            '$kolem_Fn_86'(WalkfromtoP_Num3_V26,
                           A,
                           Walkfromto25,
                           Kolem_Fn_8627))
   ->  at(Walkfromto25, Tloc24)
   ).
 */
if walkFromTo(WalkfromtoP_Num3_V26, A, Walkfromto25), some(Tloc24, '$kolem_Fn_86'(WalkfromtoP_Num3_V26, A, Walkfromto25, Kolem_Fn_8627))then loc_at(Walkfromto25, Tloc24).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',422).

 /*  reactive_rule([ happens(walkFromTo(WalkfromtoP_Num3_V26,
   				   A,
   				   Walkfromto25),
   			Time_From28,
   			Time_Until29),
   		some(Tloc24,
   		     '$kolem_Fn_86'(WalkfromtoP_Num3_V26,
   				    A,
   				    Walkfromto25,
   				    Kolem_Fn_8627))
   	      ],
   	      [ holds(loc_at(Walkfromto25,Tloc24),
   		      Holds30)
   	      ]).
 */


% [agent,object1,object2,time]
% Initiates(RunFromTo(agent,object1,object2),
%           Near(agent,object2),
%           time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',429).

 /*  axiom(initiates(runFromTo(Agent, Object1, Object2), near(Agent, Object2), Time),
       []).
 */

 /*  initiates(runFromTo(RunfromtoP_Num3_V,_,Runfromto),
   	  near(RunfromtoP_Num3_V,Runfromto),
   	  Initiates).
 */
runFromTo(RunfromtoP_Num3_V, _, Runfromto)initiates near(RunfromtoP_Num3_V, Runfromto).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',429).

 /*  initiated(happens(runFromTo(RunfromtoP_Num3_V,
   			    _,
   			    Runfromto),
   		  Time_From,
   		  Time_Until),
   	  near(RunfromtoP_Num3_V,Runfromto),
   	  []).
 */


% [agent,object1,object2,time]
% Terminates(RunFromTo(agent,object1,object2),
%            Near(agent,object1),
%            time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',434).

 /*  axiom(terminates(runFromTo(Agent, Object1, Object2), near(Agent, Object1), Time),
       []).
 */

 /*  terminates(runFromTo(RunfromtoP_Num3_V,
   		     Near,
   		     Runfromto),
   	   near(RunfromtoP_Num3_V,Near),
   	   Terminates).
 */
runFromTo(RunfromtoP_Num3_V, Near, Runfromto)terminates near(RunfromtoP_Num3_V, Near).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',434).

 /*  terminated(happens(runFromTo(RunfromtoP_Num3_V,
   			     Near,
   			     Runfromto),
   		   Time_From,
   		   Time_Until),
   	   near(RunfromtoP_Num3_V,Near),
   	   []).
 */


% [agent,object1,object2,time]
% Happens(RunFromTo(agent,object1,object2),time) ->
% {location}% 
% HoldsAt(At(agent,location),time) &
% HoldsAt(At(object1,location),time) &
% HoldsAt(At(object2,location),time).
 %  clausify_pnf=exists([Location],  (happens(runFromTo(Agent, Object1, Object2), Time)->holds_at(at(Agent, Location), Time), holds_at(at(Object1, Location), Time), holds_at(at(Object2, Location), Time))).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',439).

 /*  not(happens(runFromTo(Agent, Object1, Object2), Time)) :-
       (   not(holds_at(at(Agent, Exists_Location), Time))
       ;   not(holds_at(at(Object1, Exists_Location), Time))
       ;   not(holds_at(at(Object2, Exists_Location), Time))
       ),
       some(Exists_Location,
            '$kolem_Fn_87'(Agent, Object1, Object2, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',439).

 /*  fix_axiom_head(Time) ->
       [ not(happens(runFromTo(Agent, Object1, Object2),
                     Time)),
          (->),
         not(runFromTo(Agent, Object1, Object2))
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',439).

 /*  axiom(not(runFromTo(Agent, Object1, Object2)),
       [  (not(at(Agent, Exists_Location));not(at(Object1, Exists_Location));not(at(Object2, Exists_Location))),
         some(Exists_Location,
              '$kolem_Fn_87'(Agent, Object1, Object2, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',439).

 /*  (   (   not(at(Kolem_Fn_87P_Num4_V, Tloc))
       ;   not(at(A, Tloc))
       ;   not(at(Runfromto, Tloc))
       ),
       some(Tloc,
            '$kolem_Fn_87'(Kolem_Fn_87P_Num4_V,
                           A,
                           Runfromto,
                           Kolem_Fn_87))
   ->  not(runFromTo(Kolem_Fn_87P_Num4_V, A, Runfromto))
   ).
 */
if (not loc_at(Kolem_Fn_87P_Num4_V, Tloc);not loc_at(A, Tloc);not loc_at(Runfromto, Tloc)), some(Tloc, '$kolem_Fn_87'(Kolem_Fn_87P_Num4_V, A, Runfromto, Kolem_Fn_87))then not runFromTo(Kolem_Fn_87P_Num4_V, A, Runfromto).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',439).

 /*   reactive_rule([  (not(loc_at(Kolem_Fn_87P_Num4_V, Tloc));not(loc_at(A, Tloc));not(loc_at(Runfromto, Tloc))),
                      some(Tloc,
                           '$kolem_Fn_87'(Kolem_Fn_87P_Num4_V,
                                          A,
                                          Runfromto,
                                          Kolem_Fn_87))
                    ],
                    [ not(runFromTo(Kolem_Fn_87P_Num4_V,
                                    A,
                                    Runfromto))
                    ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',439).

 /*  holds_at(at(Agent, Exists_Location), Time) :-
       happens(runFromTo(Agent, Object1, Object2), Time),
       some(Exists_Location,
            '$kolem_Fn_87'(Agent, Object1, Object2, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',439).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Agent, Exists_Location), Time),
          (->),
         at(Agent, Exists_Location)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',439).

 /*  axiom(at(Agent, Exists_Location),
       [ runFromTo(Agent, Object1, Object2),
         some(Exists_Location,
              '$kolem_Fn_87'(Agent, Object1, Object2, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',439).

 /*  (   runFromTo(RunfromtoP_Num3_V, A, Runfromto11),
       some(Tloc10,
            '$kolem_Fn_87'(RunfromtoP_Num3_V,
                           A,
                           Runfromto11,
                           Kolem_Fn_8713))
   ->  at(RunfromtoP_Num3_V, Tloc10)
   ).
 */
if runFromTo(RunfromtoP_Num3_V, A, Runfromto11), some(Tloc10, '$kolem_Fn_87'(RunfromtoP_Num3_V, A, Runfromto11, Kolem_Fn_8713))then loc_at(RunfromtoP_Num3_V, Tloc10).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',439).

 /*  reactive_rule([ happens(runFromTo(RunfromtoP_Num3_V,
   				  A,
   				  Runfromto11),
   			Time_From,
   			Time_Until),
   		some(Tloc10,
   		     '$kolem_Fn_87'(RunfromtoP_Num3_V,
   				    A,
   				    Runfromto11,
   				    Kolem_Fn_8713))
   	      ],
   	      [ holds(loc_at(RunfromtoP_Num3_V,Tloc10),
   		      Holds)
   	      ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',439).

 /*  holds_at(at(Object1, Exists_Location), Time) :-
       happens(runFromTo(Agent, Object1, Object2), Time),
       some(Exists_Location,
            '$kolem_Fn_87'(Agent, Object1, Object2, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',439).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Object1, Exists_Location), Time),
          (->),
         at(Object1, Exists_Location)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',439).

 /*  axiom(at(Object1, Exists_Location),
       [ runFromTo(Agent, Object1, Object2),
         some(Exists_Location,
              '$kolem_Fn_87'(Agent, Object1, Object2, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',439).

 /*  (   runFromTo(RunfromtoP_Num3_V19, A, Runfromto18),
       some(Tloc17,
            '$kolem_Fn_87'(RunfromtoP_Num3_V19,
                           A,
                           Runfromto18,
                           Kolem_Fn_8720))
   ->  at(A, Tloc17)
   ).
 */
if runFromTo(RunfromtoP_Num3_V19, A, Runfromto18), some(Tloc17, '$kolem_Fn_87'(RunfromtoP_Num3_V19, A, Runfromto18, Kolem_Fn_8720))then loc_at(A, Tloc17).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',439).

 /*  reactive_rule([ happens(runFromTo(RunfromtoP_Num3_V19,
   				  A,
   				  Runfromto18),
   			Time_From21,
   			Time_Until22),
   		some(Tloc17,
   		     '$kolem_Fn_87'(RunfromtoP_Num3_V19,
   				    A,
   				    Runfromto18,
   				    Kolem_Fn_8720))
   	      ],
   	      [holds(loc_at(A,Tloc17),Holds23)]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',439).

 /*  holds_at(at(Object2, Exists_Location), Time) :-
       happens(runFromTo(Agent, Object1, Object2), Time),
       some(Exists_Location,
            '$kolem_Fn_87'(Agent, Object1, Object2, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',439).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Object2, Exists_Location), Time),
          (->),
         at(Object2, Exists_Location)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',439).

 /*  axiom(at(Object2, Exists_Location),
       [ runFromTo(Agent, Object1, Object2),
         some(Exists_Location,
              '$kolem_Fn_87'(Agent, Object1, Object2, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',439).

 /*  (   runFromTo(RunfromtoP_Num3_V26, A, Runfromto25),
       some(Tloc24,
            '$kolem_Fn_87'(RunfromtoP_Num3_V26,
                           A,
                           Runfromto25,
                           Kolem_Fn_8727))
   ->  at(Runfromto25, Tloc24)
   ).
 */
if runFromTo(RunfromtoP_Num3_V26, A, Runfromto25), some(Tloc24, '$kolem_Fn_87'(RunfromtoP_Num3_V26, A, Runfromto25, Kolem_Fn_8727))then loc_at(Runfromto25, Tloc24).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',439).

 /*  reactive_rule([ happens(runFromTo(RunfromtoP_Num3_V26,
   				  A,
   				  Runfromto25),
   			Time_From28,
   			Time_Until29),
   		some(Tloc24,
   		     '$kolem_Fn_87'(RunfromtoP_Num3_V26,
   				    A,
   				    Runfromto25,
   				    Kolem_Fn_8727))
   	      ],
   	      [ holds(loc_at(Runfromto25,Tloc24),
   		      Holds30)
   	      ]).
 */


% [agent,object,time]
% Terminates(WalkFrom(agent,object),
%            Near(agent,object),
%            time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',446).

 /*  axiom(terminates(walkFrom(Agent, Object), near(Agent, Object), Time),
       []).
 */

 /*  terminates(walkFrom(A,Walkfrom),
   	   near(A,Walkfrom),
   	   Terminates).
 */
walkFrom(A, Walkfrom)terminates near(A, Walkfrom).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',446).

 /*  terminated(happens(walkFrom(A,Walkfrom),
   		   Time_From,
   		   Time_Until),
   	   near(A,Walkfrom),
   	   []).
 */


% [agent,object,location,door,time]
% HoldsAt(Near(agent,object),time) &
% HoldsAt(At(agent,location),time) &
% HoldsAt(At(object,location),time) &
% Side1(door)=location &
% Happens(WalkThroughDoor12(agent,door),time) ->
% Happens(WalkFrom(agent,object),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',451).

 /*  (   holds_at(near(Agent, Object), Time),
       holds_at(at(Agent, Location), Time),
       holds_at(at(Object, Location), Time),
       side1Pred(Door, Location),
       happens(walkThroughDoor12(Agent, Door), Time)
   ->  happens(walkFrom(Agent, Object), Time)
   ).
 */
if near(Agent, Object)at Time, loc_at(Agent, Location)at Time, loc_at(Object, Location)at Time, side1Pred(Door, Location), happens(walkThroughDoor12(Agent, Door), Time)then happens(walkFrom(Agent, Object), Time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',451).

 /*  reactive_rule([ holds(near(Agent,Object),Time),
   		holds(loc_at(Agent,Location),Time),
   		holds(loc_at(Object,Location),Time),
   		side1Pred(Door,Location),
   		happens(walkThroughDoor12(Agent,Door),
   			Time)
   	      ],
   	      [happens(walkFrom(Agent,Object),Time)]).
 */


% [agent,object,location,door,time]
% HoldsAt(Near(agent,object),time) &
% HoldsAt(At(agent,location),time) &
% HoldsAt(At(object,location),time) &
% Side2(door)=location &
% Happens(WalkThroughDoor21(agent,door),time) ->
% Happens(WalkFrom(agent,object),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',459).

 /*  (   holds_at(near(Agent, Object), Time),
       holds_at(at(Agent, Location), Time),
       holds_at(at(Object, Location), Time),
       side2Pred(Door, Location),
       happens(walkThroughDoor21(Agent, Door), Time)
   ->  happens(walkFrom(Agent, Object), Time)
   ).
 */
if near(Agent, Object)at Time, loc_at(Agent, Location)at Time, loc_at(Object, Location)at Time, side2Pred(Door, Location), happens(walkThroughDoor21(Agent, Door), Time)then happens(walkFrom(Agent, Object), Time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',459).

 /*  reactive_rule([ holds(near(Agent,Object),Time),
   		holds(loc_at(Agent,Location),Time),
   		holds(loc_at(Object,Location),Time),
   		side2Pred(Door,Location),
   		happens(walkThroughDoor21(Agent,Door),
   			Time)
   	      ],
   	      [happens(walkFrom(Agent,Object),Time)]).
 */


% [agent,object,room,staircase,time]
% HoldsAt(Near(agent,object),time) &
% HoldsAt(At(agent,room),time) &
% HoldsAt(At(object,room),time) &
% Side1(staircase)=room &
% Happens(WalkUpStaircase(agent,staircase),time) ->
% Happens(WalkFrom(agent,object),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',467).

 /*  (   holds_at(near(Agent, Object), Time),
       holds_at(at(Agent, Room), Time),
       holds_at(at(Object, Room), Time),
       side1Pred(Staircase, Room),
       happens(walkUpStaircase(Agent, Staircase), Time)
   ->  happens(walkFrom(Agent, Object), Time)
   ).
 */
if near(Agent, Object)at Time, loc_at(Agent, Room)at Time, loc_at(Object, Room)at Time, side1Pred(Staircase, Room), happens(walkUpStaircase(Agent, Staircase), Time)then happens(walkFrom(Agent, Object), Time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',467).

 /*  reactive_rule([ holds(near(Agent,Object),Time),
   		holds(loc_at(Agent,Room),Time),
   		holds(loc_at(Object,Room),Time),
   		side1Pred(Staircase,Room),
   		happens(walkUpStaircase(Agent,Staircase),
   			Time)
   	      ],
   	      [happens(walkFrom(Agent,Object),Time)]).
 */


% [agent,object,room,staircase,time]
% HoldsAt(Near(agent,object),time) &
% HoldsAt(At(agent,room),time) &
% HoldsAt(At(object,room),time) &
% Side2(staircase)=room &
% Happens(WalkDownStaircase(agent,staircase),time) ->
% Happens(WalkFrom(agent,object),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',475).

 /*  (   holds_at(near(Agent, Object), Time),
       holds_at(at(Agent, Room), Time),
       holds_at(at(Object, Room), Time),
       side2Pred(Staircase, Room),
       happens(walkDownStaircase(Agent, Staircase), Time)
   ->  happens(walkFrom(Agent, Object), Time)
   ).
 */
if near(Agent, Object)at Time, loc_at(Agent, Room)at Time, loc_at(Object, Room)at Time, side2Pred(Staircase, Room), happens(walkDownStaircase(Agent, Staircase), Time)then happens(walkFrom(Agent, Object), Time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',475).

 /*  reactive_rule([ holds(near(Agent,Object),Time),
   		holds(loc_at(Agent,Room),Time),
   		holds(loc_at(Object,Room),Time),
   		side2Pred(Staircase,Room),
   		happens(walkDownStaircase(Agent,Staircase),
   			Time)
   	      ],
   	      [happens(walkFrom(Agent,Object),Time)]).
 */


%; End of file.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/OTSpace.e',481).
:- endif.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',46).
% load answers/Mueller2004c/HungerNeed.e
:- if(is_e_toplevel).
:- cond_convert_e(changed, 'answers/Mueller2004c/HungerNeed.e').
 %  loading(changed,'/pack/logicmoo_ec/ext/ec_sources/ecnet/HungerNeed.e').
%;
%; Copyright (c) 2005 IBM Corporation and others.
%; All rights reserved. This program and the accompanying materials
%; are made available under the terms of the Common Public License v1.0
%; which accompanies this distribution, and is available at
%; http://www.eclipse.org/legal/cpl-v10.html
%;
%; Contributors:
%; IBM - Initial implementation
%;
%; hunger need
%;

% fluent Hungry(agent)
 %  fluent(hungry(agent)).
 %  fluent(hungry(agent)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/HungerNeed.e',14).
fluents([hungry/1]).
mpred_prop(hungry(agent),fluent).

% fluent Satiated(agent)
 %  fluent(satiated(agent)).
 %  fluent(satiated(agent)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/HungerNeed.e',16).
fluents([satiated/1]).
mpred_prop(satiated(agent),fluent).

% noninertial Satiated
noninertial(satiated).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/HungerNeed.e',19).
% [agent,time]
 % HoldsAt(Hungry(agent),time) <-> !HoldsAt(Satiated(agent),time).

 /*  holds_at(hungry(Agent), Time) <->
       holds_at(neg(satiated(Agent)), Time).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/HungerNeed.e',19).

 /*  holds_at(hungry(Agent), Time) ->
       holds_at(neg(satiated(Agent)), Time).
 */
if hungry(Agent)at Time then not satiated(Agent)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/HungerNeed.e',19).

 /*  reactive_rule([holds(hungry(Agent),Time)],
   	      [holds(not(satiated(Agent)),Time)]).
 */

 /*  holds_at(neg(satiated(Agent)), Time) ->
       holds_at(hungry(Agent), Time).
 */
if not satiated(Agent)at Time then hungry(Agent)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/HungerNeed.e',19).

 /*  reactive_rule([holds(not(satiated(Agent)),Time)],
   	      [holds(hungry(Agent),Time)]).
 */

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/HungerNeed.e',21).
% event Eat(agent,food)
 %  event(eat(agent,food)).
 %  event(eat(agent,food)).
actions([eat/2]).
mpred_prop(eat(agent,food),event).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/HungerNeed.e',23).
% [agent,food,time]
% Happens(Eat(agent,food),time) ->
% {location}% 
% HoldsAt(At(agent,location),time) &
% HoldsAt(At(food,location),time).
 %  clausify_pnf=exists([Location],  (happens(eat(Agent, Food), Time)->holds_at(at(Agent, Location), Time), holds_at(at(Food, Location), Time))).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/HungerNeed.e',25).

 /*  not(happens(eat(Agent, Food), Time)) :-
       (   not(holds_at(at(Agent, Exists_Location), Time))
       ;   not(holds_at(at(Food, Exists_Location), Time))
       ),
       some(Exists_Location,
            '$kolem_Fn_88'(Agent, Food, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/HungerNeed.e',25).

 /*  fix_axiom_head(Time) ->
       [ not(happens(eat(Agent, Food), Time)),
          (->),
         not(eat(Agent, Food))
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/HungerNeed.e',25).

 /*  axiom(not(eat(Agent, Food)),
       [  (not(at(Agent, Exists_Location));not(at(Food, Exists_Location))),
         some(Exists_Location,
              '$kolem_Fn_88'(Agent, Food, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/HungerNeed.e',25).

 /*  (   (   not(at(Kolem_Fn_88P_Num3_V, Tloc))
       ;   not(at(Eat, Tloc))
       ),
       some(Tloc,
            '$kolem_Fn_88'(Kolem_Fn_88P_Num3_V, Eat, Kolem_Fn_88))
   ->  not(eat(Kolem_Fn_88P_Num3_V, Eat))
   ).
 */
if (not loc_at(Kolem_Fn_88P_Num3_V, Tloc);not loc_at(Eat, Tloc)), some(Tloc, '$kolem_Fn_88'(Kolem_Fn_88P_Num3_V, Eat, Kolem_Fn_88))then not eat(Kolem_Fn_88P_Num3_V, Eat).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/HungerNeed.e',25).

 /*   reactive_rule([  (not(loc_at(Kolem_Fn_88P_Num3_V, Tloc));not(loc_at(Eat, Tloc))),
                      some(Tloc,
                           '$kolem_Fn_88'(Kolem_Fn_88P_Num3_V,
                                          Eat,
                                          Kolem_Fn_88))
                    ],
                    [not(eat(Kolem_Fn_88P_Num3_V, Eat))]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/HungerNeed.e',25).

 /*  holds_at(at(Agent, Exists_Location), Time) :-
       happens(eat(Agent, Food), Time),
       some(Exists_Location,
            '$kolem_Fn_88'(Agent, Food, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/HungerNeed.e',25).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Agent, Exists_Location), Time),
          (->),
         at(Agent, Exists_Location)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/HungerNeed.e',25).

 /*  axiom(at(Agent, Exists_Location),
       [ eat(Agent, Food),
         some(Exists_Location,
              '$kolem_Fn_88'(Agent, Food, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/HungerNeed.e',25).

 /*  (   eat(Kolem_Fn_88P_Num3_V12, Eat10),
       some(Tloc9,
            '$kolem_Fn_88'(Kolem_Fn_88P_Num3_V12,
                           Eat10,
                           Kolem_Fn_8811))
   ->  at(Kolem_Fn_88P_Num3_V12, Tloc9)
   ).
 */
if eat(Kolem_Fn_88P_Num3_V12, Eat10), some(Tloc9, '$kolem_Fn_88'(Kolem_Fn_88P_Num3_V12, Eat10, Kolem_Fn_8811))then loc_at(Kolem_Fn_88P_Num3_V12, Tloc9).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/HungerNeed.e',25).

 /*  reactive_rule([ happens(eat(Kolem_Fn_88P_Num3_V12,Eat10),
   			Time_From,
   			Time_Until),
   		some(Tloc9,
   		     '$kolem_Fn_88'(Kolem_Fn_88P_Num3_V12,
   				    Eat10,
   				    Kolem_Fn_8811))
   	      ],
   	      [ holds(loc_at(Kolem_Fn_88P_Num3_V12,Tloc9),
   		      Holds)
   	      ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/HungerNeed.e',25).

 /*  holds_at(at(Food, Exists_Location), Time) :-
       happens(eat(Agent, Food), Time),
       some(Exists_Location,
            '$kolem_Fn_88'(Agent, Food, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/HungerNeed.e',25).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Food, Exists_Location), Time),
          (->),
         at(Food, Exists_Location)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/HungerNeed.e',25).

 /*  axiom(at(Food, Exists_Location),
       [ eat(Agent, Food),
         some(Exists_Location,
              '$kolem_Fn_88'(Agent, Food, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/HungerNeed.e',25).

 /*  (   eat(Kolem_Fn_88P_Num3_V19, Eat17),
       some(Tloc16,
            '$kolem_Fn_88'(Kolem_Fn_88P_Num3_V19,
                           Eat17,
                           Kolem_Fn_8818))
   ->  at(Eat17, Tloc16)
   ).
 */
if eat(Kolem_Fn_88P_Num3_V19, Eat17), some(Tloc16, '$kolem_Fn_88'(Kolem_Fn_88P_Num3_V19, Eat17, Kolem_Fn_8818))then loc_at(Eat17, Tloc16).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/HungerNeed.e',25).

 /*  reactive_rule([ happens(eat(Kolem_Fn_88P_Num3_V19,Eat17),
   			Time_From20,
   			Time_Until21),
   		some(Tloc16,
   		     '$kolem_Fn_88'(Kolem_Fn_88P_Num3_V19,
   				    Eat17,
   				    Kolem_Fn_8818))
   	      ],
   	      [holds(loc_at(Eat17,Tloc16),Holds22)]).
 */


% [agent,food,time]
% Terminates(Eat(agent,food),Hungry(agent),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/HungerNeed.e',30).

 /*  axiom(terminates(eat(Agent, Food), hungry(Agent), Time),
       []).
 */

 /*  terminates(eat(Hungry,Eat),
   	   hungry(Hungry),
   	   Terminates).
 */
eat(Hungry, Eat)terminates hungry(Hungry).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/HungerNeed.e',30).

 /*  terminated(happens(eat(Hungry,Eat),
   		   Time_From,
   		   Time_Until),
   	   hungry(Hungry),
   	   []).
 */


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/HungerNeed.e',32).
%; End of file.
:- endif.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',47).
% load answers/Mueller2004c/Restaurant.e
:- if(is_e_toplevel).
:- cond_convert_e(changed, 'answers/Mueller2004c/Restaurant.e').
 %  loading(changed,'/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e').
%;
%; Copyright (c) 2005 IBM Corporation and others.
%; All rights reserved. This program and the accompanying materials
%; are made available under the terms of the Common Public License v1.0
%; which accompanies this distribution, and is available at
%; http://www.eclipse.org/legal/cpl-v10.html
%;
%; Contributors:
%; IBM - Initial implementation
%;

% sort restaurant: script
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',11).
subsort(restaurant,script).

% sort waiter: agent
subsort(waiter,agent).

% sort cook: agent
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',13).
subsort(cook,agent).

% function BillOf(restaurant): bill
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',15).

 /*  axiom(function_argtypes(Function_ArgtypesP_Num3_V, billOf(restaurant), bill),
       []).
 */
function_argtypes(Function_ArgtypesP_Num3_V1,
		  billOf(restaurant),
		  bill).
 %  predicate(bill(restaurant,bill)).
 %  predicate(bill(restaurant,bill)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',15).
predicates([bill/2]).
mpred_prop(bill(restaurant,bill),predicate).

 /*  axiom(functional_predicate(billOf, bill),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',15).
functional_predicate(billOf,bill).
resultIsa(billOf,bill).

% function CookOf(restaurant): cook

 /*  axiom(function_argtypes(Function_ArgtypesP_Num3_V, cookOf(restaurant), cook),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',15).
function_argtypes(Function_ArgtypesP_Num3_V1,
		  cookOf(restaurant),
		  cook).
 %  predicate(cook(restaurant,cook)).
 %  predicate(cook(restaurant,cook)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',15).
predicates([cook/2]).
mpred_prop(cook(restaurant,cook),predicate).

 /*  axiom(functional_predicate(cookOf, cook),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',15).
functional_predicate(cookOf,cook).
resultIsa(cookOf,cook).

% function TableOf(restaurant): table
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',17).

 /*  axiom(function_argtypes(Function_ArgtypesP_Num3_V, tableOf(restaurant), table),
       []).
 */
function_argtypes(Function_ArgtypesP_Num3_V1,
		  tableOf(restaurant),
		  table).
 %  predicate(table(restaurant,table)).
 %  predicate(table(restaurant,table)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',17).
predicates([(table)/2]).
mpred_prop(table(restaurant,table),predicate).

 /*  axiom(functional_predicate(tableOf, table),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',17).
functional_predicate(tableOf,table).
resultIsa(tableOf,table).

% function WaiterOf(restaurant): waiter

 /*  axiom(function_argtypes(Function_ArgtypesP_Num3_V, waiterOf(restaurant), waiter),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',17).
function_argtypes(Function_ArgtypesP_Num3_V1,
		  waiterOf(restaurant),
		  waiter).
 %  predicate(waiter(restaurant,waiter)).
 %  predicate(waiter(restaurant,waiter)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',17).
predicates([waiter/2]).
mpred_prop(waiter(restaurant,waiter),predicate).

 /*  axiom(functional_predicate(waiterOf, waiter),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',17).
functional_predicate(waiterOf,waiter).
resultIsa(waiterOf,waiter).

% function KitchenDoorOf(restaurant): door
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',19).

 /*  axiom(function_argtypes(Function_ArgtypesP_Num3_V, kitchenDoorOf(restaurant), door),
       []).
 */
function_argtypes(Function_ArgtypesP_Num3_V1,
		  kitchenDoorOf(restaurant),
		  door).
 %  predicate(kitchenDoor(restaurant,door)).
 %  predicate(kitchenDoor(restaurant,door)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',19).
predicates([kitchenDoor/2]).
mpred_prop(kitchenDoor(restaurant,door),predicate).

 /*  axiom(functional_predicate(kitchenDoorOf, kitchenDoor),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',19).
functional_predicate(kitchenDoorOf,kitchenDoor).
resultIsa(kitchenDoorOf,door).
%; awaiting customer/waiter has set down bill on customer's table

% fluent BeWaiter0(waiter)
 %  fluent(beWaiter0(waiter)).
 %  fluent(beWaiter0(waiter)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',21).
fluents([beWaiter0/1]).
mpred_prop(beWaiter0(waiter),fluent).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',24).
%; awaiting customer order

% fluent BeWaiter1(waiter)
 %  fluent(beWaiter1(waiter)).
 %  fluent(beWaiter1(waiter)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',24).
fluents([beWaiter1/1]).
mpred_prop(beWaiter1(waiter),fluent).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',27).
%; has customer order

% fluent BeWaiter2(waiter)
 %  fluent(beWaiter2(waiter)).
 %  fluent(beWaiter2(waiter)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',27).
fluents([beWaiter2/1]).
mpred_prop(beWaiter2(waiter),fluent).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',30).
%; in kitchen

% fluent BeWaiter3(waiter)
 %  fluent(beWaiter3(waiter)).
 %  fluent(beWaiter3(waiter)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',30).
fluents([beWaiter3/1]).
mpred_prop(beWaiter3(waiter),fluent).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',33).
%; awaiting preparation of order

% fluent BeWaiter4(waiter)
 %  fluent(beWaiter4(waiter)).
 %  fluent(beWaiter4(waiter)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',33).
fluents([beWaiter4/1]).
mpred_prop(beWaiter4(waiter),fluent).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',36).
%; has order

% fluent BeWaiter5(waiter)
 %  fluent(beWaiter5(waiter)).
 %  fluent(beWaiter5(waiter)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',36).
fluents([beWaiter5/1]).
mpred_prop(beWaiter5(waiter),fluent).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',39).
%; back in dining room

% fluent BeWaiter6(waiter)
 %  fluent(beWaiter6(waiter)).
 %  fluent(beWaiter6(waiter)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',39).
fluents([beWaiter6/1]).
mpred_prop(beWaiter6(waiter),fluent).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',42).
%; order delivered to customer (can ask if all is OK)

% fluent BeWaiter7(waiter)
 %  fluent(beWaiter7(waiter)).
 %  fluent(beWaiter7(waiter)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',42).
fluents([beWaiter7/1]).
mpred_prop(beWaiter7(waiter),fluent).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',45).
%; customer has requested bill

% fluent BeWaiter8(waiter)
 %  fluent(beWaiter8(waiter)).
 %  fluent(beWaiter8(waiter)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',45).
fluents([beWaiter8/1]).
mpred_prop(beWaiter8(waiter),fluent).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',48).
%; waiter is holding bill

% fluent BeWaiter9(waiter)
 %  fluent(beWaiter9(waiter)).
 %  fluent(beWaiter9(waiter)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',48).
fluents([beWaiter9/1]).
mpred_prop(beWaiter9(waiter),fluent).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',51).
% xor BeWaiter0, BeWaiter1, BeWaiter2, BeWaiter3, BeWaiter4, BeWaiter5, BeWaiter6, BeWaiter7, BeWaiter8, BeWaiter9

 /*  ==>xor[ beWaiter0,
     beWaiter1,
     beWaiter2,
     beWaiter3,
     beWaiter4,
     beWaiter5,
     beWaiter6,
     beWaiter7,
     beWaiter8,
     beWaiter9
   ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',51).
==>xor[ beWaiter0,
  beWaiter1,
  beWaiter2,
  beWaiter3,
  beWaiter4,
  beWaiter5,
  beWaiter6,
  beWaiter7,
  beWaiter8,
  beWaiter9
].


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',53).
% [waiter,agent,time]
% HoldsAt(BeWaiter0(waiter),time) ->
% Terminates(Greet(waiter,agent),
%            BeWaiter0(waiter),
%            time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',53).

 /*  axiom(terminates(greet(Waiter, Agent), beWaiter0(Waiter), Time),
       [beWaiter0(Waiter)]).
 */

 /*  beWaiter0(Bewaiter0) ->
       terminates(greet(Bewaiter0, Greet),
                  beWaiter0(Bewaiter0),
                  Terminates).
 */
if beWaiter0(Bewaiter0)then terminates(greet(Bewaiter0, Greet), beWaiter0(Bewaiter0)at Terminates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',53).

 /*  reactive_rule([beWaiter0(Bewaiter0)],
   	      [ terminates(greet(Bewaiter0,Greet),
   			   at(beWaiter0(Bewaiter0),
   			      Terminates),
   			   Terminates6)
   	      ]).
 */


% [waiter,agent,time]
% HoldsAt(BeWaiter0(waiter),time) ->
% Initiates(Greet(waiter,agent),
%           BeWaiter1(waiter),
%           time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',60).

 /*  axiom(initiates(greet(Waiter, Agent), beWaiter1(Waiter), Time),
       [beWaiter0(Waiter)]).
 */

 /*  beWaiter0(Bewaiter0) ->
       initiates(greet(Bewaiter0, Greet),
                 beWaiter1(Bewaiter0),
                 Initiates).
 */
if beWaiter0(Bewaiter0)then initiates(greet(Bewaiter0, Greet), beWaiter1(Bewaiter0)at Initiates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',60).

 /*  reactive_rule([beWaiter0(Bewaiter0)],
   	      [ initiates(greet(Bewaiter0,Greet),
   			  at(beWaiter1(Bewaiter0),
   			     Initiates),
   			  Initiates6)
   	      ]).
 */


% [waiter,agent,food,time]
% HoldsAt(BeWaiter1(waiter),time) ->
% Terminates(Order(agent,waiter,food),
%            BeWaiter1(waiter),
%            time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',66).

 /*  axiom(terminates(order(Agent, Waiter, Food), beWaiter1(Waiter), Time),
       [beWaiter1(Waiter)]).
 */

 /*  beWaiter1(Bewaiter1) ->
       terminates(order(OrderP_Num3_V, Bewaiter1, Order),
                  beWaiter1(Bewaiter1),
                  Terminates).
 */
if beWaiter1(Bewaiter1)then terminates(order(OrderP_Num3_V, Bewaiter1, Order), beWaiter1(Bewaiter1)at Terminates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',66).

 /*  reactive_rule([beWaiter1(Bewaiter1)],
   	      [ terminates(order(OrderP_Num3_V,
   				 Bewaiter1,
   				 Order),
   			   at(beWaiter1(Bewaiter1),
   			      Terminates),
   			   Terminates8)
   	      ]).
 */


% [waiter,agent,food,time]
% HoldsAt(BeWaiter1(waiter),time) ->
% Initiates(Order(agent,waiter,food),
%           BeWaiter2(waiter),
%           time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',72).

 /*  axiom(initiates(order(Agent, Waiter, Food), beWaiter2(Waiter), Time),
       [beWaiter1(Waiter)]).
 */

 /*  beWaiter1(Bewaiter1) ->
       initiates(order(OrderP_Num3_V, Bewaiter1, Order),
                 beWaiter2(Bewaiter1),
                 Initiates).
 */
if beWaiter1(Bewaiter1)then initiates(order(OrderP_Num3_V, Bewaiter1, Order), beWaiter2(Bewaiter1)at Initiates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',72).

 /*  reactive_rule([beWaiter1(Bewaiter1)],
   	      [ initiates(order(OrderP_Num3_V,
   				Bewaiter1,
   				Order),
   			  at(beWaiter2(Bewaiter1),
   			     Initiates),
   			  Initiates8)
   	      ]).
 */


% [restaurant,waiter,time]
% WaiterOf(restaurant)=waiter &
% HoldsAt(BeWaiter2(waiter),time) ->
% Happens(WalkThroughDoor12(waiter,KitchenDoorOf(restaurant)),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',78).

 /*  (   waiter(Restaurant, Waiter),
       holds_at(beWaiter2(Waiter), Time)
   ->  happens(walkThroughDoor12(Waiter, kitchenDoorOf(Restaurant)),
               Time)
   ).
 */
if waiter(Restaurant, Waiter), beWaiter2(Waiter)at Time then happens(walkThroughDoor12(Waiter, kitchenDoorOf(Restaurant)), Time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',78).

 /*  reactive_rule([ waiter(Restaurant,Waiter),
   		holds(beWaiter2(Waiter),Time)
   	      ],
   	      [ happens(walkThroughDoor12(Waiter,
   					  kitchenDoorOf(Restaurant)),
   			Time)
   	      ]).
 */


% [restaurant,waiter,door,time]
% HoldsAt(BeWaiter2(waiter),time) &
% WaiterOf(restaurant)=waiter &
% KitchenDoorOf(restaurant)=door ->
% Terminates(WalkThroughDoor12(waiter,door),
%            BeWaiter2(waiter),
%            time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',83).

 /*  axiom(terminates(walkThroughDoor12(Waiter, Door), beWaiter2(Waiter), Time),
       [ beWaiter2(Waiter),
         waiter(Restaurant, Waiter),
         kitchenDoor(Restaurant, Door)
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',83).

 /*  (   beWaiter2(Bewaiter2),
       waiter(A, Bewaiter2),
       kitchenDoor(A, Kitchendoor)
   ->  terminates(walkThroughDoor12(Bewaiter2, Kitchendoor),
                  beWaiter2(Bewaiter2),
                  Terminates)
   ).
 */
if beWaiter2(Bewaiter2), waiter(A, Bewaiter2), kitchenDoor(A, Kitchendoor)then terminates(walkThroughDoor12(Bewaiter2, Kitchendoor), beWaiter2(Bewaiter2)at Terminates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',83).

 /*  reactive_rule([ holds(beWaiter2(Bewaiter2),Holds),
   		waiter(A,Bewaiter2),
   		kitchenDoor(A,Kitchendoor)
   	      ],
   	      [ terminates(walkThroughDoor12(Bewaiter2,
   					     Kitchendoor),
   			   at(beWaiter2(Bewaiter2),
   			      Terminates),
   			   Terminates8)
   	      ]).
 */


% [restaurant,waiter,door,time]
% HoldsAt(BeWaiter2(waiter),time) &
% WaiterOf(restaurant)=waiter &
% KitchenDoorOf(restaurant)=door ->
% Initiates(WalkThroughDoor12(waiter,door),
%           BeWaiter3(waiter),
%           time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',91).

 /*  axiom(initiates(walkThroughDoor12(Waiter, Door), beWaiter3(Waiter), Time),
       [ beWaiter2(Waiter),
         waiter(Restaurant, Waiter),
         kitchenDoor(Restaurant, Door)
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',91).

 /*  (   beWaiter2(Bewaiter2),
       waiter(A, Bewaiter2),
       kitchenDoor(A, Kitchendoor)
   ->  initiates(walkThroughDoor12(Bewaiter2, Kitchendoor),
                 beWaiter3(Bewaiter2),
                 Initiates)
   ).
 */
if beWaiter2(Bewaiter2), waiter(A, Bewaiter2), kitchenDoor(A, Kitchendoor)then initiates(walkThroughDoor12(Bewaiter2, Kitchendoor), beWaiter3(Bewaiter2)at Initiates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',91).

 /*  reactive_rule([ holds(beWaiter2(Bewaiter2),Holds),
   		waiter(A,Bewaiter2),
   		kitchenDoor(A,Kitchendoor)
   	      ],
   	      [ initiates(walkThroughDoor12(Bewaiter2,
   					    Kitchendoor),
   			  at(beWaiter3(Bewaiter2),
   			     Initiates),
   			  Initiates8)
   	      ]).
 */


% [restaurant,food,time]
% HoldsAt(BeWaiter3(WaiterOf(restaurant)),time) &
% ({agent} HoldsAt(KnowOrder(WaiterOf(restaurant),agent,food),time)) ->
% Happens(Order(WaiterOf(restaurant),CookOf(restaurant),food),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',99).

 /*  (   holds_at(beWaiter3(waiterOf(Restaurant)), Time),
       exists([Agent],
              holds_at(knowOrder(waiterOf(Restaurant),
                                 Agent,
                                 Food),
                       Time))
   ->  happens(order(waiterOf(Restaurant),
                     cookOf(Restaurant),
                     Food),
               Time)
   ).
 */
if beWaiter3(waiterOf(Restaurant))at Time, exists([Agent], knowOrder(waiterOf(Restaurant), Agent, Food)at Time)then happens(order(waiterOf(Restaurant), cookOf(Restaurant), Food), Time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',99).

 /*  reactive_rule([ holds(beWaiter3(waiterOf(Restaurant)),Time),
   		exists([Agent],
   		       at(knowOrder(waiterOf(Restaurant),
   				    Agent,
   				    Food),
   			  Time))
   	      ],
   	      [ happens(order(waiterOf(Restaurant),
   			      cookOf(Restaurant),
   			      Food),
   			Time)
   	      ]).
 */


% [restaurant,waiter,cook,food,time]
% WaiterOf(restaurant)=waiter &
% CookOf(restaurant)=cook &
% HoldsAt(BeWaiter3(waiter),time) ->
% Terminates(Order(waiter,cook,food),
%            BeWaiter3(waiter),
%            time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',104).

 /*  axiom(terminates(order(Waiter, Cook, Food), beWaiter3(Waiter), Time),
       [ waiter(Restaurant, Waiter),
         cook(Restaurant, Cook),
         beWaiter3(Waiter)
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',104).

 /*  (   waiter(A, Waiter5),
       cook(A, Cook6),
       beWaiter3(Waiter5)
   ->  terminates(order(Waiter5, Cook6, Order),
                  beWaiter3(Waiter5),
                  Terminates)
   ).
 */
if waiter(A, Waiter5), cook(A, Cook6), beWaiter3(Waiter5)then terminates(order(Waiter5, Cook6, Order), beWaiter3(Waiter5)at Terminates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',104).

 /*  reactive_rule([ waiter(A,Waiter5),
   		cook(A,Cook6),
   		holds(beWaiter3(Waiter5),Holds)
   	      ],
   	      [ terminates(order(Waiter5,Cook6,Order),
   			   at(beWaiter3(Waiter5),
   			      Terminates),
   			   Terminates10)
   	      ]).
 */


% [restaurant,waiter,cook,food,time]
% WaiterOf(restaurant)=waiter &
% CookOf(restaurant)=cook &
% HoldsAt(BeWaiter3(waiter),time) ->
% Initiates(Order(waiter,cook,food),
%           BeWaiter4(waiter),
%           time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',112).

 /*  axiom(initiates(order(Waiter, Cook, Food), beWaiter4(Waiter), Time),
       [ waiter(Restaurant, Waiter),
         cook(Restaurant, Cook),
         beWaiter3(Waiter)
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',112).

 /*  (   waiter(A, Waiter5),
       cook(A, Cook6),
       beWaiter3(Waiter5)
   ->  initiates(order(Waiter5, Cook6, Order),
                 beWaiter4(Waiter5),
                 Initiates)
   ).
 */
if waiter(A, Waiter5), cook(A, Cook6), beWaiter3(Waiter5)then initiates(order(Waiter5, Cook6, Order), beWaiter4(Waiter5)at Initiates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',112).

 /*  reactive_rule([ waiter(A,Waiter5),
   		cook(A,Cook6),
   		holds(beWaiter3(Waiter5),Holds)
   	      ],
   	      [ initiates(order(Waiter5,Cook6,Order),
   			  at(beWaiter4(Waiter5),Initiates),
   			  Initiates10)
   	      ]).
 */


% [waiter,food,time]
% HoldsAt(BeWaiter4(waiter),time) &
% ({agent} HoldsAt(KnowOrder(waiter,agent,food),time)) &
% HoldsAt(FoodPrepared(food),time) ->
% Happens(PickUp(waiter,food),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',120).

 /*  (   holds_at(beWaiter4(Waiter), Time),
       exists([Agent],
              holds_at(knowOrder(Waiter, Agent, Food), Time)),
       holds_at(foodPrepared(Food), Time)
   ->  happens(pickUp(Waiter, Food), Time)
   ).
 */
if beWaiter4(Waiter)at Time, exists([Agent], knowOrder(Waiter, Agent, Food)at Time), foodPrepared(Food)at Time then happens(pickUp(Waiter, Food), Time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',120).

 /*  reactive_rule([ holds(beWaiter4(Waiter),Time),
   		exists([Agent],
   		       at(knowOrder(Waiter,
   				    Agent,
   				    Food),
   			  Time)),
   		holds(foodPrepared(Food),Time)
   	      ],
   	      [happens(pickUp(Waiter,Food),Time)]).
 */


% [waiter,food,time]
% HoldsAt(BeWaiter4(waiter),time) &
% ({agent} HoldsAt(KnowOrder(waiter,agent,food),time)) ->
% Terminates(PickUp(waiter,food),
%            BeWaiter4(waiter),
%            time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',126).

 /*  axiom(terminates(pickUp(Waiter, Food), beWaiter4(Waiter), Time),
       [beWaiter4(Waiter), knowOrder(Waiter, Agent, Food)]).
 */

 /*  (   beWaiter4(Bewaiter4),
       knowOrder(Bewaiter4, _, Knoworder)
   ->  terminates(pickUp(Bewaiter4, Knoworder),
                  beWaiter4(Bewaiter4),
                  Terminates)
   ).
 */
if beWaiter4(Bewaiter4), knowOrder(Bewaiter4, _, Knoworder)then terminates(pickUp(Bewaiter4, Knoworder), beWaiter4(Bewaiter4)at Terminates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',126).

 /*  reactive_rule([ holds(beWaiter4(Bewaiter4),Holds),
   		holds(knowOrder(Bewaiter4,
   				_,
   				Knoworder),
   		      Holds)
   	      ],
   	      [ terminates(pickUp(Bewaiter4,Knoworder),
   			   at(beWaiter4(Bewaiter4),
   			      Terminates),
   			   Terminates8)
   	      ]).
 */


% [waiter,food,time]
% HoldsAt(BeWaiter4(waiter),time) &
% ({agent} HoldsAt(KnowOrder(waiter,agent,food),time)) ->
% Initiates(PickUp(waiter,food),
%           BeWaiter5(waiter),
%           time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',133).

 /*  axiom(initiates(pickUp(Waiter, Food), beWaiter5(Waiter), Time),
       [beWaiter4(Waiter), knowOrder(Waiter, Agent, Food)]).
 */

 /*  (   beWaiter4(Bewaiter4),
       knowOrder(Bewaiter4, _, Knoworder)
   ->  initiates(pickUp(Bewaiter4, Knoworder),
                 beWaiter5(Bewaiter4),
                 Initiates)
   ).
 */
if beWaiter4(Bewaiter4), knowOrder(Bewaiter4, _, Knoworder)then initiates(pickUp(Bewaiter4, Knoworder), beWaiter5(Bewaiter4)at Initiates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',133).

 /*  reactive_rule([ holds(beWaiter4(Bewaiter4),Holds),
   		holds(knowOrder(Bewaiter4,
   				_,
   				Knoworder),
   		      Holds)
   	      ],
   	      [ initiates(pickUp(Bewaiter4,Knoworder),
   			  at(beWaiter5(Bewaiter4),
   			     Initiates),
   			  Initiates8)
   	      ]).
 */


% [restaurant,waiter,time]
% WaiterOf(restaurant)=waiter &
% HoldsAt(BeWaiter5(waiter),time) ->
% Happens(WalkThroughDoor21(waiter,KitchenDoorOf(restaurant)),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',140).

 /*  (   waiter(Restaurant, Waiter),
       holds_at(beWaiter5(Waiter), Time)
   ->  happens(walkThroughDoor21(Waiter, kitchenDoorOf(Restaurant)),
               Time)
   ).
 */
if waiter(Restaurant, Waiter), beWaiter5(Waiter)at Time then happens(walkThroughDoor21(Waiter, kitchenDoorOf(Restaurant)), Time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',140).

 /*  reactive_rule([ waiter(Restaurant,Waiter),
   		holds(beWaiter5(Waiter),Time)
   	      ],
   	      [ happens(walkThroughDoor21(Waiter,
   					  kitchenDoorOf(Restaurant)),
   			Time)
   	      ]).
 */


% [restaurant,waiter,door,time]
% HoldsAt(BeWaiter5(waiter),time) &
% WaiterOf(restaurant)=waiter &
% KitchenDoorOf(restaurant)=door ->
% Terminates(WalkThroughDoor21(waiter,door),
%            BeWaiter5(waiter),
%            time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',145).

 /*  axiom(terminates(walkThroughDoor21(Waiter, Door), beWaiter5(Waiter), Time),
       [ beWaiter5(Waiter),
         waiter(Restaurant, Waiter),
         kitchenDoor(Restaurant, Door)
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',145).

 /*  (   beWaiter5(Bewaiter5),
       waiter(A, Bewaiter5),
       kitchenDoor(A, Kitchendoor)
   ->  terminates(walkThroughDoor21(Bewaiter5, Kitchendoor),
                  beWaiter5(Bewaiter5),
                  Terminates)
   ).
 */
if beWaiter5(Bewaiter5), waiter(A, Bewaiter5), kitchenDoor(A, Kitchendoor)then terminates(walkThroughDoor21(Bewaiter5, Kitchendoor), beWaiter5(Bewaiter5)at Terminates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',145).

 /*  reactive_rule([ holds(beWaiter5(Bewaiter5),Holds),
   		waiter(A,Bewaiter5),
   		kitchenDoor(A,Kitchendoor)
   	      ],
   	      [ terminates(walkThroughDoor21(Bewaiter5,
   					     Kitchendoor),
   			   at(beWaiter5(Bewaiter5),
   			      Terminates),
   			   Terminates8)
   	      ]).
 */


% [restaurant,waiter,door,time]
% HoldsAt(BeWaiter5(waiter),time) &
% WaiterOf(restaurant)=waiter &
% KitchenDoorOf(restaurant)=door ->
% Initiates(WalkThroughDoor21(waiter,door),
%           BeWaiter6(waiter),
%           time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',153).

 /*  axiom(initiates(walkThroughDoor21(Waiter, Door), beWaiter6(Waiter), Time),
       [ beWaiter5(Waiter),
         waiter(Restaurant, Waiter),
         kitchenDoor(Restaurant, Door)
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',153).

 /*  (   beWaiter5(Bewaiter5),
       waiter(A, Bewaiter5),
       kitchenDoor(A, Kitchendoor)
   ->  initiates(walkThroughDoor21(Bewaiter5, Kitchendoor),
                 beWaiter6(Bewaiter5),
                 Initiates)
   ).
 */
if beWaiter5(Bewaiter5), waiter(A, Bewaiter5), kitchenDoor(A, Kitchendoor)then initiates(walkThroughDoor21(Bewaiter5, Kitchendoor), beWaiter6(Bewaiter5)at Initiates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',153).

 /*  reactive_rule([ holds(beWaiter5(Bewaiter5),Holds),
   		waiter(A,Bewaiter5),
   		kitchenDoor(A,Kitchendoor)
   	      ],
   	      [ initiates(walkThroughDoor21(Bewaiter5,
   					    Kitchendoor),
   			  at(beWaiter6(Bewaiter5),
   			     Initiates),
   			  Initiates8)
   	      ]).
 */


% [restaurant,waiter,table,food,time]
% WaiterOf(restaurant)=waiter &
% TableOf(restaurant)=table &
% HoldsAt(BeWaiter6(waiter),time) &
% HoldsAt(Holding(waiter,food),time) ->
% Happens(PlaceOn(waiter,food,table),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',161).

 /*  (   waiter(Restaurant, Waiter),
       ( table(Restaurant, Table)
       ),
       holds_at(beWaiter6(Waiter), Time),
       holds_at(holding(Waiter, Food), Time)
   ->  happens(placeOn(Waiter, Food, Table), Time)
   ).
 */
if waiter(Restaurant, Waiter), table(Restaurant, Table), beWaiter6(Waiter)at Time, holding(Waiter, Food)at Time then happens(placeOn(Waiter, Food, Table), Time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',161).

 /*  reactive_rule([ waiter(Restaurant,Waiter),
   		table(Restaurant,Table),
   		holds(beWaiter6(Waiter),Time),
   		holds(holding(Waiter,Food),Time)
   	      ],
   	      [ happens(placeOn(Waiter,Food,Table),
   			Time)
   	      ]).
 */


% [waiter,food,table,time]
% HoldsAt(BeWaiter6(waiter),time) ->
% Terminates(PlaceOn(waiter,food,table),
%            BeWaiter6(waiter),
%            time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',168).

 /*  axiom(terminates(placeOn(Waiter, Food, Table), beWaiter6(Waiter), Time),
       [beWaiter6(Waiter)]).
 */

 /*  beWaiter6(Bewaiter6) ->
       terminates(placeOn(Bewaiter6, _, Placeon),
                  beWaiter6(Bewaiter6),
                  Terminates).
 */
if beWaiter6(Bewaiter6)then terminates(placeOn(Bewaiter6, _, Placeon), beWaiter6(Bewaiter6)at Terminates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',168).

 /*  reactive_rule([holds(beWaiter6(Bewaiter6),Holds)],
   	      [ terminates(placeOn(Bewaiter6,
   				   _,
   				   Placeon),
   			   at(beWaiter6(Bewaiter6),
   			      Terminates),
   			   Terminates8)
   	      ]).
 */


% [waiter,food,table,time]
% HoldsAt(BeWaiter6(waiter),time) ->
% Initiates(PlaceOn(waiter,food,table),
%           BeWaiter7(waiter),
%           time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',174).

 /*  axiom(initiates(placeOn(Waiter, Food, Table), beWaiter7(Waiter), Time),
       [beWaiter6(Waiter)]).
 */

 /*  beWaiter6(Bewaiter6) ->
       initiates(placeOn(Bewaiter6, _, Placeon),
                 beWaiter7(Bewaiter6),
                 Initiates).
 */
if beWaiter6(Bewaiter6)then initiates(placeOn(Bewaiter6, _, Placeon), beWaiter7(Bewaiter6)at Initiates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',174).

 /*  reactive_rule([holds(beWaiter6(Bewaiter6),Holds)],
   	      [ initiates(placeOn(Bewaiter6,
   				  _,
   				  Placeon),
   			  at(beWaiter7(Bewaiter6),
   			     Initiates),
   			  Initiates8)
   	      ]).
 */


% [waiter,agent,bill,time]
% HoldsAt(BeWaiter7(waiter),time) ->
% Terminates(Request(agent,waiter,bill),
%            BeWaiter7(waiter),
%            time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',180).

 /*  axiom(terminates(request(Agent, Waiter, Bill), beWaiter7(Waiter), Time),
       [beWaiter7(Waiter)]).
 */

 /*  beWaiter7(Bewaiter7) ->
       terminates(request(RequestP_Num3_V, Bewaiter7, Request),
                  beWaiter7(Bewaiter7),
                  Terminates).
 */
if beWaiter7(Bewaiter7)then terminates(request(RequestP_Num3_V, Bewaiter7, Request), beWaiter7(Bewaiter7)at Terminates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',180).

 /*  reactive_rule([beWaiter7(Bewaiter7)],
   	      [ terminates(request(RequestP_Num3_V,
   				   Bewaiter7,
   				   Request),
   			   at(beWaiter7(Bewaiter7),
   			      Terminates),
   			   Terminates8)
   	      ]).
 */


% [waiter,agent,bill,time]
% HoldsAt(BeWaiter7(waiter),time) ->
% Initiates(Request(agent,waiter,bill),
%           BeWaiter8(waiter),
%           time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',186).

 /*  axiom(initiates(request(Agent, Waiter, Bill), beWaiter8(Waiter), Time),
       [beWaiter7(Waiter)]).
 */

 /*  beWaiter7(Bewaiter7) ->
       initiates(request(RequestP_Num3_V, Bewaiter7, Request),
                 beWaiter8(Bewaiter7),
                 Initiates).
 */
if beWaiter7(Bewaiter7)then initiates(request(RequestP_Num3_V, Bewaiter7, Request), beWaiter8(Bewaiter7)at Initiates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',186).

 /*  reactive_rule([beWaiter7(Bewaiter7)],
   	      [ initiates(request(RequestP_Num3_V,
   				  Bewaiter7,
   				  Request),
   			  at(beWaiter8(Bewaiter7),
   			     Initiates),
   			  Initiates8)
   	      ]).
 */


% [restaurant,waiter,bill,time]
% WaiterOf(restaurant)=waiter &
% BillOf(restaurant)=bill &
% HoldsAt(BeWaiter8(waiter),time) ->
% Happens(PickUp(waiter,bill),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',192).

 /*  (   waiter(Restaurant, Waiter),
       bill(Restaurant, Bill),
       holds_at(beWaiter8(Waiter), Time)
   ->  happens(pickUp(Waiter, Bill), Time)
   ).
 */
if waiter(Restaurant, Waiter), bill(Restaurant, Bill), beWaiter8(Waiter)at Time then happens(pickUp(Waiter, Bill), Time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',192).

 /*  reactive_rule([ waiter(Restaurant,Waiter),
   		bill(Restaurant,Bill),
   		holds(beWaiter8(Waiter),Time)
   	      ],
   	      [happens(pickUp(Waiter,Bill),Time)]).
 */


% [waiter,bill,time]
% HoldsAt(BeWaiter8(waiter),time) ->
% Terminates(PickUp(waiter,bill),
%            BeWaiter8(waiter),
%            time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',198).

 /*  axiom(terminates(pickUp(Waiter, Bill), beWaiter8(Waiter), Time),
       [beWaiter8(Waiter)]).
 */

 /*  beWaiter8(Bewaiter8) ->
       terminates(pickUp(Bewaiter8, Pickup),
                  beWaiter8(Bewaiter8),
                  Terminates).
 */
if beWaiter8(Bewaiter8)then terminates(pickUp(Bewaiter8, Pickup), beWaiter8(Bewaiter8)at Terminates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',198).

 /*  reactive_rule([holds(beWaiter8(Bewaiter8),Holds)],
   	      [ terminates(pickUp(Bewaiter8,Pickup),
   			   at(beWaiter8(Bewaiter8),
   			      Terminates),
   			   Terminates7)
   	      ]).
 */


% [waiter,bill,time]
% HoldsAt(BeWaiter8(waiter),time) ->
% Initiates(PickUp(waiter,bill),
%           BeWaiter9(waiter),
%           time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',204).

 /*  axiom(initiates(pickUp(Waiter, Bill), beWaiter9(Waiter), Time),
       [beWaiter8(Waiter)]).
 */

 /*  beWaiter8(Bewaiter8) ->
       initiates(pickUp(Bewaiter8, Pickup),
                 beWaiter9(Bewaiter8),
                 Initiates).
 */
if beWaiter8(Bewaiter8)then initiates(pickUp(Bewaiter8, Pickup), beWaiter9(Bewaiter8)at Initiates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',204).

 /*  reactive_rule([holds(beWaiter8(Bewaiter8),Holds)],
   	      [ initiates(pickUp(Bewaiter8,Pickup),
   			  at(beWaiter9(Bewaiter8),
   			     Initiates),
   			  Initiates7)
   	      ]).
 */


% [restaurant,waiter,bill,table,time]
% WaiterOf(restaurant)=waiter &
% BillOf(restaurant)=bill &
% TableOf(restaurant)=table &
% HoldsAt(BeWaiter9(waiter),time) ->
% Happens(PlaceOn(waiter,bill,table),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',210).

 /*  (   waiter(Restaurant, Waiter),
       bill(Restaurant, Bill),
       ( table(Restaurant, Table)
       ),
       holds_at(beWaiter9(Waiter), Time)
   ->  happens(placeOn(Waiter, Bill, Table), Time)
   ).
 */
if waiter(Restaurant, Waiter), bill(Restaurant, Bill), table(Restaurant, Table), beWaiter9(Waiter)at Time then happens(placeOn(Waiter, Bill, Table), Time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',210).

 /*  reactive_rule([ waiter(Restaurant,Waiter),
   		bill(Restaurant,Bill),
   		table(Restaurant,Table),
   		holds(beWaiter9(Waiter),Time)
   	      ],
   	      [ happens(placeOn(Waiter,Bill,Table),
   			Time)
   	      ]).
 */


% [waiter,bill,table,time]
% HoldsAt(BeWaiter9(waiter),time) ->
% Terminates(PlaceOn(waiter,bill,table),
%            BeWaiter9(waiter),
%            time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',217).

 /*  axiom(terminates(placeOn(Waiter, Bill, Table), beWaiter9(Waiter), Time),
       [beWaiter9(Waiter)]).
 */

 /*  beWaiter9(Bewaiter9) ->
       terminates(placeOn(Bewaiter9, _, Placeon),
                  beWaiter9(Bewaiter9),
                  Terminates).
 */
if beWaiter9(Bewaiter9)then terminates(placeOn(Bewaiter9, _, Placeon), beWaiter9(Bewaiter9)at Terminates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',217).

 /*  reactive_rule([holds(beWaiter9(Bewaiter9),Holds)],
   	      [ terminates(placeOn(Bewaiter9,
   				   _,
   				   Placeon),
   			   at(beWaiter9(Bewaiter9),
   			      Terminates),
   			   Terminates8)
   	      ]).
 */


% [waiter,bill,table,time]
% HoldsAt(BeWaiter9(waiter),time) ->
% Initiates(PlaceOn(waiter,bill,table),
%           BeWaiter0(waiter),
%           time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',223).

 /*  axiom(initiates(placeOn(Waiter, Bill, Table), beWaiter0(Waiter), Time),
       [beWaiter9(Waiter)]).
 */

 /*  beWaiter9(Bewaiter9) ->
       initiates(placeOn(Bewaiter9, _, Placeon),
                 beWaiter0(Bewaiter9),
                 Initiates).
 */
if beWaiter9(Bewaiter9)then initiates(placeOn(Bewaiter9, _, Placeon), beWaiter0(Bewaiter9)at Initiates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',223).

 /*  reactive_rule([holds(beWaiter9(Bewaiter9),Holds)],
   	      [ initiates(placeOn(Bewaiter9,
   				  _,
   				  Placeon),
   			  at(beWaiter0(Bewaiter9),
   			     Initiates),
   			  Initiates8)
   	      ]).
 */


%; awaiting next waiter order

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',229).
% fluent BeCook0(cook)
 %  fluent(beCook0(cook)).
 %  fluent(beCook0(cook)).
fluents([beCook0/1]).
mpred_prop(beCook0(cook),fluent).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',231).
%; waiter order received

% fluent BeCook1(cook)
 %  fluent(beCook1(cook)).
 %  fluent(beCook1(cook)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',231).
fluents([beCook1/1]).
mpred_prop(beCook1(cook),fluent).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',234).
% xor BeCook0, BeCook1
 %  ==>xor[beCook0,beCook1].
==>xor[beCook0,beCook1].


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',236).
% [cook,agent,food,time]
% HoldsAt(BeCook0(cook),time) ->
% Terminates(Order(agent,cook,food),
%            BeCook0(cook),
%            time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',236).

 /*  axiom(terminates(order(Agent, Cook, Food), beCook0(Cook), Time),
       [beCook0(Cook)]).
 */

 /*  beCook0(Becook0) ->
       terminates(order(OrderP_Num3_V, Becook0, Order),
                  beCook0(Becook0),
                  Terminates).
 */
if beCook0(Becook0)then terminates(order(OrderP_Num3_V, Becook0, Order), beCook0(Becook0)at Terminates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',236).

 /*  reactive_rule([beCook0(Becook0)],
   	      [ terminates(order(OrderP_Num3_V,
   				 Becook0,
   				 Order),
   			   at(beCook0(Becook0),Terminates),
   			   Terminates8)
   	      ]).
 */


% [cook,agent,food,time]
% HoldsAt(BeCook0(cook),time) ->
% Initiates(Order(agent,cook,food),
%           BeCook1(cook),
%           time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',243).

 /*  axiom(initiates(order(Agent, Cook, Food), beCook1(Cook), Time),
       [beCook0(Cook)]).
 */

 /*  beCook0(Becook0) ->
       initiates(order(OrderP_Num3_V, Becook0, Order),
                 beCook1(Becook0),
                 Initiates).
 */
if beCook0(Becook0)then initiates(order(OrderP_Num3_V, Becook0, Order), beCook1(Becook0)at Initiates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',243).

 /*  reactive_rule([beCook0(Becook0)],
   	      [ initiates(order(OrderP_Num3_V,
   				Becook0,
   				Order),
   			  at(beCook1(Becook0),Initiates),
   			  Initiates8)
   	      ]).
 */

% event FoodPrepare(agent,food)
 %  event(foodPrepare(agent,food)).
 %  event(foodPrepare(agent,food)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',247).
actions([foodPrepare/2]).
mpred_prop(foodPrepare(agent,food),event).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',250).
% fluent FoodPrepared(food)
 %  fluent(foodPrepared(food)).
 %  fluent(foodPrepared(food)).
fluents([foodPrepared/1]).
mpred_prop(foodPrepared(food),fluent).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',252).
% [agent,food,time]
% Initiates(FoodPrepare(agent,food),
%           FoodPrepared(food),
%           time).

 /*  axiom(initiates(foodPrepare(Agent, Food), foodPrepared(Food), Time),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',252).

 /*  initiates(foodPrepare(_,Foodprepare),
   	  foodPrepared(Foodprepare),
   	  Initiates).
 */
foodPrepare(_, Foodprepare)initiates foodPrepared(Foodprepare).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',252).

 /*  initiated(happens(foodPrepare(_,Foodprepare),
   		  Time_From,
   		  Time_Until),
   	  foodPrepared(Foodprepare),
   	  []).
 */


% [agent,food,time]
% Happens(FoodPrepare(agent,food),time) ->
% {location}% 
% HoldsAt(At(agent,location),time) &
% HoldsAt(At(food,location),time).
 %  clausify_pnf=exists([Location],  (happens(foodPrepare(Agent, Food), Time)->holds_at(at(Agent, Location), Time), holds_at(at(Food, Location), Time))).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',258).

 /*  not(happens(foodPrepare(Agent, Food), Time)) :-
       (   not(holds_at(at(Agent, Exists_Location), Time))
       ;   not(holds_at(at(Food, Exists_Location), Time))
       ),
       some(Exists_Location,
            '$kolem_Fn_91'(Agent, Food, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',258).

 /*  fix_axiom_head(Time) ->
       [ not(happens(foodPrepare(Agent, Food), Time)),
          (->),
         not(foodPrepare(Agent, Food))
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',258).

 /*  axiom(not(foodPrepare(Agent, Food)),
       [  (not(at(Agent, Exists_Location));not(at(Food, Exists_Location))),
         some(Exists_Location,
              '$kolem_Fn_91'(Agent, Food, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',258).

 /*  (   (   not(at(Kolem_Fn_91P_Num3_V, Tloc))
       ;   not(at(Foodprepare, Tloc))
       ),
       some(Tloc,
            '$kolem_Fn_91'(Kolem_Fn_91P_Num3_V,
                           Foodprepare,
                           Kolem_Fn_91))
   ->  not(foodPrepare(Kolem_Fn_91P_Num3_V, Foodprepare))
   ).
 */
if (not loc_at(Kolem_Fn_91P_Num3_V, Tloc);not loc_at(Foodprepare, Tloc)), some(Tloc, '$kolem_Fn_91'(Kolem_Fn_91P_Num3_V, Foodprepare, Kolem_Fn_91))then not foodPrepare(Kolem_Fn_91P_Num3_V, Foodprepare).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',258).

 /*   reactive_rule([  (not(loc_at(Kolem_Fn_91P_Num3_V, Tloc));not(loc_at(Foodprepare, Tloc))),
                      some(Tloc,
                           '$kolem_Fn_91'(Kolem_Fn_91P_Num3_V,
                                          Foodprepare,
                                          Kolem_Fn_91))
                    ],
                    [ not(foodPrepare(Kolem_Fn_91P_Num3_V,
                                      Foodprepare))
                    ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',258).

 /*  holds_at(at(Agent, Exists_Location), Time) :-
       happens(foodPrepare(Agent, Food), Time),
       some(Exists_Location,
            '$kolem_Fn_91'(Agent, Food, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',258).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Agent, Exists_Location), Time),
          (->),
         at(Agent, Exists_Location)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',258).

 /*  axiom(at(Agent, Exists_Location),
       [ foodPrepare(Agent, Food),
         some(Exists_Location,
              '$kolem_Fn_91'(Agent, Food, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',258).

 /*  (   foodPrepare(Kolem_Fn_91P_Num3_V12, Foodprepare10),
       some(Tloc9,
            '$kolem_Fn_91'(Kolem_Fn_91P_Num3_V12,
                           Foodprepare10,
                           Kolem_Fn_9111))
   ->  at(Kolem_Fn_91P_Num3_V12, Tloc9)
   ).
 */
if foodPrepare(Kolem_Fn_91P_Num3_V12, Foodprepare10), some(Tloc9, '$kolem_Fn_91'(Kolem_Fn_91P_Num3_V12, Foodprepare10, Kolem_Fn_9111))then loc_at(Kolem_Fn_91P_Num3_V12, Tloc9).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',258).

 /*  reactive_rule([ happens(foodPrepare(Kolem_Fn_91P_Num3_V12,
   				    Foodprepare10),
   			Time_From,
   			Time_Until),
   		some(Tloc9,
   		     '$kolem_Fn_91'(Kolem_Fn_91P_Num3_V12,
   				    Foodprepare10,
   				    Kolem_Fn_9111))
   	      ],
   	      [ holds(loc_at(Kolem_Fn_91P_Num3_V12,Tloc9),
   		      Holds)
   	      ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',258).

 /*  holds_at(at(Food, Exists_Location), Time) :-
       happens(foodPrepare(Agent, Food), Time),
       some(Exists_Location,
            '$kolem_Fn_91'(Agent, Food, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',258).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Food, Exists_Location), Time),
          (->),
         at(Food, Exists_Location)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',258).

 /*  axiom(at(Food, Exists_Location),
       [ foodPrepare(Agent, Food),
         some(Exists_Location,
              '$kolem_Fn_91'(Agent, Food, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',258).

 /*  (   foodPrepare(Kolem_Fn_91P_Num3_V19, Foodprepare17),
       some(Tloc16,
            '$kolem_Fn_91'(Kolem_Fn_91P_Num3_V19,
                           Foodprepare17,
                           Kolem_Fn_9118))
   ->  at(Foodprepare17, Tloc16)
   ).
 */
if foodPrepare(Kolem_Fn_91P_Num3_V19, Foodprepare17), some(Tloc16, '$kolem_Fn_91'(Kolem_Fn_91P_Num3_V19, Foodprepare17, Kolem_Fn_9118))then loc_at(Foodprepare17, Tloc16).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',258).

 /*  reactive_rule([ happens(foodPrepare(Kolem_Fn_91P_Num3_V19,
   				    Foodprepare17),
   			Time_From20,
   			Time_Until21),
   		some(Tloc16,
   		     '$kolem_Fn_91'(Kolem_Fn_91P_Num3_V19,
   				    Foodprepare17,
   				    Kolem_Fn_9118))
   	      ],
   	      [ holds(loc_at(Foodprepare17,Tloc16),
   		      Holds22)
   	      ]).
 */


% [cook,agent,food,time]
% HoldsAt(BeCook1(cook),time) &
% HoldsAt(KnowOrder(cook,agent,food),time) ->
% Happens(FoodPrepare(cook,food),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',264).

 /*  (   holds_at(beCook1(Cook), Time),
       holds_at(knowOrder(Cook, Agent, Food), Time)
   ->  happens(foodPrepare(Cook, Food), Time)
   ).
 */
if beCook1(Cook)at Time, knowOrder(Cook, Agent, Food)at Time then happens(foodPrepare(Cook, Food), Time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',264).

 /*  reactive_rule([ holds(beCook1(Cook),Time),
   		holds(knowOrder(Cook,Agent,Food),
   		      Time)
   	      ],
   	      [happens(foodPrepare(Cook,Food),Time)]).
 */


% [cook,food,time]
% HoldsAt(BeCook1(cook),time) ->
% Terminates(FoodPrepare(cook,food),
%            BeCook1(cook),
%            time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',269).

 /*  axiom(terminates(foodPrepare(Cook, Food), beCook1(Cook), Time),
       [beCook1(Cook)]).
 */

 /*  beCook1(Becook1) ->
       terminates(foodPrepare(Becook1, Foodprepare),
                  beCook1(Becook1),
                  Terminates).
 */
if beCook1(Becook1)then terminates(foodPrepare(Becook1, Foodprepare), beCook1(Becook1)at Terminates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',269).

 /*  reactive_rule([holds(beCook1(Becook1),Holds)],
   	      [ terminates(foodPrepare(Becook1,Foodprepare),
   			   at(beCook1(Becook1),Terminates),
   			   Terminates7)
   	      ]).
 */


% [cook,food,time]
% HoldsAt(BeCook1(cook),time) ->
% Initiates(FoodPrepare(cook,food),
%           BeCook0(cook),
%           time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',275).

 /*  axiom(initiates(foodPrepare(Cook, Food), beCook0(Cook), Time),
       [beCook1(Cook)]).
 */

 /*  beCook1(Becook1) ->
       initiates(foodPrepare(Becook1, Foodprepare),
                 beCook0(Becook1),
                 Initiates).
 */
if beCook1(Becook1)then initiates(foodPrepare(Becook1, Foodprepare), beCook0(Becook1)at Initiates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',275).

 /*  reactive_rule([holds(beCook1(Becook1),Holds)],
   	      [ initiates(foodPrepare(Becook1,Foodprepare),
   			  at(beCook0(Becook1),Initiates),
   			  Initiates7)
   	      ]).
 */


%; End of file.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Restaurant.e',279).
:- endif.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',48).
% load answers/Mueller2003/Sleep.e
:- if(is_e_toplevel).
:- cond_convert_e(changed, 'answers/Mueller2003/Sleep.e').
 %  loading(changed,'/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e').
%;
%; Copyright (c) 2005 IBM Corporation and others.
%; All rights reserved. This program and the accompanying materials
%; are made available under the terms of the Common Public License v1.0
%; which accompanies this distribution, and is available at
%; http://www.eclipse.org/legal/cpl-v10.html
%;
%; Contributors:
%; IBM - Initial implementation
%;
%; The Sleep representation deals with the activity of sleeping and
%; body posture.
%; It is similar to the finite automaton representation of sleep
%; used in ThoughtTreasure \fullcite[chap. 7]{Mueller:1998}.
%;
%; @book{Mueller:1998,
%;   author = "Erik T. Mueller",
%;   year = "1998",
%;   title = "Natural Language Processing with \uppercase{T}hought\uppercase{T}reasure",
%;   address = "New York",
%;   publisher = "Signiform",
%; }
%;
%; sleep
%; agent wakes up.

% event WakeUp(agent)
 %  event(wakeUp(agent)).
 %  event(wakeUp(agent)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',27).
actions([wakeUp/1]).
mpred_prop(wakeUp(agent),event).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',30).
%; agent gets tired.

% event GetTired(agent)
 %  event(getTired(agent)).
 %  event(getTired(agent)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',30).
actions([getTired/1]).
mpred_prop(getTired(agent),event).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',33).
%; agent falls asleep.

% event FallAsleep(agent)
 %  event(fallAsleep(agent)).
 %  event(fallAsleep(agent)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',33).
actions([fallAsleep/1]).
mpred_prop(fallAsleep(agent),event).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',36).
%; agent is asleep.

% fluent Sleep0(agent)
 %  fluent(sleep0(agent)).
 %  fluent(sleep0(agent)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',36).
fluents([sleep0/1]).
mpred_prop(sleep0(agent),fluent).


%; agent is awake and in bed.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',39).
% fluent Sleep1(agent)
 %  fluent(sleep1(agent)).
 %  fluent(sleep1(agent)).
fluents([sleep1/1]).
mpred_prop(sleep1(agent),fluent).


%; agent is awake, out of bed, and undressed.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',41).
% fluent Sleep2(agent)
 %  fluent(sleep2(agent)).
 %  fluent(sleep2(agent)).
fluents([sleep2/1]).
mpred_prop(sleep2(agent),fluent).


%; agent is awake and dressed.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',43).
% fluent Sleep3(agent)
 %  fluent(sleep3(agent)).
 %  fluent(sleep3(agent)).
fluents([sleep3/1]).
mpred_prop(sleep3(agent),fluent).


%; agent is tired and dressed.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',45).
% fluent Sleep4(agent)
 %  fluent(sleep4(agent)).
 %  fluent(sleep4(agent)).
fluents([sleep4/1]).
mpred_prop(sleep4(agent),fluent).


%; agent is tired and undressed.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',47).
% fluent Sleep5(agent)
 %  fluent(sleep5(agent)).
 %  fluent(sleep5(agent)).
fluents([sleep5/1]).
mpred_prop(sleep5(agent),fluent).


%; agent is in bed, waiting to fall asleep.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',49).
% fluent Sleep6(agent)
 %  fluent(sleep6(agent)).
 %  fluent(sleep6(agent)).
fluents([sleep6/1]).
mpred_prop(sleep6(agent),fluent).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',51).
%; At any time, an agent is in one of seven sleep states:

% xor Sleep0, Sleep1, Sleep2, Sleep3, Sleep4, Sleep5, Sleep6
 %  ==>xor[sleep0,sleep1,sleep2,sleep3,sleep4,sleep5,sleep6].
==>xor[sleep0,sleep1,sleep2,sleep3,sleep4,sleep5,sleep6].
%; constraints
%; agent is asleep.

% fluent Asleep(agent)
 %  fluent(asleep(agent)).
 %  fluent(asleep(agent)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',56).
fluents([asleep/1]).
mpred_prop(asleep(agent),fluent).


%; agent is awake.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',59).
% fluent Awake(agent)
 %  fluent(awake(agent)).
 %  fluent(awake(agent)).
fluents([awake/1]).
mpred_prop(awake(agent),fluent).

% noninertial Asleep
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',59).
noninertial(asleep).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',61).
% noninertial Awake
noninertial(awake).
%; Sleep0 indicates that the agent is asleep:
% [agent,time]
 % HoldsAt(Asleep(agent),time) <-> HoldsAt(Sleep0(agent),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',63).

 /*  holds_at(asleep(Agent), Time) <->
       holds_at(sleep0(Agent), Time).
 */

 /*  holds_at(asleep(Agent), Time) ->
       holds_at(sleep0(Agent), Time).
 */
if asleep(Agent)at Time then sleep0(Agent)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',63).

 /*  reactive_rule([holds(asleep(Agent),Time)],
   	      [holds(sleep0(Agent),Time)]).
 */

 /*  holds_at(sleep0(Agent), Time) ->
       holds_at(asleep(Agent), Time).
 */
if sleep0(Agent)at Time then asleep(Agent)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',63).

 /*  reactive_rule([holds(sleep0(Agent),Time)],
   	      [holds(asleep(Agent),Time)]).
 */


%; In all other sleep states, the agent is awake:
% [agent,time]
% HoldsAt(Awake(agent),time) <->
% HoldsAt(Sleep1(agent),time) |
% HoldsAt(Sleep2(agent),time) |
% HoldsAt(Sleep3(agent),time) |
% HoldsAt(Sleep4(agent),time) |
% HoldsAt(Sleep5(agent),time) |
% HoldsAt(Sleep6(agent),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',67).

 /*  holds_at(awake(Agent), Time) <->
       (   holds_at(sleep1(Agent), Time)
       ;   holds_at(sleep2(Agent), Time)
       ;   holds_at(sleep3(Agent), Time)
       ;   holds_at(sleep4(Agent), Time)
       ;   holds_at(sleep5(Agent), Time)
       ;   holds_at(sleep6(Agent), Time)
       ).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',67).

 /*  holds_at(awake(Agent), Time) ->
       (   holds_at(sleep1(Agent), Time)
       ;   holds_at(sleep2(Agent), Time)
       ;   holds_at(sleep3(Agent), Time)
       ;   holds_at(sleep4(Agent), Time)
       ;   holds_at(sleep5(Agent), Time)
       ;   holds_at(sleep6(Agent), Time)
       ).
 */
if awake(Agent)at Time then sleep1(Agent)at Time;sleep2(Agent)at Time;sleep3(Agent)at Time;sleep4(Agent)at Time;sleep5(Agent)at Time;sleep6(Agent)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',67).

 /*   reactive_rule([holds(awake(Agent), Time)],
                    [  (at(sleep1(Agent), Time);at(sleep2(Agent), Time);at(sleep3(Agent), Time);at(sleep4(Agent), Time);at(sleep5(Agent), Time);at(sleep6(Agent), Time))
                    ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',67).

 /*  holds_at(sleep1(Agent), Time);holds_at(sleep2(Agent), Time);holds_at(sleep3(Agent), Time);holds_at(sleep4(Agent), Time);holds_at(sleep5(Agent), Time);holds_at(sleep6(Agent), Time) ->
       holds_at(awake(Agent), Time).
 */
if sleep1(Agent)at Time;sleep2(Agent)at Time;sleep3(Agent)at Time;sleep4(Agent)at Time;sleep5(Agent)at Time;sleep6(Agent)at Time then awake(Agent)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',67).

 /*   reactive_rule([  (at(sleep1(Agent), Time);at(sleep2(Agent), Time);at(sleep3(Agent), Time);at(sleep4(Agent), Time);at(sleep5(Agent), Time);at(sleep6(Agent), Time))
                    ],
                    [holds(awake(Agent), Time)]).
 */


%; A number of axioms are used to specify the transitions of
%; a finite automaton.
%;--
%; Waking up causes a transition from Sleep0
%; to Sleep1:
% [agent,time]
 
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',82).
% Terminates(WakeUp(agent),Sleep0(agent),time).

 /*  axiom(terminates(wakeUp(Agent), sleep0(Agent), Time),
       []).
 */
 %  terminates(wakeUp(Wakeup),sleep0(Wakeup),Terminates).
wakeUp(Wakeup)terminates sleep0(Wakeup).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',82).

 /*  terminated(happens(wakeUp(Wakeup),
   		   Time_From,
   		   Time_Until),
   	   sleep0(Wakeup),
   	   []).
 */


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',84).
% [agent,time]
 % Initiates(WakeUp(agent),Sleep1(agent),time).

 /*  axiom(initiates(wakeUp(Agent), sleep1(Agent), Time),
       []).
 */
 %  initiates(wakeUp(Wakeup),sleep1(Wakeup),Initiates).
wakeUp(Wakeup)initiates sleep1(Wakeup).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',84).

 /*  initiated(happens(wakeUp(Wakeup),
   		  Time_From,
   		  Time_Until),
   	  sleep1(Wakeup),
   	  []).
 */


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',86).
% [agent,time]
 % Happens(WakeUp(agent),time) -> HoldsAt(Sleep0(agent),time).

 /*  happens(wakeUp(Agent), Time) ->
       holds_at(sleep0(Agent), Time).
 */
if happens(wakeUp(Agent), Time)then sleep0(Agent)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',86).

 /*  reactive_rule([happens(wakeUp(Agent),Time)],
   	      [holds(sleep0(Agent),Time)]).
 */


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',88).
%;--
%; Getting out of bed causes a transition from Sleep1
%; to Sleep2:
% [agent,bed,time]
 
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',92).
% Terminates(RiseFrom(agent,bed),Sleep1(agent),time).

 /*  axiom(terminates(riseFrom(Agent, Bed), sleep1(Agent), Time),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',92).

 /*  terminates(riseFrom(Sleep1,Risefrom),
   	   sleep1(Sleep1),
   	   Terminates).
 */
riseFrom(Sleep1, Risefrom)terminates sleep1(Sleep1).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',92).

 /*  terminated(happens(riseFrom(Sleep1,Risefrom),
   		   Time_From,
   		   Time_Until),
   	   sleep1(Sleep1),
   	   []).
 */


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',94).
% [agent,bed,time]
 % Initiates(RiseFrom(agent,bed),Sleep2(agent),time).

 /*  axiom(initiates(riseFrom(Agent, Bed), sleep2(Agent), Time),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',94).

 /*  initiates(riseFrom(Sleep2,Risefrom),
   	  sleep2(Sleep2),
   	  Initiates).
 */
riseFrom(Sleep2, Risefrom)initiates sleep2(Sleep2).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',94).

 /*  initiated(happens(riseFrom(Sleep2,Risefrom),
   		  Time_From,
   		  Time_Until),
   	  sleep2(Sleep2),
   	  []).
 */


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',96).
% [agent,bed,time]
% Happens(RiseFrom(agent,bed),time) -> HoldsAt(Sleep1(agent),time).

 /*  happens(riseFrom(Agent, Bed), Time) ->
       holds_at(sleep1(Agent), Time).
 */
if happens(riseFrom(Agent, Bed), Time)then sleep1(Agent)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',96).

 /*  reactive_rule([happens(riseFrom(Agent,Bed),Time)],
   	      [holds(sleep1(Agent),Time)]).
 */


%;--
%; Getting dressed causes a transition from Sleep2
%; to Sleep3, the normal state of awakeness:
% [agent,time]
 
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',103).
% Terminates(GetDressed(agent),Sleep2(agent),time).

 /*  axiom(terminates(getDressed(Agent), sleep2(Agent), Time),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',103).

 /*  terminates(getDressed(Getdressed),
   	   sleep2(Getdressed),
   	   Terminates).
 */
getDressed(Getdressed)terminates sleep2(Getdressed).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',103).

 /*  terminated(happens(getDressed(Getdressed),
   		   Time_From,
   		   Time_Until),
   	   sleep2(Getdressed),
   	   []).
 */


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',105).
% [agent,time]
 % Initiates(GetDressed(agent),Sleep3(agent),time).

 /*  axiom(initiates(getDressed(Agent), sleep3(Agent), Time),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',105).

 /*  initiates(getDressed(Getdressed),
   	  sleep3(Getdressed),
   	  Initiates).
 */
getDressed(Getdressed)initiates sleep3(Getdressed).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',105).

 /*  initiated(happens(getDressed(Getdressed),
   		  Time_From,
   		  Time_Until),
   	  sleep3(Getdressed),
   	  []).
 */


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',107).
% [agent,time]
 % Happens(GetDressed(agent),time) -> HoldsAt(Sleep2(agent),time).

 /*  happens(getDressed(Agent), Time) ->
       holds_at(sleep2(Agent), Time).
 */
if happens(getDressed(Agent), Time)then sleep2(Agent)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',107).

 /*  reactive_rule([happens(getDressed(Agent),Time)],
   	      [holds(sleep2(Agent),Time)]).
 */


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',109).
%;--
%; Getting tired causes a transition from Sleep3
%; to Sleep4:
% [agent,time]
 
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',113).
% Terminates(GetTired(agent),Sleep3(agent),time).

 /*  axiom(terminates(getTired(Agent), sleep3(Agent), Time),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',113).

 /*  terminates(getTired(Gettired),
   	   sleep3(Gettired),
   	   Terminates).
 */
getTired(Gettired)terminates sleep3(Gettired).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',113).

 /*  terminated(happens(getTired(Gettired),
   		   Time_From,
   		   Time_Until),
   	   sleep3(Gettired),
   	   []).
 */


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',115).
% [agent,time]
 % Initiates(GetTired(agent),Sleep4(agent),time).

 /*  axiom(initiates(getTired(Agent), sleep4(Agent), Time),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',115).

 /*  initiates(getTired(Gettired),
   	  sleep4(Gettired),
   	  Initiates).
 */
getTired(Gettired)initiates sleep4(Gettired).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',115).

 /*  initiated(happens(getTired(Gettired),
   		  Time_From,
   		  Time_Until),
   	  sleep4(Gettired),
   	  []).
 */


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',117).
% [agent,time]
 % Happens(GetTired(agent),time) -> HoldsAt(Sleep3(agent),time).

 /*  happens(getTired(Agent), Time) ->
       holds_at(sleep3(Agent), Time).
 */
if happens(getTired(Agent), Time)then sleep3(Agent)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',117).

 /*  reactive_rule([happens(getTired(Agent),Time)],
   	      [holds(sleep3(Agent),Time)]).
 */


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',119).
%;--
%; Getting undressed causes a transition from Sleep4
%; to Sleep5:
% [agent,time]
 
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',123).
% Terminates(GetUndressed(agent),Sleep4(agent),time).

 /*  axiom(terminates(getUndressed(Agent), sleep4(Agent), Time),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',123).

 /*  terminates(getUndressed(Getundressed),
   	   sleep4(Getundressed),
   	   Terminates).
 */
getUndressed(Getundressed)terminates sleep4(Getundressed).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',123).

 /*  terminated(happens(getUndressed(Getundressed),
   		   Time_From,
   		   Time_Until),
   	   sleep4(Getundressed),
   	   []).
 */


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',125).
% [agent,time]
 % Initiates(GetUndressed(agent),Sleep5(agent),time).

 /*  axiom(initiates(getUndressed(Agent), sleep5(Agent), Time),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',125).

 /*  initiates(getUndressed(Getundressed),
   	  sleep5(Getundressed),
   	  Initiates).
 */
getUndressed(Getundressed)initiates sleep5(Getundressed).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',125).

 /*  initiated(happens(getUndressed(Getundressed),
   		  Time_From,
   		  Time_Until),
   	  sleep5(Getundressed),
   	  []).
 */


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',127).
% [agent,time]
 % Happens(GetUndressed(agent),time) -> HoldsAt(Sleep4(agent),time).

 /*  happens(getUndressed(Agent), Time) ->
       holds_at(sleep4(Agent), Time).
 */
if happens(getUndressed(Agent), Time)then sleep4(Agent)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',127).

 /*  reactive_rule([happens(getUndressed(Agent),Time)],
   	      [holds(sleep4(Agent),Time)]).
 */


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',129).
%;--
%; Lying on a bed causes a transition from Sleep5
%; to Sleep6:
% [agent,bed,time]
 
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',133).
% Terminates(LieOn(agent,bed),Sleep5(agent),time).

 /*  axiom(terminates(lieOn(Agent, Bed), sleep5(Agent), Time),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',133).

 /*  terminates(lieOn(Sleep5,Lieon),
   	   sleep5(Sleep5),
   	   Terminates).
 */
lieOn(Sleep5, Lieon)terminates sleep5(Sleep5).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',133).

 /*  terminated(happens(lieOn(Sleep5,Lieon),
   		   Time_From,
   		   Time_Until),
   	   sleep5(Sleep5),
   	   []).
 */


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',135).
% [agent,bed,time]
 % Initiates(LieOn(agent,bed),Sleep6(agent),time).

 /*  axiom(initiates(lieOn(Agent, Bed), sleep6(Agent), Time),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',135).

 /*  initiates(lieOn(Sleep6,Lieon),
   	  sleep6(Sleep6),
   	  Initiates).
 */
lieOn(Sleep6, Lieon)initiates sleep6(Sleep6).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',135).

 /*  initiated(happens(lieOn(Sleep6,Lieon),
   		  Time_From,
   		  Time_Until),
   	  sleep6(Sleep6),
   	  []).
 */


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',137).
% [agent,bed,time]
 % Happens(LieOn(agent,bed),time) -> HoldsAt(Sleep5(agent),time).

 /*  happens(lieOn(Agent, Bed), Time) ->
       holds_at(sleep5(Agent), Time).
 */
if happens(lieOn(Agent, Bed), Time)then sleep5(Agent)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',137).

 /*  reactive_rule([happens(lieOn(Agent,Bed),Time)],
   	      [holds(sleep5(Agent),Time)]).
 */


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',139).
%;--
%; Falling asleep causes a transition from Sleep6
%; to Sleep0:
% [agent,time]
 
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',143).
% Terminates(FallAsleep(agent),Sleep6(agent),time).

 /*  axiom(terminates(fallAsleep(Agent), sleep6(Agent), Time),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',143).

 /*  terminates(fallAsleep(Fallasleep),
   	   sleep6(Fallasleep),
   	   Terminates).
 */
fallAsleep(Fallasleep)terminates sleep6(Fallasleep).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',143).

 /*  terminated(happens(fallAsleep(Fallasleep),
   		   Time_From,
   		   Time_Until),
   	   sleep6(Fallasleep),
   	   []).
 */


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',145).
% [agent,time]
 % Initiates(FallAsleep(agent),Sleep0(agent),time).

 /*  axiom(initiates(fallAsleep(Agent), sleep0(Agent), Time),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',145).

 /*  initiates(fallAsleep(Fallasleep),
   	  sleep0(Fallasleep),
   	  Initiates).
 */
fallAsleep(Fallasleep)initiates sleep0(Fallasleep).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',145).

 /*  initiated(happens(fallAsleep(Fallasleep),
   		  Time_From,
   		  Time_Until),
   	  sleep0(Fallasleep),
   	  []).
 */


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',147).
% [agent,time]
 % Happens(FallAsleep(agent),time) -> HoldsAt(Sleep6(agent),time).

 /*  happens(fallAsleep(Agent), Time) ->
       holds_at(sleep6(Agent), Time).
 */
if happens(fallAsleep(Agent), Time)then sleep6(Agent)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',147).

 /*  reactive_rule([happens(fallAsleep(Agent),Time)],
   	      [holds(sleep6(Agent),Time)]).
 */


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',149).
%;--
%; agent acts on being in state Sleep5.

% fluent ActOnSleep5(agent)
 %  fluent(actOnSleep5(agent)).
 %  fluent(actOnSleep5(agent)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',151).
fluents([actOnSleep5/1]).
mpred_prop(actOnSleep5(agent),fluent).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',153).
% noninertial ActOnSleep5
noninertial(actOnSleep5).
%; We reduce the number of models by asserting that
%; an agent only acts on being in state Sleep5 while in
%; that state:
% [agent,time]
% !HoldsAt(Sleep5(agent),time) ->
% !HoldsAt(ActOnSleep5(agent),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',158).

 /*  holds_at(neg(sleep5(Agent)), Time) ->
       holds_at(neg(actOnSleep5(Agent)), Time).
 */
if not sleep5(Agent)at Time then not actOnSleep5(Agent)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',158).

 /*  reactive_rule([holds(not(sleep5(Agent)),Time)],
   	      [holds(not(actOnSleep5(Agent)),Time)]).
 */


%; Undressed is like IntentionToPlay
%; ActOnSleep5 is like ActOnIntentionToPlay
%; A trigger axiom states that if an agent is in state Sleep5,
%; the agent acts on this state, the agent is in a room, and
%; a bed is at the room, the agent lies on the bed:
% [agent,room,bed,time]
% HoldsAt(Sleep5(agent),time) &
% HoldsAt(ActOnSleep5(agent),time) &
% HoldsAt(At(agent,room),time) &
% HoldsAt(At(bed,room),time) ->
% Happens(LieOn(agent,bed),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',168).

 /*  (   holds_at(sleep5(Agent), Time),
       holds_at(actOnSleep5(Agent), Time),
       holds_at(at(Agent, Room), Time),
       holds_at(at(Bed, Room), Time)
   ->  happens(lieOn(Agent, Bed), Time)
   ).
 */
if sleep5(Agent)at Time, actOnSleep5(Agent)at Time, loc_at(Agent, Room)at Time, loc_at(Bed, Room)at Time then happens(lieOn(Agent, Bed), Time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',168).

 /*  reactive_rule([ holds(sleep5(Agent),Time),
   		holds(actOnSleep5(Agent),Time),
   		holds(loc_at(Agent,Room),Time),
   		holds(loc_at(Bed,Room),Time)
   	      ],
   	      [happens(lieOn(Agent,Bed),Time)]).
 */


%; A precondition axiom states that for
%; an agent to lie on a bed,
%; the agent must be in state Sleep5,
%; the agent must act on this state, and
%; there must be a room such that
%; the agent is in the room and the bed is in the room:
% [agent,bed,time]
% Happens(LieOn(agent,bed),time) ->
% HoldsAt(Sleep5(agent),time) &
% HoldsAt(ActOnSleep5(agent),time) &
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',181).
% {room}% 
%  HoldsAt(At(agent,room),time) &
%  HoldsAt(At(bed,room),time).
 %  clausify_pnf=exists([Room],  (happens(lieOn(Agent, Bed), Time)->holds_at(sleep5(Agent), Time), holds_at(actOnSleep5(Agent), Time), holds_at(at(Agent, Room), Time), holds_at(at(Bed, Room), Time))).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',185).

 /*  not(happens(lieOn(Agent, Bed), Time)) :-
       (   not(holds_at(sleep5(Agent), Time))
       ;   not(holds_at(actOnSleep5(Agent), Time))
       ;   not(holds_at(at(Agent, Exists_Room), Time))
       ;   not(holds_at(at(Bed, Exists_Room), Time))
       ),
       some(Exists_Room, '$kolem_Fn_92'(Agent, Bed, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',185).

 /*  fix_axiom_head(Time) ->
       [ not(happens(lieOn(Agent, Bed), Time)),
          (->),
         not(lieOn(Agent, Bed))
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',185).

 /*  axiom(not(lieOn(Agent, Bed)),
       [  (not(sleep5(Agent));not(actOnSleep5(Agent));not(at(Agent, Exists_Room));not(at(Bed, Exists_Room))),
         some(Exists_Room, '$kolem_Fn_92'(Agent, Bed, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',185).

 /*  (   (   not(sleep5(Sleep5))
       ;   not(actOnSleep5(Sleep5))
       ;   not(at(Sleep5, Tloc))
       ;   not(at(Lieon, Tloc))
       ),
       some(Tloc, '$kolem_Fn_92'(Sleep5, Lieon, Kolem_Fn_92))
   ->  not(lieOn(Sleep5, Lieon))
   ).
 */
if (not sleep5(Sleep5);not actOnSleep5(Sleep5);not loc_at(Sleep5, Tloc);not loc_at(Lieon, Tloc)), some(Tloc, '$kolem_Fn_92'(Sleep5, Lieon, Kolem_Fn_92))then not lieOn(Sleep5, Lieon).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',185).

 /*   reactive_rule([  (not(sleep5(Sleep5));not(actOnSleep5(Sleep5));not(loc_at(Sleep5, Tloc));not(loc_at(Lieon, Tloc))),
                      some(Tloc,
                           '$kolem_Fn_92'(Sleep5,
                                          Lieon,
                                          Kolem_Fn_92))
                    ],
                    [not(lieOn(Sleep5, Lieon))]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',185).

 /*  holds_at(sleep5(Agent), Time) :-
       happens(lieOn(Agent, Bed), Time),
       some(Exists_Room, '$kolem_Fn_92'(Agent, Bed, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',185).

 /*  fix_axiom_head(Time) ->
       [holds_at(sleep5(Agent), Time), ->, sleep5(Agent)].
 */

 /*  axiom(sleep5(Agent),
       [ lieOn(Agent, Bed),
         some(Exists_Room, '$kolem_Fn_92'(Agent, Bed, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',185).

 /*  (   lieOn(Kolem_Fn_92P_Num3_V, Lieon9),
       some(_,
            '$kolem_Fn_92'(Kolem_Fn_92P_Num3_V,
                           Lieon9,
                           Kolem_Fn_9210))
   ->  sleep5(Kolem_Fn_92P_Num3_V)
   ).
 */
if lieOn(Kolem_Fn_92P_Num3_V, Lieon9), some(_, '$kolem_Fn_92'(Kolem_Fn_92P_Num3_V, Lieon9, Kolem_Fn_9210))then sleep5(Kolem_Fn_92P_Num3_V).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',185).

 /*  reactive_rule([ happens(lieOn(Kolem_Fn_92P_Num3_V,Lieon9),
   			Time_From,
   			Time_Until),
   		some(_,
   		     '$kolem_Fn_92'(Kolem_Fn_92P_Num3_V,
   				    Lieon9,
   				    Kolem_Fn_9210))
   	      ],
   	      [holds(sleep5(Kolem_Fn_92P_Num3_V),Holds)]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',185).

 /*  holds_at(actOnSleep5(Agent), Time) :-
       happens(lieOn(Agent, Bed), Time),
       some(Exists_Room, '$kolem_Fn_92'(Agent, Bed, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',185).

 /*  fix_axiom_head(Time) ->
       [ holds_at(actOnSleep5(Agent), Time),
          (->),
         actOnSleep5(Agent)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',185).

 /*  axiom(actOnSleep5(Agent),
       [ lieOn(Agent, Bed),
         some(Exists_Room, '$kolem_Fn_92'(Agent, Bed, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',185).

 /*  (   lieOn(Kolem_Fn_92P_Num3_V17, Lieon15),
       some(_,
            '$kolem_Fn_92'(Kolem_Fn_92P_Num3_V17,
                           Lieon15,
                           Kolem_Fn_9216))
   ->  actOnSleep5(Kolem_Fn_92P_Num3_V17)
   ).
 */
if lieOn(Kolem_Fn_92P_Num3_V17, Lieon15), some(_, '$kolem_Fn_92'(Kolem_Fn_92P_Num3_V17, Lieon15, Kolem_Fn_9216))then actOnSleep5(Kolem_Fn_92P_Num3_V17).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',185).

 /*  reactive_rule([ happens(lieOn(Kolem_Fn_92P_Num3_V17,
   			      Lieon15),
   			Time_From18,
   			Time_Until19),
   		some(_,
   		     '$kolem_Fn_92'(Kolem_Fn_92P_Num3_V17,
   				    Lieon15,
   				    Kolem_Fn_9216))
   	      ],
   	      [ holds(actOnSleep5(Kolem_Fn_92P_Num3_V17),
   		      Holds20)
   	      ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',185).

 /*  holds_at(at(Agent, Exists_Room), Time) :-
       happens(lieOn(Agent, Bed), Time),
       some(Exists_Room, '$kolem_Fn_92'(Agent, Bed, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',185).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Agent, Exists_Room), Time),
          (->),
         at(Agent, Exists_Room)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',185).

 /*  axiom(at(Agent, Exists_Room),
       [ lieOn(Agent, Bed),
         some(Exists_Room, '$kolem_Fn_92'(Agent, Bed, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',185).

 /*  (   lieOn(Kolem_Fn_92P_Num3_V24, Lieon22),
       some(Tloc21,
            '$kolem_Fn_92'(Kolem_Fn_92P_Num3_V24,
                           Lieon22,
                           Kolem_Fn_9223))
   ->  at(Kolem_Fn_92P_Num3_V24, Tloc21)
   ).
 */
if lieOn(Kolem_Fn_92P_Num3_V24, Lieon22), some(Tloc21, '$kolem_Fn_92'(Kolem_Fn_92P_Num3_V24, Lieon22, Kolem_Fn_9223))then loc_at(Kolem_Fn_92P_Num3_V24, Tloc21).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',185).

 /*  reactive_rule([ happens(lieOn(Kolem_Fn_92P_Num3_V24,
   			      Lieon22),
   			Time_From25,
   			Time_Until26),
   		some(Tloc21,
   		     '$kolem_Fn_92'(Kolem_Fn_92P_Num3_V24,
   				    Lieon22,
   				    Kolem_Fn_9223))
   	      ],
   	      [ holds(loc_at(Kolem_Fn_92P_Num3_V24,Tloc21),
   		      Holds27)
   	      ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',185).

 /*  holds_at(at(Bed, Exists_Room), Time) :-
       happens(lieOn(Agent, Bed), Time),
       some(Exists_Room, '$kolem_Fn_92'(Agent, Bed, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',185).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Bed, Exists_Room), Time),
          (->),
         at(Bed, Exists_Room)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',185).

 /*  axiom(at(Bed, Exists_Room),
       [ lieOn(Agent, Bed),
         some(Exists_Room, '$kolem_Fn_92'(Agent, Bed, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',185).

 /*  (   lieOn(Kolem_Fn_92P_Num3_V31, Lieon29),
       some(Tloc28,
            '$kolem_Fn_92'(Kolem_Fn_92P_Num3_V31,
                           Lieon29,
                           Kolem_Fn_9230))
   ->  at(Lieon29, Tloc28)
   ).
 */
if lieOn(Kolem_Fn_92P_Num3_V31, Lieon29), some(Tloc28, '$kolem_Fn_92'(Kolem_Fn_92P_Num3_V31, Lieon29, Kolem_Fn_9230))then loc_at(Lieon29, Tloc28).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',185).

 /*  reactive_rule([ happens(lieOn(Kolem_Fn_92P_Num3_V31,
   			      Lieon29),
   			Time_From32,
   			Time_Until33),
   		some(Tloc28,
   		     '$kolem_Fn_92'(Kolem_Fn_92P_Num3_V31,
   				    Lieon29,
   				    Kolem_Fn_9230))
   	      ],
   	      [holds(loc_at(Lieon29,Tloc28),Holds34)]).
 */


%; (body) posture
%; agent lies on physobj.

% event LieOn(agent,physobj)
 %  event(lieOn(agent,physobj)).
 %  event(lieOn(agent,physobj)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',191).
actions([lieOn/2]).
mpred_prop(lieOn(agent,physobj),event).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',194).
%; agent sits on physobj.

% event SitOn(agent,physobj)
 %  event(sitOn(agent,physobj)).
 %  event(sitOn(agent,physobj)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',194).
actions([sitOn/2]).
mpred_prop(sitOn(agent,physobj),event).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',197).
% [agent,physobj,time]
% Happens(SitOn(agent,physobj),time) ->
% {location}% 
%  HoldsAt(At(agent,location),time) &
%  HoldsAt(At(physobj,location),time).
 %  clausify_pnf=exists([Location],  (happens(sitOn(Agent, Physobj), Time)->holds_at(at(Agent, Location), Time), holds_at(at(Physobj, Location), Time))).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',199).

 /*  not(happens(sitOn(Agent, Physobj), Time)) :-
       (   not(holds_at(at(Agent, Exists_Location), Time))
       ;   not(holds_at(at(Physobj, Exists_Location), Time))
       ),
       some(Exists_Location,
            '$kolem_Fn_93'(Agent, Physobj, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',199).

 /*  fix_axiom_head(Time) ->
       [ not(happens(sitOn(Agent, Physobj), Time)),
          (->),
         not(sitOn(Agent, Physobj))
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',199).

 /*  axiom(not(sitOn(Agent, Physobj)),
       [  (not(at(Agent, Exists_Location));not(at(Physobj, Exists_Location))),
         some(Exists_Location,
              '$kolem_Fn_93'(Agent, Physobj, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',199).

 /*  (   (   not(at(Kolem_Fn_93P_Num3_V, Tloc))
       ;   not(at(Siton, Tloc))
       ),
       some(Tloc,
            '$kolem_Fn_93'(Kolem_Fn_93P_Num3_V, Siton, Kolem_Fn_93))
   ->  not(sitOn(Kolem_Fn_93P_Num3_V, Siton))
   ).
 */
if (not loc_at(Kolem_Fn_93P_Num3_V, Tloc);not loc_at(Siton, Tloc)), some(Tloc, '$kolem_Fn_93'(Kolem_Fn_93P_Num3_V, Siton, Kolem_Fn_93))then not sitOn(Kolem_Fn_93P_Num3_V, Siton).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',199).

 /*   reactive_rule([  (not(loc_at(Kolem_Fn_93P_Num3_V, Tloc));not(loc_at(Siton, Tloc))),
                      some(Tloc,
                           '$kolem_Fn_93'(Kolem_Fn_93P_Num3_V,
                                          Siton,
                                          Kolem_Fn_93))
                    ],
                    [not(sitOn(Kolem_Fn_93P_Num3_V, Siton))]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',199).

 /*  holds_at(at(Agent, Exists_Location), Time) :-
       happens(sitOn(Agent, Physobj), Time),
       some(Exists_Location,
            '$kolem_Fn_93'(Agent, Physobj, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',199).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Agent, Exists_Location), Time),
          (->),
         at(Agent, Exists_Location)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',199).

 /*  axiom(at(Agent, Exists_Location),
       [ sitOn(Agent, Physobj),
         some(Exists_Location,
              '$kolem_Fn_93'(Agent, Physobj, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',199).

 /*  (   sitOn(Kolem_Fn_93P_Num3_V12, Siton10),
       some(Tloc9,
            '$kolem_Fn_93'(Kolem_Fn_93P_Num3_V12,
                           Siton10,
                           Kolem_Fn_9311))
   ->  at(Kolem_Fn_93P_Num3_V12, Tloc9)
   ).
 */
if sitOn(Kolem_Fn_93P_Num3_V12, Siton10), some(Tloc9, '$kolem_Fn_93'(Kolem_Fn_93P_Num3_V12, Siton10, Kolem_Fn_9311))then loc_at(Kolem_Fn_93P_Num3_V12, Tloc9).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',199).

 /*  reactive_rule([ happens(sitOn(Kolem_Fn_93P_Num3_V12,
   			      Siton10),
   			Time_From,
   			Time_Until),
   		some(Tloc9,
   		     '$kolem_Fn_93'(Kolem_Fn_93P_Num3_V12,
   				    Siton10,
   				    Kolem_Fn_9311))
   	      ],
   	      [ holds(loc_at(Kolem_Fn_93P_Num3_V12,Tloc9),
   		      Holds)
   	      ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',199).

 /*  holds_at(at(Physobj, Exists_Location), Time) :-
       happens(sitOn(Agent, Physobj), Time),
       some(Exists_Location,
            '$kolem_Fn_93'(Agent, Physobj, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',199).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Physobj, Exists_Location), Time),
          (->),
         at(Physobj, Exists_Location)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',199).

 /*  axiom(at(Physobj, Exists_Location),
       [ sitOn(Agent, Physobj),
         some(Exists_Location,
              '$kolem_Fn_93'(Agent, Physobj, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',199).

 /*  (   sitOn(Kolem_Fn_93P_Num3_V19, Siton17),
       some(Tloc16,
            '$kolem_Fn_93'(Kolem_Fn_93P_Num3_V19,
                           Siton17,
                           Kolem_Fn_9318))
   ->  at(Siton17, Tloc16)
   ).
 */
if sitOn(Kolem_Fn_93P_Num3_V19, Siton17), some(Tloc16, '$kolem_Fn_93'(Kolem_Fn_93P_Num3_V19, Siton17, Kolem_Fn_9318))then loc_at(Siton17, Tloc16).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',199).

 /*  reactive_rule([ happens(sitOn(Kolem_Fn_93P_Num3_V19,
   			      Siton17),
   			Time_From20,
   			Time_Until21),
   		some(Tloc16,
   		     '$kolem_Fn_93'(Kolem_Fn_93P_Num3_V19,
   				    Siton17,
   				    Kolem_Fn_9318))
   	      ],
   	      [holds(loc_at(Siton17,Tloc16),Holds22)]).
 */


%; agent rises from physobj.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',204).
% event RiseFrom(agent,physobj)
 %  event(riseFrom(agent,physobj)).
 %  event(riseFrom(agent,physobj)).
actions([riseFrom/2]).
mpred_prop(riseFrom(agent,physobj),event).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',206).
%; agent is lying on physobj.

% fluent LyingOn(agent,physobj)
 %  fluent(lyingOn(agent,physobj)).
 %  fluent(lyingOn(agent,physobj)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',206).
fluents([lyingOn/2]).
mpred_prop(lyingOn(agent,physobj),fluent).


%; agent is sitting on physobj.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',209).
% fluent SittingOn(agent,physobj)
 %  fluent(sittingOn(agent,physobj)).
 %  fluent(sittingOn(agent,physobj)).
fluents([sittingOn/2]).
mpred_prop(sittingOn(agent,physobj),fluent).


%; agent is standing.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',211).
% fluent Standing(agent)
 %  fluent(standing(agent)).
 %  fluent(standing(agent)).
fluents([standing/1]).
mpred_prop(standing(agent),fluent).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',213).
%; agent is lying down.

% fluent Lying(agent)
 %  fluent(lying(agent)).
 %  fluent(lying(agent)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',213).
fluents([lying/1]).
mpred_prop(lying(agent),fluent).


%; agent is sitting.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',216).
% fluent Sitting(agent)
 %  fluent(sitting(agent)).
 %  fluent(sitting(agent)).
fluents([sitting/1]).
mpred_prop(sitting(agent),fluent).

% noninertial Lying
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',216).
noninertial(lying).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',218).
% noninertial Sitting
noninertial(sitting).
%; At any time, an agent is either lying, sitting, or standing:

% xor Lying, Sitting, Standing
 %  ==>xor[lying,sitting,standing].
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',220).
==>xor[lying,sitting,standing].


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',223).
% [agent,physobj,time]
% HoldsAt(LyingOn(agent,physobj),time) ->
% HoldsAt(Lying(agent),time).

 /*  holds_at(lyingOn(Agent, Physobj), Time) ->
       holds_at(lying(Agent), Time).
 */
if lyingOn(Agent, Physobj)at Time then lying(Agent)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',223).

 /*  reactive_rule([holds(lyingOn(Agent,Physobj),Time)],
   	      [holds(lying(Agent),Time)]).
 */


% [agent,physobj,time]
% HoldsAt(SittingOn(agent,physobj),time) ->
% HoldsAt(Sitting(agent),time).

 /*  holds_at(sittingOn(Agent, Physobj), Time) ->
       holds_at(sitting(Agent), Time).
 */
if sittingOn(Agent, Physobj)at Time then sitting(Agent)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',228).

 /*  reactive_rule([holds(sittingOn(Agent,Physobj),Time)],
   	      [holds(sitting(Agent),Time)]).
 */


%; State constraints represent that an agent can lie or sit
%; on at most one object at a time:
% [agent,physobj1,physobj2,time]
% HoldsAt(LyingOn(agent,physobj1),time) &
% HoldsAt(LyingOn(agent,physobj2),time) ->
% physobj1=physobj2.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',233).

 /*  (   holds_at(lyingOn(Agent, Physobj1), Time),
       holds_at(lyingOn(Agent, Physobj2), Time)
   ->  equals(Physobj1, Physobj2)
   ).
 */
if lyingOn(Agent, Physobj1)at Time, lyingOn(Agent, Physobj2)at Time then equals(Physobj1, Physobj2).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',233).

 /*  reactive_rule([ holds(lyingOn(Agent,Physobj1),Time),
   		holds(lyingOn(Agent,Physobj2),Time)
   	      ],
   	      [equals(Physobj1,Physobj2)]).
 */


% [agent,physobj1,physobj2,time]
% HoldsAt(SittingOn(agent,physobj1),time) &
% HoldsAt(SittingOn(agent,physobj2),time) ->
% physobj1=physobj2.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',239).

 /*  (   holds_at(sittingOn(Agent, Physobj1), Time),
       holds_at(sittingOn(Agent, Physobj2), Time)
   ->  equals(Physobj1, Physobj2)
   ).
 */
if sittingOn(Agent, Physobj1)at Time, sittingOn(Agent, Physobj2)at Time then equals(Physobj1, Physobj2).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',239).

 /*  reactive_rule([ holds(sittingOn(Agent,Physobj1),Time),
   		holds(sittingOn(Agent,Physobj2),Time)
   	      ],
   	      [equals(Physobj1,Physobj2)]).
 */


%; An effect axiom states that if an agent is standing and
%; lies on a physical object, the agent will be lying on
%; the physical object:
% [agent,physobj,time]
% HoldsAt(Standing(agent),time) ->
% Initiates(LieOn(agent,physobj),
%           LyingOn(agent,physobj),
%           time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',246).

 /*  axiom(initiates(lieOn(Agent, Physobj), lyingOn(Agent, Physobj), Time),
       [standing(Agent)]).
 */

 /*  standing(Standing) ->
       initiates(lieOn(Standing, Lieon),
                 lyingOn(Standing, Lieon),
                 Initiates).
 */
if standing(Standing)then initiates(lieOn(Standing, Lieon), lyingOn(Standing, Lieon)at Initiates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',246).

 /*  reactive_rule([holds(standing(Standing),Holds)],
   	      [ initiates(lieOn(Standing,Lieon),
   			  at(lyingOn(Standing,Lieon),
   			     Initiates),
   			  Initiates7)
   	      ]).
 */


%; An effect axiom states that if an agent
%; lies on a physical object, the agent will no longer
%; be standing:
% [agent,physobj,time]
% Terminates(LieOn(agent,physobj),
%            Standing(agent),
%            time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',255).

 /*  axiom(terminates(lieOn(Agent, Physobj), standing(Agent), Time),
       []).
 */

 /*  terminates(lieOn(Standing,Lieon),
   	   standing(Standing),
   	   Terminates).
 */
lieOn(Standing, Lieon)terminates standing(Standing).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',255).

 /*  terminated(happens(lieOn(Standing,Lieon),
   		   Time_From,
   		   Time_Until),
   	   standing(Standing),
   	   []).
 */


%; An effect axiom states that if an agent is standing and
%; sits on a physical object, the agent will be sitting on
%; the physical object:
% [agent,physobj,time]
% HoldsAt(Standing(agent),time) ->
% Initiates(SitOn(agent,physobj),
%           SittingOn(agent,physobj),
%           time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',263).

 /*  axiom(initiates(sitOn(Agent, Physobj), sittingOn(Agent, Physobj), Time),
       [standing(Agent)]).
 */

 /*  standing(Standing) ->
       initiates(sitOn(Standing, Siton),
                 sittingOn(Standing, Siton),
                 Initiates).
 */
if standing(Standing)then initiates(sitOn(Standing, Siton), sittingOn(Standing, Siton)at Initiates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',263).

 /*  reactive_rule([holds(standing(Standing),Holds)],
   	      [ initiates(sitOn(Standing,Siton),
   			  at(sittingOn(Standing,Siton),
   			     Initiates),
   			  Initiates7)
   	      ]).
 */


%; An effect axiom states that if an agent
%; sits on a physical object, the agent will no longer
%; be standing:
% [agent,physobj,time]
% Terminates(SitOn(agent,physobj),
%            Standing(agent),
%            time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',272).

 /*  axiom(terminates(sitOn(Agent, Physobj), standing(Agent), Time),
       []).
 */

 /*  terminates(sitOn(Standing,Siton),
   	   standing(Standing),
   	   Terminates).
 */
sitOn(Standing, Siton)terminates standing(Standing).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',272).

 /*  terminated(happens(sitOn(Standing,Siton),
   		   Time_From,
   		   Time_Until),
   	   standing(Standing),
   	   []).
 */


%; An effect axiom states that if an agent
%; is sitting or lying on a physical object and
%; the agent rises from the physical object,
%; the agent will be standing:
% [agent,physobj,time]
% (HoldsAt(SittingOn(agent,physobj),time) |
%  HoldsAt(LyingOn(agent,physobj),time)) ->
% Initiates(RiseFrom(agent,physobj),
%           Standing(agent),
%           time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',281).

 /*  axiom(initiates(riseFrom(Agent, Physobj), standing(Agent), Time),
       [  (sittingOn(Agent, Physobj);lyingOn(Agent, Physobj))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',281).

 /*  sittingOn(Standing, Sittingon);lyingOn(Standing, Sittingon) ->
       initiates(riseFrom(Standing, Sittingon),
                 standing(Standing),
                 Initiates).
 */
if sittingOn(Standing, Sittingon);lyingOn(Standing, Sittingon)then initiates(riseFrom(Standing, Sittingon), standing(Standing)at Initiates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',281).

 /*   reactive_rule([  (sittingOn(Standing, Sittingon);lyingOn(Standing, Sittingon))
                    ],
                    [ initiates(riseFrom(Standing, Sittingon),
                                at(standing(Standing), Initiates),
                                Initiates6)
                    ]).
 */


%; An effect axiom states that if an agent is sitting on
%; a physical object and the agent rises from the physical
%; object, the agent will no longer be sitting on the
%; physical object:
% [agent,physobj,time]
% HoldsAt(SittingOn(agent,physobj),time) ->
% Terminates(RiseFrom(agent,physobj),
%            SittingOn(agent,physobj),
%            time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',292).

 /*  axiom(terminates(riseFrom(Agent, Physobj), sittingOn(Agent, Physobj), Time),
       [sittingOn(Agent, Physobj)]).
 */

 /*  sittingOn(A, Sittingon) ->
       terminates(riseFrom(A, Sittingon),
                  sittingOn(A, Sittingon),
                  Terminates).
 */
if sittingOn(A, Sittingon)then terminates(riseFrom(A, Sittingon), sittingOn(A, Sittingon)at Terminates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',292).

 /*  reactive_rule([holds(sittingOn(A,Sittingon),Holds)],
   	      [ terminates(riseFrom(A,Sittingon),
   			   at(sittingOn(A,Sittingon),
   			      Terminates),
   			   Terminates6)
   	      ]).
 */


%; An effect axiom states that if an agent is lying on
%; a physical object and the agent rises from the physical
%; object, the agent will no longer be lying on the
%; physical object:
% [agent,physobj,time]
% HoldsAt(LyingOn(agent,physobj),time) ->
% Terminates(RiseFrom(agent,physobj),
%            LyingOn(agent,physobj),
%            time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',302).

 /*  axiom(terminates(riseFrom(Agent, Physobj), lyingOn(Agent, Physobj), Time),
       [lyingOn(Agent, Physobj)]).
 */

 /*  lyingOn(A, Lyingon) ->
       terminates(riseFrom(A, Lyingon),
                  lyingOn(A, Lyingon),
                  Terminates).
 */
if lyingOn(A, Lyingon)then terminates(riseFrom(A, Lyingon), lyingOn(A, Lyingon)at Terminates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',302).

 /*  reactive_rule([holds(lyingOn(A,Lyingon),Holds)],
   	      [ terminates(riseFrom(A,Lyingon),
   			   at(lyingOn(A,Lyingon),
   			      Terminates),
   			   Terminates6)
   	      ]).
 */


%; dressing
%; agent gets undressed.

% event GetDressed(agent)
 %  event(getDressed(agent)).
 %  event(getDressed(agent)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',310).
actions([getDressed/1]).
mpred_prop(getDressed(agent),event).


%; agent gets dressed.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',313).
% event GetUndressed(agent)
 %  event(getUndressed(agent)).
 %  event(getUndressed(agent)).
actions([getUndressed/1]).
mpred_prop(getUndressed(agent),event).


%; agent is dressed.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',315).
% fluent Dressed(agent)
 %  fluent(dressed(agent)).
 %  fluent(dressed(agent)).
fluents([dressed/1]).
mpred_prop(dressed(agent),fluent).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',317).
%; Effect axioms deal with getting dressed and undressed:
% [agent,time]
 % Initiates(GetDressed(agent),Dressed(agent),time).

 /*  axiom(initiates(getDressed(Agent), dressed(Agent), Time),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',317).

 /*  initiates(getDressed(Getdressed),
   	  dressed(Getdressed),
   	  Initiates).
 */
getDressed(Getdressed)initiates dressed(Getdressed).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',317).

 /*  initiated(happens(getDressed(Getdressed),
   		  Time_From,
   		  Time_Until),
   	  dressed(Getdressed),
   	  []).
 */


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',319).
% [agent,time]
 % Terminates(GetUndressed(agent),Dressed(agent),time).

 /*  axiom(terminates(getUndressed(Agent), dressed(Agent), Time),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',319).

 /*  terminates(getUndressed(Getundressed),
   	   dressed(Getundressed),
   	   Terminates).
 */
getUndressed(Getundressed)terminates dressed(Getundressed).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',319).

 /*  terminated(happens(getUndressed(Getundressed),
   		   Time_From,
   		   Time_Until),
   	   dressed(Getundressed),
   	   []).
 */


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Sleep.e',321).
%; End of file.
:- endif.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',49).
% load answers/Mueller2003/SpeechAct.e
:- if(is_e_toplevel).
:- cond_convert_e(changed, 'answers/Mueller2003/SpeechAct.e').
 %  loading(changed,'/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e').
%;
%; Copyright (c) 2005 IBM Corporation and others.
%; All rights reserved. This program and the accompanying materials
%; are made available under the terms of the Common Public License v1.0
%; which accompanies this distribution, and is available at
%; http://www.eclipse.org/legal/cpl-v10.html
%;
%; Contributors:
%; IBM - Initial implementation
%;
%; The SpeechAct representation deals with a few speech acts
%; \fullcite{Searle:1969}.
%;
%; @book{Searle:1969,
%;   author = "John R. Searle",
%;   year = "1969",
%;   title = "Speech Acts: An Essay in the Philosophy of Language",
%;   address = "Cambridge",
%;   publisher = "Cambridge University Press",
%; }
%;
%; We handle
%; the illocutionary acts of
%; inviting someone into one's house (a form of request) and
%; greeting someone,
%; and the expressive speech act of crying for joy.
%;
%; inviting in
%; agent1 invites agent2 into room.

% event InviteIn(agent,agent,room)
 %  event(inviteIn(agent,agent,room)).
 %  event(inviteIn(agent,agent,room)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',31).
actions([inviteIn/3]).
mpred_prop(inviteIn(agent,agent,room),event).


%; agent1 is invited into room by agent2.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',34).
% fluent InvitedIn(agent,room,agent)
 %  fluent(invitedIn(agent,room,agent)).
 %  fluent(invitedIn(agent,room,agent)).
fluents([invitedIn/3]).
mpred_prop(invitedIn(agent,room,agent),fluent).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',36).
%; A precondition axiom states that for
%; an agent to invite another agent into a room,
%; the first agent must be in the room and
%; there must be an outside area such that
%; the second agent is at the outside area and
%; the outside area is adjacent to the room:
% [agent1,agent2,room,time]
% Happens(InviteIn(agent1,agent2,room),time) ->
% HoldsAt(At(agent1,room),time) &
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',42).
% {outside}% 
% HoldsAt(At(agent2,outside),time) &
% Adjacent(room,outside).
 %  clausify_pnf=exists([Outside],  (happens(inviteIn(Agent1, Agent2, Room), Time)->holds_at(at(Agent1, Room), Time), holds_at(at(Agent2, Outside), Time), adjacent(Room, Outside))).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',45).

 /*  not(happens(inviteIn(Agent1, Agent2, Room), Time)) :-
       (   not(holds_at(at(Agent1, Room), Time))
       ;   not(holds_at(at(Agent2, Exists_Outside), Time))
       ;   not(adjacent(Room, Exists_Outside))
       ),
       some(Exists_Outside,
            '$kolem_Fn_94'(Agent1, Agent2, Room, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',45).

 /*  fix_axiom_head(Time) ->
       [ not(happens(inviteIn(Agent1, Agent2, Room), Time)),
          (->),
         not(inviteIn(Agent1, Agent2, Room))
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',45).

 /*  axiom(not(inviteIn(Agent1, Agent2, Room)),
       [  (not(at(Agent1, Room));not(at(Agent2, Exists_Outside));not(adjacent(Room, Exists_Outside))),
         some(Exists_Outside,
              '$kolem_Fn_94'(Agent1, Agent2, Room, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',45).

 /*  (   (   not(at(Kolem_Fn_94P_Num4_V, Tloc))
       ;   not(at(A, Tloc7))
       ;   not(adjacent(Tloc, Tloc7))
       ),
       some(Tloc7,
            '$kolem_Fn_94'(Kolem_Fn_94P_Num4_V,
                           A,
                           Tloc,
                           Kolem_Fn_94))
   ->  not(inviteIn(Kolem_Fn_94P_Num4_V, A, Tloc))
   ).
 */
if (not loc_at(Kolem_Fn_94P_Num4_V, Tloc);not loc_at(A, Tloc7);not adjacent(Tloc, Tloc7)), some(Tloc7, '$kolem_Fn_94'(Kolem_Fn_94P_Num4_V, A, Tloc, Kolem_Fn_94))then not inviteIn(Kolem_Fn_94P_Num4_V, A, Tloc).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',45).

 /*   reactive_rule([  (not(loc_at(Kolem_Fn_94P_Num4_V, Tloc));not(loc_at(A, Tloc7));not(adjacent(Tloc, Tloc7))),
                      some(Tloc7,
                           '$kolem_Fn_94'(Kolem_Fn_94P_Num4_V,
                                          A,
                                          Tloc,
                                          Kolem_Fn_94))
                    ],
                    [not(inviteIn(Kolem_Fn_94P_Num4_V, A, Tloc))]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',45).

 /*  holds_at(at(Agent1, Room), Time) :-
       happens(inviteIn(Agent1, Agent2, Room), Time),
       some(Exists_Outside,
            '$kolem_Fn_94'(Agent1, Agent2, Room, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',45).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Agent1, Room), Time),
          (->),
         at(Agent1, Room)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',45).

 /*  axiom(at(Agent1, Room),
       [ inviteIn(Agent1, Agent2, Room),
         some(Exists_Outside,
              '$kolem_Fn_94'(Agent1, Agent2, Room, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',45).

 /*  (   inviteIn(InviteinP_Num3_V, A, Tloc10),
       some(_,
            '$kolem_Fn_94'(InviteinP_Num3_V,
                           A,
                           Tloc10,
                           Kolem_Fn_9412))
   ->  at(InviteinP_Num3_V, Tloc10)
   ).
 */
if inviteIn(InviteinP_Num3_V, A, Tloc10), some(_, '$kolem_Fn_94'(InviteinP_Num3_V, A, Tloc10, Kolem_Fn_9412))then loc_at(InviteinP_Num3_V, Tloc10).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',45).

 /*  reactive_rule([ happens(inviteIn(InviteinP_Num3_V,
   				 A,
   				 Tloc10),
   			Time_From,
   			Time_Until),
   		some(_,
   		     '$kolem_Fn_94'(InviteinP_Num3_V,
   				    A,
   				    Tloc10,
   				    Kolem_Fn_9412))
   	      ],
   	      [ holds(loc_at(InviteinP_Num3_V,Tloc10),
   		      Holds)
   	      ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',45).

 /*  holds_at(at(Agent2, Exists_Outside), Time) :-
       happens(inviteIn(Agent1, Agent2, Room), Time),
       some(Exists_Outside,
            '$kolem_Fn_94'(Agent1, Agent2, Room, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',45).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Agent2, Exists_Outside), Time),
          (->),
         at(Agent2, Exists_Outside)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',45).

 /*  axiom(at(Agent2, Exists_Outside),
       [ inviteIn(Agent1, Agent2, Room),
         some(Exists_Outside,
              '$kolem_Fn_94'(Agent1, Agent2, Room, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',45).

 /*  (   inviteIn(InviteinP_Num3_V18, A, Invitein),
       some(Tloc16,
            '$kolem_Fn_94'(InviteinP_Num3_V18,
                           A,
                           Invitein,
                           Kolem_Fn_9419))
   ->  at(A, Tloc16)
   ).
 */
if inviteIn(InviteinP_Num3_V18, A, Invitein), some(Tloc16, '$kolem_Fn_94'(InviteinP_Num3_V18, A, Invitein, Kolem_Fn_9419))then loc_at(A, Tloc16).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',45).

 /*  reactive_rule([ happens(inviteIn(InviteinP_Num3_V18,
   				 A,
   				 Invitein),
   			Time_From20,
   			Time_Until21),
   		some(Tloc16,
   		     '$kolem_Fn_94'(InviteinP_Num3_V18,
   				    A,
   				    Invitein,
   				    Kolem_Fn_9419))
   	      ],
   	      [holds(loc_at(A,Tloc16),Holds22)]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',45).

 /*  adjacent(Room, Exists_Outside) :-
       happens(inviteIn(Agent1, Agent2, Room), Time),
       some(Exists_Outside,
            '$kolem_Fn_94'(Agent1, Agent2, Room, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',45).

 /*  fix_axiom_head(Time) ->
       [ happens(inviteIn(Agent1, Agent2, Room), Time),
          (->),
         inviteIn(Agent1, Agent2, Room)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',45).

 /*  axiom(adjacent(Room, Exists_Outside),
       [ inviteIn(Agent1, Agent2, Room),
         some(Exists_Outside,
              '$kolem_Fn_94'(Agent1, Agent2, Room, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',45).

 /*  (   inviteIn(InviteinP_Num3_V24, A, Invitein23),
       some(Adjacent,
            '$kolem_Fn_94'(InviteinP_Num3_V24,
                           A,
                           Invitein23,
                           Kolem_Fn_9425))
   ->  adjacent(Invitein23, Adjacent)
   ).
 */
if inviteIn(InviteinP_Num3_V24, A, Invitein23), some(Adjacent, '$kolem_Fn_94'(InviteinP_Num3_V24, A, Invitein23, Kolem_Fn_9425))then adjacent(Invitein23, Adjacent).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',45).

 /*  reactive_rule([ happens(inviteIn(InviteinP_Num3_V24,
   				 A,
   				 Invitein23),
   			Time_From27,
   			Time_Until28),
   		some(Adjacent,
   		     '$kolem_Fn_94'(InviteinP_Num3_V24,
   				    A,
   				    Invitein23,
   				    Kolem_Fn_9425))
   	      ],
   	      [adjacent(Invitein23,Adjacent)]).
 */


%; An effect axiom states that if
%; an agent invites another agent into a room,
%; the second agent will be invited into the room by the first agent:
% [agent1,agent2,room,time]
% Initiates(InviteIn(agent1,agent2,room),
%           InvitedIn(agent2,room,agent1),
%           time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',52).

 /*  axiom(initiates(inviteIn(Agent1, Agent2, Room), invitedIn(Agent2, Room, Agent1), Time),
       []).
 */

 /*  initiates(inviteIn(InviteinP_Num3_V,
   		   InvitedinP_Num3_V,
   		   Invitein),
   	  invitedIn(InvitedinP_Num3_V,
   		    Invitein,
   		    InviteinP_Num3_V),
   	  Initiates).
 */
inviteIn(InviteinP_Num3_V, InvitedinP_Num3_V, Invitein)initiates invitedIn(InvitedinP_Num3_V, Invitein, InviteinP_Num3_V).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',52).

 /*  initiated(happens(inviteIn(InviteinP_Num3_V,
   			   InvitedinP_Num3_V,
   			   Invitein),
   		  Time_From,
   		  Time_Until),
   	  invitedIn(InvitedinP_Num3_V,
   		    Invitein,
   		    InviteinP_Num3_V),
   	  []).
 */


%; agent intends to walk into room.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',58).
% event IntendToWalkIn(agent,room)
 %  event(intendToWalkIn(agent,room)).
 %  event(intendToWalkIn(agent,room)).
actions([intendToWalkIn/2]).
mpred_prop(intendToWalkIn(agent,room),event).


%; agent has the intention to walk into room.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',60).
% fluent IntentionToWalkIn(agent,room)
 %  fluent(intentionToWalkIn(agent,room)).
 %  fluent(intentionToWalkIn(agent,room)).
fluents([intentionToWalkIn/2]).
mpred_prop(intentionToWalkIn(agent,room),fluent).


%; agent acts on the intention to walk into room.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',62).
% fluent ActOnIntentionToWalkIn(agent,room)
 %  fluent(actOnIntentionToWalkIn(agent,room)).
 %  fluent(actOnIntentionToWalkIn(agent,room)).
fluents([actOnIntentionToWalkIn/2]).
mpred_prop(actOnIntentionToWalkIn(agent,room),fluent).

% noninertial ActOnIntentionToWalkIn
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',62).
noninertial(actOnIntentionToWalkIn).
%; A trigger axiom states that
%; if an agent is invited into a room by another agent,
%; the first agent likes the second agent, and
%; the first agent does not already have the intention to
%; walk into the room,
%; the first agent intends to walk into the room:
% [agent1,agent2,room,time]
% HoldsAt(InvitedIn(agent1,room,agent2),time) &
% HoldsAt(Like(agent1,agent2),time) &
% !HoldsAt(IntentionToWalkIn(agent1,room),time) ->
% Happens(IntendToWalkIn(agent1,room),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',71).

 /*  (   holds_at(invitedIn(Agent1, Room, Agent2), Time),
       holds_at(like(Agent1, Agent2), Time),
       holds_at(neg(intentionToWalkIn(Agent1, Room)), Time)
   ->  happens(intendToWalkIn(Agent1, Room), Time)
   ).
 */
if invitedIn(Agent1, Room, Agent2)at Time, like(Agent1, Agent2)at Time, not intentionToWalkIn(Agent1, Room)at Time then happens(intendToWalkIn(Agent1, Room), Time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',71).

 /*  reactive_rule([ holds(invitedIn(Agent1,Room,Agent2),
   		      Time),
   		holds(like(Agent1,Agent2),Time),
   		holds(not(intentionToWalkIn(Agent1,Room)),
   		      Time)
   	      ],
   	      [ happens(intendToWalkIn(Agent1,Room),
   			Time)
   	      ]).
 */


%; An effect axiom states that
%; if an agent intends to walk into a room,
%; the agent will have the intention to walk into the room:
% [agent,room,time]
% Initiates(IntendToWalkIn(agent,room),
%           IntentionToWalkIn(agent,room),
%           time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',80).

 /*  axiom(initiates(intendToWalkIn(Agent, Room), intentionToWalkIn(Agent, Room), Time),
       []).
 */

 /*  initiates(intendToWalkIn(A,Intendtowalkin),
   	  intentionToWalkIn(A,Intendtowalkin),
   	  Initiates).
 */
intendToWalkIn(A, Intendtowalkin)initiates intentionToWalkIn(A, Intendtowalkin).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',80).

 /*  initiated(happens(intendToWalkIn(A,Intendtowalkin),
   		  Time_From,
   		  Time_Until),
   	  intentionToWalkIn(A,Intendtowalkin),
   	  []).
 */


%; Two trigger axioms state that
%; if an agent has the intention to walk into a room,
%; the agent acts on the intention to walk into the room,
%; the agent is at a location,
%; side one (two) of a door is the room,
%; side two (one) of the door is the location,
%; agent will walk through side two (one) of the door:
% [agent,room,location,door,time]
% HoldsAt(IntentionToWalkIn(agent,room),time) &
% HoldsAt(ActOnIntentionToWalkIn(agent,room),time) &
% HoldsAt(At(agent,location),time) &
% Side1(door)=room &
% Side2(door)=location ->
% Happens(WalkThroughDoor21(agent,door),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',92).

 /*  (   holds_at(intentionToWalkIn(Agent, Room), Time),
       holds_at(actOnIntentionToWalkIn(Agent, Room), Time),
       holds_at(at(Agent, Location), Time),
       side1Pred(Door, Room),
       side2Pred(Door, Location)
   ->  happens(walkThroughDoor21(Agent, Door), Time)
   ).
 */
if intentionToWalkIn(Agent, Room)at Time, actOnIntentionToWalkIn(Agent, Room)at Time, loc_at(Agent, Location)at Time, side1Pred(Door, Room), side2Pred(Door, Location)then happens(walkThroughDoor21(Agent, Door), Time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',92).

 /*  reactive_rule([ holds(intentionToWalkIn(Agent,Room),
   		      Time),
   		holds(actOnIntentionToWalkIn(Agent,Room),
   		      Time),
   		holds(loc_at(Agent,Location),Time),
   		side1Pred(Door,Room),
   		side2Pred(Door,Location)
   	      ],
   	      [ happens(walkThroughDoor21(Agent,Door),
   			Time)
   	      ]).
 */


% [agent,room,location,door,time]
% HoldsAt(IntentionToWalkIn(agent,room),time) &
% HoldsAt(ActOnIntentionToWalkIn(agent,room),time) &
% HoldsAt(At(agent,location),time) &
% Side2(door)=room &
% Side1(door)=location ->
% Happens(WalkThroughDoor12(agent,door),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',101).

 /*  (   holds_at(intentionToWalkIn(Agent, Room), Time),
       holds_at(actOnIntentionToWalkIn(Agent, Room), Time),
       holds_at(at(Agent, Location), Time),
       side2Pred(Door, Room),
       side1Pred(Door, Location)
   ->  happens(walkThroughDoor12(Agent, Door), Time)
   ).
 */
if intentionToWalkIn(Agent, Room)at Time, actOnIntentionToWalkIn(Agent, Room)at Time, loc_at(Agent, Location)at Time, side2Pred(Door, Room), side1Pred(Door, Location)then happens(walkThroughDoor12(Agent, Door), Time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',101).

 /*  reactive_rule([ holds(intentionToWalkIn(Agent,Room),
   		      Time),
   		holds(actOnIntentionToWalkIn(Agent,Room),
   		      Time),
   		holds(loc_at(Agent,Location),Time),
   		side2Pred(Door,Room),
   		side1Pred(Door,Location)
   	      ],
   	      [ happens(walkThroughDoor12(Agent,Door),
   			Time)
   	      ]).
 */


%; Two effect axioms state that
%; if side one (two) of a door is a room and
%; an agent walks through side two (one) of the door,
%; the agent will no longer have the intention to
%; walk into the room:
% [agent,room,door,time]
% Side1(door)=room ->
% Terminates(WalkThroughDoor21(agent,door),
%            IntentionToWalkIn(agent,room),
%            time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',113).

 /*  axiom(terminates(walkThroughDoor21(Agent, Door), intentionToWalkIn(Agent, Room), Time),
       [side1Pred(Door, Room)]).
 */

 /*  side1Pred(Walkthroughdoor21, Side1pred) ->
       terminates(walkThroughDoor21(A, Walkthroughdoor21),
                  intentionToWalkIn(A, Side1pred),
                  Terminates).
 */
if side1Pred(Walkthroughdoor21, Side1pred)then terminates(walkThroughDoor21(A, Walkthroughdoor21), intentionToWalkIn(A, Side1pred)at Terminates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',113).

 /*  reactive_rule([side1Pred(Walkthroughdoor21,Side1pred)],
   	      [ terminates(walkThroughDoor21(A,
   					     Walkthroughdoor21),
   			   at(intentionToWalkIn(A,
   						Side1pred),
   			      Terminates),
   			   Terminates7)
   	      ]).
 */


% [agent,room,door,time]
% Side2(door)=room ->
% Terminates(WalkThroughDoor12(agent,door),
%            IntentionToWalkIn(agent,room),
%            time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',120).

 /*  axiom(terminates(walkThroughDoor12(Agent, Door), intentionToWalkIn(Agent, Room), Time),
       [side2Pred(Door, Room)]).
 */

 /*  side2Pred(Walkthroughdoor12, Side2pred) ->
       terminates(walkThroughDoor12(A, Walkthroughdoor12),
                  intentionToWalkIn(A, Side2pred),
                  Terminates).
 */
if side2Pred(Walkthroughdoor12, Side2pred)then terminates(walkThroughDoor12(A, Walkthroughdoor12), intentionToWalkIn(A, Side2pred)at Terminates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',120).

 /*  reactive_rule([side2Pred(Walkthroughdoor12,Side2pred)],
   	      [ terminates(walkThroughDoor12(A,
   					     Walkthroughdoor12),
   			   at(intentionToWalkIn(A,
   						Side2pred),
   			      Terminates),
   			   Terminates7)
   	      ]).
 */


%; agent greets object.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',126).
% event Greet(agent,object)
 %  event(greet(agent,object)).
 %  event(greet(agent,object)).
actions([greet/2]).
mpred_prop(greet(agent,object),event).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',128).
% event SayPleasedToMeet(agent,agent)
 %  event(sayPleasedToMeet(agent,agent)).
 %  event(sayPleasedToMeet(agent,agent)).
actions([sayPleasedToMeet/2]).
mpred_prop(sayPleasedToMeet(agent,agent),event).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',130).
%; agent says goodbye to object.

% event SayGoodbye(agent,object)
 %  event(sayGoodbye(agent,object)).
 %  event(sayGoodbye(agent,object)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',130).
actions([sayGoodbye/2]).
mpred_prop(sayGoodbye(agent,object),event).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',133).
% event TalkAbout(agent,content)
 %  event(talkAbout(agent,content)).
 %  event(talkAbout(agent,content)).
actions([talkAbout/2]).
mpred_prop(talkAbout(agent,content),event).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',135).
% event Converse(agent,agent)
 %  event(converse(agent,agent)).
 %  event(converse(agent,agent)).
actions([converse/2]).
mpred_prop(converse(agent,agent),event).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',137).
% [agent1,agent2,time]
% Happens(Converse(agent1,agent2),time) ->
% {location}% 
% HoldsAt(At(agent1,location),time) &
% HoldsAt(At(agent2,location),time).
 %  clausify_pnf=exists([Location],  (happens(converse(Agent1, Agent2), Time)->holds_at(at(Agent1, Location), Time), holds_at(at(Agent2, Location), Time))).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',139).

 /*  not(happens(converse(Agent1, Agent2), Time)) :-
       (   not(holds_at(at(Agent1, Exists_Location), Time))
       ;   not(holds_at(at(Agent2, Exists_Location), Time))
       ),
       some(Exists_Location,
            '$kolem_Fn_95'(Agent1, Agent2, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',139).

 /*  fix_axiom_head(Time) ->
       [ not(happens(converse(Agent1, Agent2), Time)),
          (->),
         not(converse(Agent1, Agent2))
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',139).

 /*  axiom(not(converse(Agent1, Agent2)),
       [  (not(at(Agent1, Exists_Location));not(at(Agent2, Exists_Location))),
         some(Exists_Location,
              '$kolem_Fn_95'(Agent1, Agent2, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',139).

 /*  (   (   not(at(Kolem_Fn_95P_Num3_V, Tloc))
       ;   not(at(Converse, Tloc))
       ),
       some(Tloc,
            '$kolem_Fn_95'(Kolem_Fn_95P_Num3_V,
                           Converse,
                           Kolem_Fn_95))
   ->  not(converse(Kolem_Fn_95P_Num3_V, Converse))
   ).
 */
if (not loc_at(Kolem_Fn_95P_Num3_V, Tloc);not loc_at(Converse, Tloc)), some(Tloc, '$kolem_Fn_95'(Kolem_Fn_95P_Num3_V, Converse, Kolem_Fn_95))then not converse(Kolem_Fn_95P_Num3_V, Converse).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',139).

 /*   reactive_rule([  (not(loc_at(Kolem_Fn_95P_Num3_V, Tloc));not(loc_at(Converse, Tloc))),
                      some(Tloc,
                           '$kolem_Fn_95'(Kolem_Fn_95P_Num3_V,
                                          Converse,
                                          Kolem_Fn_95))
                    ],
                    [not(converse(Kolem_Fn_95P_Num3_V, Converse))]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',139).

 /*  holds_at(at(Agent1, Exists_Location), Time) :-
       happens(converse(Agent1, Agent2), Time),
       some(Exists_Location,
            '$kolem_Fn_95'(Agent1, Agent2, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',139).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Agent1, Exists_Location), Time),
          (->),
         at(Agent1, Exists_Location)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',139).

 /*  axiom(at(Agent1, Exists_Location),
       [ converse(Agent1, Agent2),
         some(Exists_Location,
              '$kolem_Fn_95'(Agent1, Agent2, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',139).

 /*  (   converse(Kolem_Fn_95P_Num3_V12, Converse10),
       some(Tloc9,
            '$kolem_Fn_95'(Kolem_Fn_95P_Num3_V12,
                           Converse10,
                           Kolem_Fn_9511))
   ->  at(Kolem_Fn_95P_Num3_V12, Tloc9)
   ).
 */
if converse(Kolem_Fn_95P_Num3_V12, Converse10), some(Tloc9, '$kolem_Fn_95'(Kolem_Fn_95P_Num3_V12, Converse10, Kolem_Fn_9511))then loc_at(Kolem_Fn_95P_Num3_V12, Tloc9).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',139).

 /*  reactive_rule([ converse(Kolem_Fn_95P_Num3_V12,Converse10),
   		some(Tloc9,
   		     '$kolem_Fn_95'(Kolem_Fn_95P_Num3_V12,
   				    Converse10,
   				    Kolem_Fn_9511))
   	      ],
   	      [ holds(loc_at(Kolem_Fn_95P_Num3_V12,Tloc9),
   		      Holds)
   	      ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',139).

 /*  holds_at(at(Agent2, Exists_Location), Time) :-
       happens(converse(Agent1, Agent2), Time),
       some(Exists_Location,
            '$kolem_Fn_95'(Agent1, Agent2, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',139).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Agent2, Exists_Location), Time),
          (->),
         at(Agent2, Exists_Location)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',139).

 /*  axiom(at(Agent2, Exists_Location),
       [ converse(Agent1, Agent2),
         some(Exists_Location,
              '$kolem_Fn_95'(Agent1, Agent2, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',139).

 /*  (   converse(Kolem_Fn_95P_Num3_V17, Converse15),
       some(Tloc14,
            '$kolem_Fn_95'(Kolem_Fn_95P_Num3_V17,
                           Converse15,
                           Kolem_Fn_9516))
   ->  at(Converse15, Tloc14)
   ).
 */
if converse(Kolem_Fn_95P_Num3_V17, Converse15), some(Tloc14, '$kolem_Fn_95'(Kolem_Fn_95P_Num3_V17, Converse15, Kolem_Fn_9516))then loc_at(Converse15, Tloc14).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',139).

 /*  reactive_rule([ converse(Kolem_Fn_95P_Num3_V17,Converse15),
   		some(Tloc14,
   		     '$kolem_Fn_95'(Kolem_Fn_95P_Num3_V17,
   				    Converse15,
   				    Kolem_Fn_9516))
   	      ],
   	      [ holds(loc_at(Converse15,Tloc14),
   		      Holds18)
   	      ]).
 */


%; A precondition axiom states that for
%; an agent to greet an object,
%; there must be a location such that
%; the agent is at the location and
%; the object is at the location:
% [agent,object,time]
% Happens(Greet(agent,object),time) ->
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',148).
% {location}% 
% HoldsAt(At(agent,location),time) &
% HoldsAt(At(object,location),time).
 %  clausify_pnf=exists([Location],  (happens(greet(Agent, Object), Time)->holds_at(at(Agent, Location), Time), holds_at(at(Object, Location), Time))).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',150).

 /*  not(happens(greet(Agent, Object), Time)) :-
       (   not(holds_at(at(Agent, Exists_Location), Time))
       ;   not(holds_at(at(Object, Exists_Location), Time))
       ),
       some(Exists_Location,
            '$kolem_Fn_96'(Agent, Object, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',150).

 /*  fix_axiom_head(Time) ->
       [ not(happens(greet(Agent, Object), Time)),
          (->),
         not(greet(Agent, Object))
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',150).

 /*  axiom(not(greet(Agent, Object)),
       [  (not(at(Agent, Exists_Location));not(at(Object, Exists_Location))),
         some(Exists_Location,
              '$kolem_Fn_96'(Agent, Object, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',150).

 /*  (   (   not(at(Kolem_Fn_96P_Num3_V, Tloc))
       ;   not(at(Greet, Tloc))
       ),
       some(Tloc,
            '$kolem_Fn_96'(Kolem_Fn_96P_Num3_V, Greet, Kolem_Fn_96))
   ->  not(greet(Kolem_Fn_96P_Num3_V, Greet))
   ).
 */
if (not loc_at(Kolem_Fn_96P_Num3_V, Tloc);not loc_at(Greet, Tloc)), some(Tloc, '$kolem_Fn_96'(Kolem_Fn_96P_Num3_V, Greet, Kolem_Fn_96))then not greet(Kolem_Fn_96P_Num3_V, Greet).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',150).

 /*   reactive_rule([  (not(loc_at(Kolem_Fn_96P_Num3_V, Tloc));not(loc_at(Greet, Tloc))),
                      some(Tloc,
                           '$kolem_Fn_96'(Kolem_Fn_96P_Num3_V,
                                          Greet,
                                          Kolem_Fn_96))
                    ],
                    [not(greet(Kolem_Fn_96P_Num3_V, Greet))]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',150).

 /*  holds_at(at(Agent, Exists_Location), Time) :-
       happens(greet(Agent, Object), Time),
       some(Exists_Location,
            '$kolem_Fn_96'(Agent, Object, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',150).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Agent, Exists_Location), Time),
          (->),
         at(Agent, Exists_Location)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',150).

 /*  axiom(at(Agent, Exists_Location),
       [ greet(Agent, Object),
         some(Exists_Location,
              '$kolem_Fn_96'(Agent, Object, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',150).

 /*  (   greet(Kolem_Fn_96P_Num3_V12, Greet10),
       some(Tloc9,
            '$kolem_Fn_96'(Kolem_Fn_96P_Num3_V12,
                           Greet10,
                           Kolem_Fn_9611))
   ->  at(Kolem_Fn_96P_Num3_V12, Tloc9)
   ).
 */
if greet(Kolem_Fn_96P_Num3_V12, Greet10), some(Tloc9, '$kolem_Fn_96'(Kolem_Fn_96P_Num3_V12, Greet10, Kolem_Fn_9611))then loc_at(Kolem_Fn_96P_Num3_V12, Tloc9).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',150).

 /*  reactive_rule([ greet(Kolem_Fn_96P_Num3_V12,Greet10),
   		some(Tloc9,
   		     '$kolem_Fn_96'(Kolem_Fn_96P_Num3_V12,
   				    Greet10,
   				    Kolem_Fn_9611))
   	      ],
   	      [ holds(loc_at(Kolem_Fn_96P_Num3_V12,Tloc9),
   		      Holds)
   	      ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',150).

 /*  holds_at(at(Object, Exists_Location), Time) :-
       happens(greet(Agent, Object), Time),
       some(Exists_Location,
            '$kolem_Fn_96'(Agent, Object, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',150).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Object, Exists_Location), Time),
          (->),
         at(Object, Exists_Location)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',150).

 /*  axiom(at(Object, Exists_Location),
       [ greet(Agent, Object),
         some(Exists_Location,
              '$kolem_Fn_96'(Agent, Object, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',150).

 /*  (   greet(Kolem_Fn_96P_Num3_V17, Greet15),
       some(Tloc14,
            '$kolem_Fn_96'(Kolem_Fn_96P_Num3_V17,
                           Greet15,
                           Kolem_Fn_9616))
   ->  at(Greet15, Tloc14)
   ).
 */
if greet(Kolem_Fn_96P_Num3_V17, Greet15), some(Tloc14, '$kolem_Fn_96'(Kolem_Fn_96P_Num3_V17, Greet15, Kolem_Fn_9616))then loc_at(Greet15, Tloc14).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',150).

 /*  reactive_rule([ greet(Kolem_Fn_96P_Num3_V17,Greet15),
   		some(Tloc14,
   		     '$kolem_Fn_96'(Kolem_Fn_96P_Num3_V17,
   				    Greet15,
   				    Kolem_Fn_9616))
   	      ],
   	      [holds(loc_at(Greet15,Tloc14),Holds18)]).
 */


% [agent,object,time]
% Happens(SayGoodbye(agent,object),time) ->
% {location}% 
% HoldsAt(At(agent,location),time) &
% HoldsAt(At(object,location),time).
 %  clausify_pnf=exists([Location],  (happens(sayGoodbye(Agent, Object), Time)->holds_at(at(Agent, Location), Time), holds_at(at(Object, Location), Time))).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',155).

 /*  not(happens(sayGoodbye(Agent, Object), Time)) :-
       (   not(holds_at(at(Agent, Exists_Location), Time))
       ;   not(holds_at(at(Object, Exists_Location), Time))
       ),
       some(Exists_Location,
            '$kolem_Fn_97'(Agent, Object, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',155).

 /*  fix_axiom_head(Time) ->
       [ not(happens(sayGoodbye(Agent, Object), Time)),
          (->),
         not(sayGoodbye(Agent, Object))
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',155).

 /*  axiom(not(sayGoodbye(Agent, Object)),
       [  (not(at(Agent, Exists_Location));not(at(Object, Exists_Location))),
         some(Exists_Location,
              '$kolem_Fn_97'(Agent, Object, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',155).

 /*  (   (   not(at(Kolem_Fn_97P_Num3_V, Tloc))
       ;   not(at(Saygoodbye, Tloc))
       ),
       some(Tloc,
            '$kolem_Fn_97'(Kolem_Fn_97P_Num3_V,
                           Saygoodbye,
                           Kolem_Fn_97))
   ->  not(sayGoodbye(Kolem_Fn_97P_Num3_V, Saygoodbye))
   ).
 */
if (not loc_at(Kolem_Fn_97P_Num3_V, Tloc);not loc_at(Saygoodbye, Tloc)), some(Tloc, '$kolem_Fn_97'(Kolem_Fn_97P_Num3_V, Saygoodbye, Kolem_Fn_97))then not sayGoodbye(Kolem_Fn_97P_Num3_V, Saygoodbye).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',155).

 /*   reactive_rule([  (not(loc_at(Kolem_Fn_97P_Num3_V, Tloc));not(loc_at(Saygoodbye, Tloc))),
                      some(Tloc,
                           '$kolem_Fn_97'(Kolem_Fn_97P_Num3_V,
                                          Saygoodbye,
                                          Kolem_Fn_97))
                    ],
                    [not(sayGoodbye(Kolem_Fn_97P_Num3_V, Saygoodbye))]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',155).

 /*  holds_at(at(Agent, Exists_Location), Time) :-
       happens(sayGoodbye(Agent, Object), Time),
       some(Exists_Location,
            '$kolem_Fn_97'(Agent, Object, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',155).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Agent, Exists_Location), Time),
          (->),
         at(Agent, Exists_Location)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',155).

 /*  axiom(at(Agent, Exists_Location),
       [ sayGoodbye(Agent, Object),
         some(Exists_Location,
              '$kolem_Fn_97'(Agent, Object, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',155).

 /*  (   sayGoodbye(Kolem_Fn_97P_Num3_V12, Saygoodbye10),
       some(Tloc9,
            '$kolem_Fn_97'(Kolem_Fn_97P_Num3_V12,
                           Saygoodbye10,
                           Kolem_Fn_9711))
   ->  at(Kolem_Fn_97P_Num3_V12, Tloc9)
   ).
 */
if sayGoodbye(Kolem_Fn_97P_Num3_V12, Saygoodbye10), some(Tloc9, '$kolem_Fn_97'(Kolem_Fn_97P_Num3_V12, Saygoodbye10, Kolem_Fn_9711))then loc_at(Kolem_Fn_97P_Num3_V12, Tloc9).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',155).

 /*  reactive_rule([ sayGoodbye(Kolem_Fn_97P_Num3_V12,
   			   Saygoodbye10),
   		some(Tloc9,
   		     '$kolem_Fn_97'(Kolem_Fn_97P_Num3_V12,
   				    Saygoodbye10,
   				    Kolem_Fn_9711))
   	      ],
   	      [ holds(loc_at(Kolem_Fn_97P_Num3_V12,Tloc9),
   		      Holds)
   	      ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',155).

 /*  holds_at(at(Object, Exists_Location), Time) :-
       happens(sayGoodbye(Agent, Object), Time),
       some(Exists_Location,
            '$kolem_Fn_97'(Agent, Object, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',155).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Object, Exists_Location), Time),
          (->),
         at(Object, Exists_Location)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',155).

 /*  axiom(at(Object, Exists_Location),
       [ sayGoodbye(Agent, Object),
         some(Exists_Location,
              '$kolem_Fn_97'(Agent, Object, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',155).

 /*  (   sayGoodbye(Kolem_Fn_97P_Num3_V17, Saygoodbye15),
       some(Tloc14,
            '$kolem_Fn_97'(Kolem_Fn_97P_Num3_V17,
                           Saygoodbye15,
                           Kolem_Fn_9716))
   ->  at(Saygoodbye15, Tloc14)
   ).
 */
if sayGoodbye(Kolem_Fn_97P_Num3_V17, Saygoodbye15), some(Tloc14, '$kolem_Fn_97'(Kolem_Fn_97P_Num3_V17, Saygoodbye15, Kolem_Fn_9716))then loc_at(Saygoodbye15, Tloc14).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',155).

 /*  reactive_rule([ sayGoodbye(Kolem_Fn_97P_Num3_V17,
   			   Saygoodbye15),
   		some(Tloc14,
   		     '$kolem_Fn_97'(Kolem_Fn_97P_Num3_V17,
   				    Saygoodbye15,
   				    Kolem_Fn_9716))
   	      ],
   	      [ holds(loc_at(Saygoodbye15,Tloc14),
   		      Holds18)
   	      ]).
 */


%; speech: expression of emotions
%; agent cries for joy.

% event CryForJoy(agent)
 %  event(cryForJoy(agent)).
 %  event(cryForJoy(agent)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',162).
actions([cryForJoy/1]).
mpred_prop(cryForJoy(agent),event).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',165).
%; A precondition axiom states that for
%; an agent to cry for joy,
%; the agent must be happy:
% [agent,time]
% Happens(CryForJoy(agent),time) ->
% HoldsAt(Happy(agent),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',168).

 /*  happens(cryForJoy(Agent), Time) ->
       holds_at(happy(Agent), Time).
 */
if happens(cryForJoy(Agent), Time)then happy(Agent)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',168).

 /*  reactive_rule([happens(cryForJoy(Agent),Time)],
   	      [holds(happy(Agent),Time)]).
 */

% event Threaten(agent,agent,weapon)
 %  event(threaten(agent,agent,weapon)).
 %  event(threaten(agent,agent,weapon)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',171).
actions([threaten/3]).
mpred_prop(threaten(agent,agent,weapon),event).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',174).
% event ReleaseFromThreat(agent,agent)
 %  event(releaseFromThreat(agent,agent)).
 %  event(releaseFromThreat(agent,agent)).
actions([releaseFromThreat/2]).
mpred_prop(releaseFromThreat(agent,agent),event).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',176).
% fluent ThreatenedBy(agent,agent)
 %  fluent(threatenedBy(agent,agent)).
 %  fluent(threatenedBy(agent,agent)).
fluents([threatenedBy/2]).
mpred_prop(threatenedBy(agent,agent),fluent).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',178).
% [agent1,agent2,weapon,time]
% Happens(Threaten(agent1,agent2,weapon), time) ->
% HoldsAt(Holding(agent1,weapon),time) &
% {location}% 
% HoldsAt(At(agent1,location),time) &
% HoldsAt(At(agent2,location),time).
 %  clausify_pnf=exists([Location],  (happens(threaten(Agent1, Agent2, Weapon), Time)->holds_at(holding(Agent1, Weapon), Time), holds_at(at(Agent1, Location), Time), holds_at(at(Agent2, Location), Time))).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',181).

 /*  not(happens(threaten(Agent1, Agent2, Weapon), Time)) :-
       (   not(holds_at(holding(Agent1, Weapon), Time))
       ;   not(holds_at(at(Agent1, Exists_Location), Time))
       ;   not(holds_at(at(Agent2, Exists_Location), Time))
       ),
       some(Exists_Location,
            '$kolem_Fn_98'(Agent1, Agent2, Weapon, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',181).

 /*  fix_axiom_head(Time) ->
       [ not(happens(threaten(Agent1, Agent2, Weapon), Time)),
          (->),
         not(threaten(Agent1, Agent2, Weapon))
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',181).

 /*  axiom(not(threaten(Agent1, Agent2, Weapon)),
       [  (not(holding(Agent1, Weapon));not(at(Agent1, Exists_Location));not(at(Agent2, Exists_Location))),
         some(Exists_Location,
              '$kolem_Fn_98'(Agent1, Agent2, Weapon, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',181).

 /*  (   (   not(holding(Kolem_Fn_98P_Num4_V, Holding))
       ;   not(at(Kolem_Fn_98P_Num4_V, Tloc))
       ;   not(at(A, Tloc))
       ),
       some(Tloc,
            '$kolem_Fn_98'(Kolem_Fn_98P_Num4_V,
                           A,
                           Holding,
                           Kolem_Fn_98))
   ->  not(threaten(Kolem_Fn_98P_Num4_V, A, Holding))
   ).
 */
if (not holding(Kolem_Fn_98P_Num4_V, Holding);not loc_at(Kolem_Fn_98P_Num4_V, Tloc);not loc_at(A, Tloc)), some(Tloc, '$kolem_Fn_98'(Kolem_Fn_98P_Num4_V, A, Holding, Kolem_Fn_98))then not threaten(Kolem_Fn_98P_Num4_V, A, Holding).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',181).

 /*   reactive_rule([  (not(holding(Kolem_Fn_98P_Num4_V, Holding));not(loc_at(Kolem_Fn_98P_Num4_V, Tloc));not(loc_at(A, Tloc))),
                      some(Tloc,
                           '$kolem_Fn_98'(Kolem_Fn_98P_Num4_V,
                                          A,
                                          Holding,
                                          Kolem_Fn_98))
                    ],
                    [ not(threaten(Kolem_Fn_98P_Num4_V,
                                   A,
                                   Holding))
                    ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',181).

 /*  holds_at(holding(Agent1, Weapon), Time) :-
       happens(threaten(Agent1, Agent2, Weapon), Time),
       some(Exists_Location,
            '$kolem_Fn_98'(Agent1, Agent2, Weapon, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',181).

 /*  fix_axiom_head(Time) ->
       [ holds_at(holding(Agent1, Weapon), Time),
          (->),
         holding(Agent1, Weapon)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',181).

 /*  axiom(holding(Agent1, Weapon),
       [ threaten(Agent1, Agent2, Weapon),
         some(Exists_Location,
              '$kolem_Fn_98'(Agent1, Agent2, Weapon, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',181).

 /*  (   threaten(ThreatenP_Num3_V, A, Threaten),
       some(_,
            '$kolem_Fn_98'(ThreatenP_Num3_V,
                           A,
                           Threaten,
                           Kolem_Fn_9812))
   ->  holding(ThreatenP_Num3_V, Threaten)
   ).
 */
if threaten(ThreatenP_Num3_V, A, Threaten), some(_, '$kolem_Fn_98'(ThreatenP_Num3_V, A, Threaten, Kolem_Fn_9812))then holding(ThreatenP_Num3_V, Threaten).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',181).

 /*  reactive_rule([ happens(threaten(ThreatenP_Num3_V,
   				 A,
   				 Threaten),
   			Time_From,
   			Time_Until),
   		some(_,
   		     '$kolem_Fn_98'(ThreatenP_Num3_V,
   				    A,
   				    Threaten,
   				    Kolem_Fn_9812))
   	      ],
   	      [ holds(holding(ThreatenP_Num3_V,Threaten),
   		      Holds)
   	      ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',181).

 /*  holds_at(at(Agent1, Exists_Location), Time) :-
       happens(threaten(Agent1, Agent2, Weapon), Time),
       some(Exists_Location,
            '$kolem_Fn_98'(Agent1, Agent2, Weapon, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',181).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Agent1, Exists_Location), Time),
          (->),
         at(Agent1, Exists_Location)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',181).

 /*  axiom(at(Agent1, Exists_Location),
       [ threaten(Agent1, Agent2, Weapon),
         some(Exists_Location,
              '$kolem_Fn_98'(Agent1, Agent2, Weapon, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',181).

 /*  (   threaten(ThreatenP_Num3_V18, A, Threaten17),
       some(Tloc16,
            '$kolem_Fn_98'(ThreatenP_Num3_V18,
                           A,
                           Threaten17,
                           Kolem_Fn_9819))
   ->  at(ThreatenP_Num3_V18, Tloc16)
   ).
 */
if threaten(ThreatenP_Num3_V18, A, Threaten17), some(Tloc16, '$kolem_Fn_98'(ThreatenP_Num3_V18, A, Threaten17, Kolem_Fn_9819))then loc_at(ThreatenP_Num3_V18, Tloc16).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',181).

 /*  reactive_rule([ happens(threaten(ThreatenP_Num3_V18,
   				 A,
   				 Threaten17),
   			Time_From20,
   			Time_Until21),
   		some(Tloc16,
   		     '$kolem_Fn_98'(ThreatenP_Num3_V18,
   				    A,
   				    Threaten17,
   				    Kolem_Fn_9819))
   	      ],
   	      [ holds(loc_at(ThreatenP_Num3_V18,Tloc16),
   		      Holds22)
   	      ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',181).

 /*  holds_at(at(Agent2, Exists_Location), Time) :-
       happens(threaten(Agent1, Agent2, Weapon), Time),
       some(Exists_Location,
            '$kolem_Fn_98'(Agent1, Agent2, Weapon, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',181).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Agent2, Exists_Location), Time),
          (->),
         at(Agent2, Exists_Location)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',181).

 /*  axiom(at(Agent2, Exists_Location),
       [ threaten(Agent1, Agent2, Weapon),
         some(Exists_Location,
              '$kolem_Fn_98'(Agent1, Agent2, Weapon, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',181).

 /*  (   threaten(ThreatenP_Num3_V25, A, Threaten24),
       some(Tloc23,
            '$kolem_Fn_98'(ThreatenP_Num3_V25,
                           A,
                           Threaten24,
                           Kolem_Fn_9826))
   ->  at(A, Tloc23)
   ).
 */
if threaten(ThreatenP_Num3_V25, A, Threaten24), some(Tloc23, '$kolem_Fn_98'(ThreatenP_Num3_V25, A, Threaten24, Kolem_Fn_9826))then loc_at(A, Tloc23).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',181).

 /*  reactive_rule([ happens(threaten(ThreatenP_Num3_V25,
   				 A,
   				 Threaten24),
   			Time_From27,
   			Time_Until28),
   		some(Tloc23,
   		     '$kolem_Fn_98'(ThreatenP_Num3_V25,
   				    A,
   				    Threaten24,
   				    Kolem_Fn_9826))
   	      ],
   	      [holds(loc_at(A,Tloc23),Holds29)]).
 */


% [agent1,agent2,weapon,time]
% Happens(Threaten(agent1,agent2,weapon), time) ->
% Happens(BecomeAngryAt(agent2,agent1),time).

 /*  happens(threaten(Agent1, Agent2, Weapon), Time) ->
       happens(becomeAngryAt(Agent2, Agent1), Time).
 */
if happens(threaten(Agent1, Agent2, Weapon), Time)then happens(becomeAngryAt(Agent2, Agent1), Time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',186).

 /*  reactive_rule([ happens(threaten(Agent1,
   				 Agent2,
   				 Weapon),
   			Time)
   	      ],
   	      [ happens(becomeAngryAt(Agent2,Agent1),
   			Time)
   	      ]).
 */


% [agent1,agent2,weapon,time]
% Initiates(Threaten(agent1,agent2,weapon),
%           ThreatenedBy(agent2,agent1),
%           time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',190).

 /*  axiom(initiates(threaten(Agent1, Agent2, Weapon), threatenedBy(Agent2, Agent1), Time),
       []).
 */

 /*  initiates(threaten(ThreatenP_Num3_V,A,Threaten),
   	  threatenedBy(A,ThreatenP_Num3_V),
   	  Initiates).
 */
threaten(ThreatenP_Num3_V, A, Threaten)initiates threatenedBy(A, ThreatenP_Num3_V).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',190).

 /*  initiated(happens(threaten(ThreatenP_Num3_V,
   			   A,
   			   Threaten),
   		  Time_From,
   		  Time_Until),
   	  threatenedBy(A,ThreatenP_Num3_V),
   	  []).
 */


% [agent1,agent2,time]
% Terminates(ReleaseFromThreat(agent1,agent2),
%            ThreatenedBy(agent2,agent1),
%            time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',195).

 /*  axiom(terminates(releaseFromThreat(Agent1, Agent2), threatenedBy(Agent2, Agent1), Time),
       []).
 */

 /*  terminates(releaseFromThreat(Threatenedby,
   			     Releasefromthreat),
   	   threatenedBy(Releasefromthreat,Threatenedby),
   	   Terminates).
 */
releaseFromThreat(Threatenedby, Releasefromthreat)terminates threatenedBy(Releasefromthreat, Threatenedby).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',195).

 /*  terminated(happens(releaseFromThreat(Threatenedby,
   				     Releasefromthreat),
   		   Time_From,
   		   Time_Until),
   	   threatenedBy(Releasefromthreat,Threatenedby),
   	   []).
 */

% event Order(agent,agent,physobj)
 %  event(order(agent,agent,physobj)).
 %  event(order(agent,agent,physobj)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',198).
actions([order/3]).
mpred_prop(order(agent,agent,physobj),event).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',201).
% fluent KnowOrder(agent,agent,physobj)
 %  fluent(knowOrder(agent,agent,physobj)).
 %  fluent(knowOrder(agent,agent,physobj)).
fluents([knowOrder/3]).
mpred_prop(knowOrder(agent,agent,physobj),fluent).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',203).
% [agent1,agent2,physobj,time]
% Initiates(Order(agent1,agent2,physobj),
%           KnowOrder(agent2,agent1,physobj),
%           time).

 /*  axiom(initiates(order(Agent1, Agent2, Physobj), knowOrder(Agent2, Agent1, Physobj), Time),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',203).

 /*  initiates(order(OrderP_Num3_V,
   		KnoworderP_Num3_V,
   		Order),
   	  knowOrder(KnoworderP_Num3_V,
   		    OrderP_Num3_V,
   		    Order),
   	  Initiates).
 */
order(OrderP_Num3_V, KnoworderP_Num3_V, Order)initiates knowOrder(KnoworderP_Num3_V, OrderP_Num3_V, Order).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',203).

 /*  initiated(happens(order(OrderP_Num3_V,
   			KnoworderP_Num3_V,
   			Order),
   		  Time_From,
   		  Time_Until),
   	  knowOrder(KnoworderP_Num3_V,
   		    OrderP_Num3_V,
   		    Order),
   	  []).
 */


% [agent1,agent2,physobj,time]
% Happens(Order(agent1,agent2,physobj),time) ->
% {location}% 
% HoldsAt(At(agent1,location),time) &
% HoldsAt(At(agent2,location),time).
 %  clausify_pnf=exists([Location],  (happens(order(Agent1, Agent2, Physobj), Time)->holds_at(at(Agent1, Location), Time), holds_at(at(Agent2, Location), Time))).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',209).

 /*  not(happens(order(Agent1, Agent2, Physobj), Time)) :-
       (   not(holds_at(at(Agent1, Exists_Location), Time))
       ;   not(holds_at(at(Agent2, Exists_Location), Time))
       ),
       some(Exists_Location,
            '$kolem_Fn_99'(Agent1, Agent2, Physobj, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',209).

 /*  fix_axiom_head(Time) ->
       [ not(happens(order(Agent1, Agent2, Physobj), Time)),
          (->),
         not(order(Agent1, Agent2, Physobj))
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',209).

 /*  axiom(not(order(Agent1, Agent2, Physobj)),
       [  (not(at(Agent1, Exists_Location));not(at(Agent2, Exists_Location))),
         some(Exists_Location,
              '$kolem_Fn_99'(Agent1, Agent2, Physobj, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',209).

 /*  (   (   not(at(Kolem_Fn_99P_Num4_V, Tloc))
       ;   not(at(A, Tloc))
       ),
       some(Tloc,
            '$kolem_Fn_99'(Kolem_Fn_99P_Num4_V,
                           A,
                           Order,
                           Kolem_Fn_99))
   ->  not(order(Kolem_Fn_99P_Num4_V, A, Order))
   ).
 */
if (not loc_at(Kolem_Fn_99P_Num4_V, Tloc);not loc_at(A, Tloc)), some(Tloc, '$kolem_Fn_99'(Kolem_Fn_99P_Num4_V, A, Order, Kolem_Fn_99))then not order(Kolem_Fn_99P_Num4_V, A, Order).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',209).

 /*   reactive_rule([  (not(loc_at(Kolem_Fn_99P_Num4_V, Tloc));not(loc_at(A, Tloc))),
                      some(Tloc,
                           '$kolem_Fn_99'(Kolem_Fn_99P_Num4_V,
                                          A,
                                          Order,
                                          Kolem_Fn_99))
                    ],
                    [not(order(Kolem_Fn_99P_Num4_V, A, Order))]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',209).

 /*  holds_at(at(Agent1, Exists_Location), Time) :-
       happens(order(Agent1, Agent2, Physobj), Time),
       some(Exists_Location,
            '$kolem_Fn_99'(Agent1, Agent2, Physobj, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',209).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Agent1, Exists_Location), Time),
          (->),
         at(Agent1, Exists_Location)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',209).

 /*  axiom(at(Agent1, Exists_Location),
       [ order(Agent1, Agent2, Physobj),
         some(Exists_Location,
              '$kolem_Fn_99'(Agent1, Agent2, Physobj, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',209).

 /*  (   order(OrderP_Num3_V, A, Order11),
       some(Tloc10,
            '$kolem_Fn_99'(OrderP_Num3_V,
                           A,
                           Order11,
                           Kolem_Fn_9913))
   ->  at(OrderP_Num3_V, Tloc10)
   ).
 */
if order(OrderP_Num3_V, A, Order11), some(Tloc10, '$kolem_Fn_99'(OrderP_Num3_V, A, Order11, Kolem_Fn_9913))then loc_at(OrderP_Num3_V, Tloc10).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',209).

 /*  reactive_rule([ happens(order(OrderP_Num3_V,
   			      A,
   			      Order11),
   			Time_From,
   			Time_Until),
   		some(Tloc10,
   		     '$kolem_Fn_99'(OrderP_Num3_V,
   				    A,
   				    Order11,
   				    Kolem_Fn_9913))
   	      ],
   	      [ holds(loc_at(OrderP_Num3_V,Tloc10),
   		      Holds)
   	      ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',209).

 /*  holds_at(at(Agent2, Exists_Location), Time) :-
       happens(order(Agent1, Agent2, Physobj), Time),
       some(Exists_Location,
            '$kolem_Fn_99'(Agent1, Agent2, Physobj, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',209).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Agent2, Exists_Location), Time),
          (->),
         at(Agent2, Exists_Location)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',209).

 /*  axiom(at(Agent2, Exists_Location),
       [ order(Agent1, Agent2, Physobj),
         some(Exists_Location,
              '$kolem_Fn_99'(Agent1, Agent2, Physobj, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',209).

 /*  (   order(OrderP_Num3_V19, A, Order18),
       some(Tloc17,
            '$kolem_Fn_99'(OrderP_Num3_V19,
                           A,
                           Order18,
                           Kolem_Fn_9920))
   ->  at(A, Tloc17)
   ).
 */
if order(OrderP_Num3_V19, A, Order18), some(Tloc17, '$kolem_Fn_99'(OrderP_Num3_V19, A, Order18, Kolem_Fn_9920))then loc_at(A, Tloc17).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',209).

 /*  reactive_rule([ happens(order(OrderP_Num3_V19,
   			      A,
   			      Order18),
   			Time_From21,
   			Time_Until22),
   		some(Tloc17,
   		     '$kolem_Fn_99'(OrderP_Num3_V19,
   				    A,
   				    Order18,
   				    Kolem_Fn_9920))
   	      ],
   	      [holds(loc_at(A,Tloc17),Holds23)]).
 */

% event Request(agent,agent,physobj)
 %  event(request(agent,agent,physobj)).
 %  event(request(agent,agent,physobj)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',213).
actions([request/3]).
mpred_prop(request(agent,agent,physobj),event).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',216).
% fluent KnowRequest(agent,agent,physobj)
 %  fluent(knowRequest(agent,agent,physobj)).
 %  fluent(knowRequest(agent,agent,physobj)).
fluents([knowRequest/3]).
mpred_prop(knowRequest(agent,agent,physobj),fluent).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',218).
% [agent1,agent2,physobj,time]
% Initiates(Request(agent1,agent2,physobj),
%           KnowRequest(agent2,agent1,physobj),
%           time).

 /*  axiom(initiates(request(Agent1, Agent2, Physobj), knowRequest(Agent2, Agent1, Physobj), Time),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',218).

 /*  initiates(request(RequestP_Num3_V,
   		  KnowrequestP_Num3_V,
   		  Request),
   	  knowRequest(KnowrequestP_Num3_V,
   		      RequestP_Num3_V,
   		      Request),
   	  Initiates).
 */
request(RequestP_Num3_V, KnowrequestP_Num3_V, Request)initiates knowRequest(KnowrequestP_Num3_V, RequestP_Num3_V, Request).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',218).

 /*  initiated(happens(request(RequestP_Num3_V,
   			  KnowrequestP_Num3_V,
   			  Request),
   		  Time_From,
   		  Time_Until),
   	  knowRequest(KnowrequestP_Num3_V,
   		      RequestP_Num3_V,
   		      Request),
   	  []).
 */


% [agent1,agent2,physobj,time]
% Happens(Request(agent1,agent2,physobj),time) ->
% {location}% 
% HoldsAt(At(agent1,location),time) &
% HoldsAt(At(agent2,location),time).
 %  clausify_pnf=exists([Location],  (happens(request(Agent1, Agent2, Physobj), Time)->holds_at(at(Agent1, Location), Time), holds_at(at(Agent2, Location), Time))).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',224).

 /*  not(happens(request(Agent1, Agent2, Physobj), Time)) :-
       (   not(holds_at(at(Agent1, Exists_Location), Time))
       ;   not(holds_at(at(Agent2, Exists_Location), Time))
       ),
       some(Exists_Location,
            '$kolem_Fn_100'(Agent1, Agent2, Physobj, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',224).

 /*  fix_axiom_head(Time) ->
       [ not(happens(request(Agent1, Agent2, Physobj), Time)),
          (->),
         not(request(Agent1, Agent2, Physobj))
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',224).

 /*  axiom(not(request(Agent1, Agent2, Physobj)),
       [  (not(at(Agent1, Exists_Location));not(at(Agent2, Exists_Location))),
         some(Exists_Location,
              '$kolem_Fn_100'(Agent1, Agent2, Physobj, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',224).

 /*  (   (   not(at(Kolem_Fn_100P_Num4_V, Tloc))
       ;   not(at(A, Tloc))
       ),
       some(Tloc,
            '$kolem_Fn_100'(Kolem_Fn_100P_Num4_V,
                            A,
                            Request,
                            Kolem_Fn_100))
   ->  not(request(Kolem_Fn_100P_Num4_V, A, Request))
   ).
 */
if (not loc_at(Kolem_Fn_100P_Num4_V, Tloc);not loc_at(A, Tloc)), some(Tloc, '$kolem_Fn_100'(Kolem_Fn_100P_Num4_V, A, Request, Kolem_Fn_100))then not request(Kolem_Fn_100P_Num4_V, A, Request).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',224).

 /*   reactive_rule([  (not(loc_at(Kolem_Fn_100P_Num4_V, Tloc));not(loc_at(A, Tloc))),
                      some(Tloc,
                           '$kolem_Fn_100'(Kolem_Fn_100P_Num4_V,
                                           A,
                                           Request,
                                           Kolem_Fn_100))
                    ],
                    [ not(request(Kolem_Fn_100P_Num4_V,
                                  A,
                                  Request))
                    ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',224).

 /*  holds_at(at(Agent1, Exists_Location), Time) :-
       happens(request(Agent1, Agent2, Physobj), Time),
       some(Exists_Location,
            '$kolem_Fn_100'(Agent1, Agent2, Physobj, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',224).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Agent1, Exists_Location), Time),
          (->),
         at(Agent1, Exists_Location)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',224).

 /*  axiom(at(Agent1, Exists_Location),
       [ request(Agent1, Agent2, Physobj),
         some(Exists_Location,
              '$kolem_Fn_100'(Agent1, Agent2, Physobj, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',224).

 /*  (   request(RequestP_Num3_V, A, Request11),
       some(Tloc10,
            '$kolem_Fn_100'(RequestP_Num3_V,
                            A,
                            Request11,
                            Kolem_Fn_10013))
   ->  at(RequestP_Num3_V, Tloc10)
   ).
 */
if request(RequestP_Num3_V, A, Request11), some(Tloc10, '$kolem_Fn_100'(RequestP_Num3_V, A, Request11, Kolem_Fn_10013))then loc_at(RequestP_Num3_V, Tloc10).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',224).

 /*  reactive_rule([ happens(request(RequestP_Num3_V,
   				A,
   				Request11),
   			Time_From,
   			Time_Until),
   		some(Tloc10,
   		     '$kolem_Fn_100'(RequestP_Num3_V,
   				     A,
   				     Request11,
   				     Kolem_Fn_10013))
   	      ],
   	      [ holds(loc_at(RequestP_Num3_V,Tloc10),
   		      Holds)
   	      ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',224).

 /*  holds_at(at(Agent2, Exists_Location), Time) :-
       happens(request(Agent1, Agent2, Physobj), Time),
       some(Exists_Location,
            '$kolem_Fn_100'(Agent1, Agent2, Physobj, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',224).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Agent2, Exists_Location), Time),
          (->),
         at(Agent2, Exists_Location)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',224).

 /*  axiom(at(Agent2, Exists_Location),
       [ request(Agent1, Agent2, Physobj),
         some(Exists_Location,
              '$kolem_Fn_100'(Agent1, Agent2, Physobj, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',224).

 /*  (   request(RequestP_Num3_V19, A, Request18),
       some(Tloc17,
            '$kolem_Fn_100'(RequestP_Num3_V19,
                            A,
                            Request18,
                            Kolem_Fn_10020))
   ->  at(A, Tloc17)
   ).
 */
if request(RequestP_Num3_V19, A, Request18), some(Tloc17, '$kolem_Fn_100'(RequestP_Num3_V19, A, Request18, Kolem_Fn_10020))then loc_at(A, Tloc17).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',224).

 /*  reactive_rule([ happens(request(RequestP_Num3_V19,
   				A,
   				Request18),
   			Time_From21,
   			Time_Until22),
   		some(Tloc17,
   		     '$kolem_Fn_100'(RequestP_Num3_V19,
   				     A,
   				     Request18,
   				     Kolem_Fn_10020))
   	      ],
   	      [holds(loc_at(A,Tloc17),Holds23)]).
 */


%; End of file.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/SpeechAct.e',228).
:- endif.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',50).
% load answers/Mueller2004c/Dress.e
:- if(is_e_toplevel).
:- cond_convert_e(changed, 'answers/Mueller2004c/Dress.e').
 %  loading(changed,'/pack/logicmoo_ec/ext/ec_sources/ecnet/Dress.e').
%;
%; Copyright (c) 2005 IBM Corporation and others.
%; All rights reserved. This program and the accompanying materials
%; are made available under the terms of the Common Public License v1.0
%; which accompanies this distribution, and is available at
%; http://www.eclipse.org/legal/cpl-v10.html
%;
%; Contributors:
%; IBM - Initial implementation
%;
%; Dress
%; (cf Sleep)
%;

% event PutOn(agent,clothing)
 %  event(putOn(agent,clothing)).
 %  event(putOn(agent,clothing)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Dress.e',15).
actions([putOn/2]).
mpred_prop(putOn(agent,clothing),event).

% event TakeOff(agent,clothing)
 %  event(takeOff(agent,clothing)).
 %  event(takeOff(agent,clothing)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Dress.e',17).
actions([takeOff/2]).
mpred_prop(takeOff(agent,clothing),event).

% fluent Wearing(agent,clothing)
 %  fluent(wearing(agent,clothing)).
 %  fluent(wearing(agent,clothing)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Dress.e',19).
fluents([wearing/2]).
mpred_prop(wearing(agent,clothing),fluent).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Dress.e',21).
% [agent,clothing,time]
% Initiates(PutOn(agent,clothing),
%           Wearing(agent,clothing),
%           time).

 /*  axiom(initiates(putOn(Agent, Clothing), wearing(Agent, Clothing), Time),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Dress.e',21).

 /*  initiates(putOn(A,Puton),
   	  wearing(A,Puton),
   	  Initiates).
 */
putOn(A, Puton)initiates wearing(A, Puton).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Dress.e',21).

 /*  initiated(happens(putOn(A,Puton),
   		  Time_From,
   		  Time_Until),
   	  wearing(A,Puton),
   	  []).
 */


% [agent,clothing,time]
% Happens(PutOn(agent,clothing),time) ->
% !HoldsAt(Wearing(agent,clothing),time) &
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Dress.e',27).
% {location}%  HoldsAt(At(agent,location),time) &
%            HoldsAt(At(clothing,location),time).
 %  clausify_pnf=exists([Location],  (happens(putOn(Agent, Clothing), Time)->holds_at(neg(wearing(Agent, Clothing)), Time), holds_at(at(Agent, Location), Time), holds_at(at(Clothing, Location), Time))).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Dress.e',29).

 /*  not(happens(putOn(Agent, Clothing), Time)) :-
       (   not(holds_at(neg(wearing(Agent, Clothing)), Time))
       ;   not(holds_at(at(Agent, Exists_Location), Time))
       ;   not(holds_at(at(Clothing, Exists_Location), Time))
       ),
       some(Exists_Location,
            '$kolem_Fn_101'(Agent, Clothing, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Dress.e',29).

 /*  fix_axiom_head(Time) ->
       [ not(happens(putOn(Agent, Clothing), Time)),
          (->),
         not(putOn(Agent, Clothing))
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Dress.e',29).

 /*  axiom(not(putOn(Agent, Clothing)),
       [  (not(not(wearing(Agent, Clothing)));not(at(Agent, Exists_Location));not(at(Clothing, Exists_Location))),
         some(Exists_Location,
              '$kolem_Fn_101'(Agent, Clothing, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Dress.e',29).

 /*  (   (   not(not(wearing(Kolem_Fn_101P_Num3_V, Wearing)))
       ;   not(at(Kolem_Fn_101P_Num3_V, Tloc))
       ;   not(at(Wearing, Tloc))
       ),
       some(Tloc,
            '$kolem_Fn_101'(Kolem_Fn_101P_Num3_V,
                            Wearing,
                            Kolem_Fn_101))
   ->  not(putOn(Kolem_Fn_101P_Num3_V, Wearing))
   ).
 */
if (not not wearing(Kolem_Fn_101P_Num3_V, Wearing);not loc_at(Kolem_Fn_101P_Num3_V, Tloc);not loc_at(Wearing, Tloc)), some(Tloc, '$kolem_Fn_101'(Kolem_Fn_101P_Num3_V, Wearing, Kolem_Fn_101))then not putOn(Kolem_Fn_101P_Num3_V, Wearing).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Dress.e',29).

 /*   reactive_rule([  (not(not(wearing(Kolem_Fn_101P_Num3_V, Wearing)));not(loc_at(Kolem_Fn_101P_Num3_V, Tloc));not(loc_at(Wearing, Tloc))),
                      some(Tloc,
                           '$kolem_Fn_101'(Kolem_Fn_101P_Num3_V,
                                           Wearing,
                                           Kolem_Fn_101))
                    ],
                    [not(putOn(Kolem_Fn_101P_Num3_V, Wearing))]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Dress.e',29).

 /*  holds_at(neg(wearing(Agent, Clothing)), Time) :-
       happens(putOn(Agent, Clothing), Time),
       some(Exists_Location,
            '$kolem_Fn_101'(Agent, Clothing, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Dress.e',29).

 /*  fix_axiom_head(Time) ->
       [ holds_at(neg(wearing(Agent, Clothing)), Time),
          (->),
         not(wearing(Agent, Clothing))
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Dress.e',29).

 /*  axiom(not(wearing(Agent, Clothing)),
       [ putOn(Agent, Clothing),
         some(Exists_Location,
              '$kolem_Fn_101'(Agent, Clothing, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Dress.e',29).

 /*  (   putOn(Kolem_Fn_101P_Num3_V11, Puton),
       some(_,
            '$kolem_Fn_101'(Kolem_Fn_101P_Num3_V11,
                            Puton,
                            Kolem_Fn_10110))
   ->  not(wearing(Kolem_Fn_101P_Num3_V11, Puton))
   ).
 */
if putOn(Kolem_Fn_101P_Num3_V11, Puton), some(_, '$kolem_Fn_101'(Kolem_Fn_101P_Num3_V11, Puton, Kolem_Fn_10110))then not wearing(Kolem_Fn_101P_Num3_V11, Puton).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Dress.e',29).

 /*  reactive_rule([ happens(putOn(Kolem_Fn_101P_Num3_V11,Puton),
   			Time_From,
   			Time_Until),
   		some(_,
   		     '$kolem_Fn_101'(Kolem_Fn_101P_Num3_V11,
   				     Puton,
   				     Kolem_Fn_10110))
   	      ],
   	      [ holds(not(wearing(Kolem_Fn_101P_Num3_V11,
   				  Puton)),
   		      Holds)
   	      ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Dress.e',29).

 /*  holds_at(at(Agent, Exists_Location), Time) :-
       happens(putOn(Agent, Clothing), Time),
       some(Exists_Location,
            '$kolem_Fn_101'(Agent, Clothing, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Dress.e',29).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Agent, Exists_Location), Time),
          (->),
         at(Agent, Exists_Location)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Dress.e',29).

 /*  axiom(at(Agent, Exists_Location),
       [ putOn(Agent, Clothing),
         some(Exists_Location,
              '$kolem_Fn_101'(Agent, Clothing, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Dress.e',29).

 /*  (   putOn(Kolem_Fn_101P_Num3_V18, Puton16),
       some(Tloc15,
            '$kolem_Fn_101'(Kolem_Fn_101P_Num3_V18,
                            Puton16,
                            Kolem_Fn_10117))
   ->  at(Kolem_Fn_101P_Num3_V18, Tloc15)
   ).
 */
if putOn(Kolem_Fn_101P_Num3_V18, Puton16), some(Tloc15, '$kolem_Fn_101'(Kolem_Fn_101P_Num3_V18, Puton16, Kolem_Fn_10117))then loc_at(Kolem_Fn_101P_Num3_V18, Tloc15).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Dress.e',29).

 /*  reactive_rule([ happens(putOn(Kolem_Fn_101P_Num3_V18,
   			      Puton16),
   			Time_From19,
   			Time_Until20),
   		some(Tloc15,
   		     '$kolem_Fn_101'(Kolem_Fn_101P_Num3_V18,
   				     Puton16,
   				     Kolem_Fn_10117))
   	      ],
   	      [ holds(loc_at(Kolem_Fn_101P_Num3_V18,Tloc15),
   		      Holds21)
   	      ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Dress.e',29).

 /*  holds_at(at(Clothing, Exists_Location), Time) :-
       happens(putOn(Agent, Clothing), Time),
       some(Exists_Location,
            '$kolem_Fn_101'(Agent, Clothing, Time)).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Dress.e',29).

 /*  fix_axiom_head(Time) ->
       [ holds_at(at(Clothing, Exists_Location), Time),
          (->),
         at(Clothing, Exists_Location)
       ].
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Dress.e',29).

 /*  axiom(at(Clothing, Exists_Location),
       [ putOn(Agent, Clothing),
         some(Exists_Location,
              '$kolem_Fn_101'(Agent, Clothing, Time))
       ]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Dress.e',29).

 /*  (   putOn(Kolem_Fn_101P_Num3_V25, Puton23),
       some(Tloc22,
            '$kolem_Fn_101'(Kolem_Fn_101P_Num3_V25,
                            Puton23,
                            Kolem_Fn_10124))
   ->  at(Puton23, Tloc22)
   ).
 */
if putOn(Kolem_Fn_101P_Num3_V25, Puton23), some(Tloc22, '$kolem_Fn_101'(Kolem_Fn_101P_Num3_V25, Puton23, Kolem_Fn_10124))then loc_at(Puton23, Tloc22).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Dress.e',29).

 /*  reactive_rule([ happens(putOn(Kolem_Fn_101P_Num3_V25,
   			      Puton23),
   			Time_From26,
   			Time_Until27),
   		some(Tloc22,
   		     '$kolem_Fn_101'(Kolem_Fn_101P_Num3_V25,
   				     Puton23,
   				     Kolem_Fn_10124))
   	      ],
   	      [holds(loc_at(Puton23,Tloc22),Holds28)]).
 */


% [agent,clothing,time]
% Terminates(TakeOff(agent,clothing),
%            Wearing(agent,clothing),
%            time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Dress.e',33).

 /*  axiom(terminates(takeOff(Agent, Clothing), wearing(Agent, Clothing), Time),
       []).
 */

 /*  terminates(takeOff(A,Takeoff),
   	   wearing(A,Takeoff),
   	   Terminates).
 */
takeOff(A, Takeoff)terminates wearing(A, Takeoff).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Dress.e',33).

 /*  terminated(happens(takeOff(A,Takeoff),
   		   Time_From,
   		   Time_Until),
   	   wearing(A,Takeoff),
   	   []).
 */


% [agent,clothing,time]
% Happens(TakeOff(agent,clothing),time) ->
% HoldsAt(Wearing(agent,clothing),time).

 /*  happens(takeOff(Agent, Clothing), Time) ->
       holds_at(wearing(Agent, Clothing), Time).
 */
if happens(takeOff(Agent, Clothing), Time)then wearing(Agent, Clothing)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Dress.e',38).

 /*  reactive_rule([happens(takeOff(Agent,Clothing),Time)],
   	      [holds(wearing(Agent,Clothing),Time)]).
 */


% [agent,clothing,location,time]
% Releases(PutOn(agent,clothing),At(clothing,location),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Dress.e',42).

 /*  axiom(releases(putOn(Agent, Clothing), at(Clothing, Location), Time),
       []).
 */

 /*  releases(putOn(_,Puton),
   	 at(Puton,Tloc),
   	 Releases).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Dress.e',42).
releases(putOn(_,Puton),
	 loc_at(Puton,Tloc),
	 Releases).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Dress.e',44).
% [agent,clothing,location,time]
% HoldsAt(Wearing(agent,clothing),time) &
% HoldsAt(At(agent,location),time) ->
% HoldsAt(At(clothing,location),time).

 /*  (   holds_at(wearing(Agent, Clothing), Time),
       holds_at(at(Agent, Location), Time)
   ->  holds_at(at(Clothing, Location), Time)
   ).
 */
if wearing(Agent, Clothing)at Time, loc_at(Agent, Location)at Time then loc_at(Clothing, Location)at Time.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Dress.e',44).

 /*  reactive_rule([ holds(wearing(Agent,Clothing),Time),
   		holds(loc_at(Agent,Location),Time)
   	      ],
   	      [holds(loc_at(Clothing,Location),Time)]).
 */


%;[agent,clothing,location1,location2,time]
%;HoldsAt(At(agent,location1),time) &
%;location1 != location2 ->
%;Terminates(TakeOff(agent,clothing),At(clothing,location2),time).
% [agent,clothing,location,time]
% HoldsAt(At(agent,location),time) ->
% Initiates(TakeOff(agent,clothing),At(clothing,location),time).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Dress.e',54).

 /*  axiom(initiates(takeOff(Agent, Clothing), at(Clothing, Location), Time),
       [at(Agent, Location)]).
 */

 /*  at(A, Tloc) ->
       initiates(takeOff(A, Takeoff),
                 at(Takeoff, Tloc),
                 Initiates).
 */
if loc_at(A, Tloc)then initiates(takeOff(A, Takeoff), loc_at(Takeoff, Tloc)at Initiates, _).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Dress.e',54).

 /*  reactive_rule([holds(loc_at(A,Tloc),Holds)],
   	      [ initiates(takeOff(A,Takeoff),
   			  at(loc_at(Takeoff,Tloc),
   			     Initiates),
   			  Initiates8)
   	      ]).
 */


%; End of file.
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/Dress.e',57).
:- endif.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',52).
% room Upstairs1
 %  t(room,upstairs1).
room(upstairs1).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',54).
% staircase Staircase1
 %  t(staircase,staircase1).
staircase(staircase1).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',56).
% room Hallway1
 %  t(room,hallway1).
room(hallway1).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',58).
% Side1(Staircase1)=Hallway1.

 /*  axiom(side1Pred(staircase1, hallway1),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',58).
side1Pred(staircase1,hallway1).


% Side2(Staircase1)=Upstairs1.

 /*  axiom(side2Pred(staircase1, upstairs1),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',58).
side2Pred(staircase1,upstairs1).

% door DiningRoomDoor1
 %  t(door,diningRoomDoor1).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',60).
door(diningRoomDoor1).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',63).
% room DiningRoom1
 %  t(room,diningRoom1).
room(diningRoom1).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',65).
% Side1(DiningRoomDoor1)=Hallway1.

 /*  axiom(side1Pred(diningRoomDoor1, hallway1),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',65).
side1Pred(diningRoomDoor1,hallway1).


% Side2(DiningRoomDoor1)=DiningRoom1.

 /*  axiom(side2Pred(diningRoomDoor1, diningRoom1),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',65).
side2Pred(diningRoomDoor1,diningRoom1).

% door KitchenDoor1
 %  t(door,kitchenDoor1).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',67).
door(kitchenDoor1).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',70).
% room Kitchen1
 %  t(room,kitchen1).
room(kitchen1).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',72).
% Side1(KitchenDoor1)=DiningRoom1.

 /*  axiom(side1Pred(kitchenDoor1, diningRoom1),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',72).
side1Pred(kitchenDoor1,diningRoom1).


% Side2(KitchenDoor1)=Kitchen1.

 /*  axiom(side2Pred(kitchenDoor1, kitchen1),
       []).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',72).
side2Pred(kitchenDoor1,kitchen1).

% agent Eater1
 %  t(agent,eater1).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',74).
agent(eater1).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',77).
% agent Eater2
 %  t(agent,eater2).
agent(eater2).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',79).
% clothing Clothing1
 %  t(clothing,clothing1).
clothing(clothing1).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',81).
% clothing Clothing2
 %  t(clothing,clothing2).
clothing(clothing2).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',83).
% chair Chair1
 %  t(chair,chair1).
chair(chair1).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',85).
% chair Chair2
 %  t(chair,chair2).
chair(chair2).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',87).
% food Food1
 %  t(food,food1).
food(food1).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',89).
% agent Cook1
 %  t(agent,cook1).
agent(cook1).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',91).
% table Table1
 %  t(table,table1).
table table1.

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',93).
% content Content1
 %  t(content,content1).
content(content1).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',95).
% content Content2
 %  t(content,content2).
content(content2).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',97).
% outside DummyOutside1
 %  t(outside,dummyOutside1).
outside(dummyOutside1).
%; prune

% sort ona, onb
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',99).
sort(ona).
sort(onb).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',101).
% fluent! On(ona,onb)
 %  fluent(on(ona,onb)).
 %  fluent(on(ona,onb)).
fluents([on/2]).
mpred_prop(on(ona,onb),fluent).

% event! PlaceOn(agent,ona,onb)
 %  event(placeOn(agent,ona,onb)).
 %  event(placeOn(agent,ona,onb)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',101).
actions([placeOn/3]).
mpred_prop(placeOn(agent,ona,onb),event).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',103).
% event! TakeOffOf(agent,ona,onb)
 %  event(takeOffOf(agent,ona,onb)).
 %  event(takeOffOf(agent,ona,onb)).
actions([takeOffOf/3]).
mpred_prop(takeOffOf(agent,ona,onb),event).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',105).
% sort ordera, orderb, orderc
sort(ordera).
sort(orderb).
sort(orderc).

% event! Order(ordera,orderb,orderc)
 %  event(order(ordera,orderb,orderc)).
 %  event(order(ordera,orderb,orderc)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',105).
events([order/3]).
mpred_prop(order(ordera,orderb,orderc),event).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',107).
% fluent! KnowOrder(orderb,ordera,orderc)
 %  fluent(knowOrder(orderb,ordera,orderc)).
 %  fluent(knowOrder(orderb,ordera,orderc)).
fluents([knowOrder/3]).
mpred_prop(knowOrder(orderb,ordera,orderc),fluent).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',109).
% sort requesta, requestb, requestc
sort(requesta).
sort(requestb).
sort(requestc).

% event! Request(requesta,requestb,requestc)
 %  event(request(requesta,requestb,requestc)).
 %  event(request(requesta,requestb,requestc)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',109).
events([request/3]).
mpred_prop(request(requesta,requestb,requestc),event).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',111).
% fluent! KnowRequest(requestb,requesta,requestc)
 %  fluent(knowRequest(requestb,requesta,requestc)).
 %  fluent(knowRequest(requestb,requesta,requestc)).
fluents([knowRequest/3]).
mpred_prop(knowRequest(requestb,requesta,requestc),fluent).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',113).
% sort holda, holdb, holdc
sort(holda).
sort(holdb).
sort(holdc).

% event! TakeOffOf(holda,holdb,holdc)
 %  event(takeOffOf(holda,holdb,holdc)).
 %  event(takeOffOf(holda,holdb,holdc)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',113).
events([takeOffOf/3]).
mpred_prop(takeOffOf(holda,holdb,holdc),event).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',115).
% event! PickUp(holda,holdb)
 %  event(pickUp(holda,holdb)).
 %  event(pickUp(holda,holdb)).
events([pickUp/2]).
mpred_prop(pickUp(holda,holdb),event).

% event! LetGoOf(holda,holdb)
 %  event(letGoOf(holda,holdb)).
 %  event(letGoOf(holda,holdb)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',115).
events([letGoOf/2]).
mpred_prop(letGoOf(holda,holdb),event).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',117).
% event! Hold(holda,holdb)
 %  event(hold(holda,holdb)).
 %  event(hold(holda,holdb)).
events([hold/2]).
mpred_prop(hold(holda,holdb),event).

% fluent! Holding(holda,holdb)
 %  fluent(holding(holda,holdb)).
 %  fluent(holding(holda,holdb)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',117).
fluents([holding/2]).
mpred_prop(holding(holda,holdb),fluent).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',120).
% sort sita, sitb
sort(sita).
sort(sitb).

% event! LieOn(sita,sitb)
 %  event(lieOn(sita,sitb)).
 %  event(lieOn(sita,sitb)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',120).
events([lieOn/2]).
mpred_prop(lieOn(sita,sitb),event).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',122).
% event! SitOn(sita,sitb)
 %  event(sitOn(sita,sitb)).
 %  event(sitOn(sita,sitb)).
events([sitOn/2]).
mpred_prop(sitOn(sita,sitb),event).

% event! RiseFrom(sita,sitb)
 %  event(riseFrom(sita,sitb)).
 %  event(riseFrom(sita,sitb)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',122).
events([riseFrom/2]).
mpred_prop(riseFrom(sita,sitb),event).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',124).
% fluent! LyingOn(sita,sitb)
 %  fluent(lyingOn(sita,sitb)).
 %  fluent(lyingOn(sita,sitb)).
fluents([lyingOn/2]).
mpred_prop(lyingOn(sita,sitb),fluent).

% fluent! SittingOn(sita,sitb)
 %  fluent(sittingOn(sita,sitb)).
 %  fluent(sittingOn(sita,sitb)).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',124).
fluents([sittingOn/2]).
mpred_prop(sittingOn(sita,sitb),fluent).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',127).
% ona! Food1
 %  t(ona,food1).
ona(food1).

% onb! Table1
 %  t(onb,table1).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',127).
onb(table1).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',129).
% holda! Cook1
 %  t(holda,cook1).
holda(cook1).

% holdb! Food1
 %  t(holdb,food1).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',129).
holdb(food1).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',131).
% holdc! Table1
 %  t(holdc,table1).
holdc(table1).

% sita! Eater1
 %  t(sita,eater1).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',131).
sita(eater1).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',133).
% sitb! Chair1
 %  t(sitb,chair1).
sitb(chair1).
%; initial situation
% [agent]
 % HoldsAt(Dressed(agent),0).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',135).

 /*  axiom(initially(dressed(Agent)),
       []).
 */
initially dressed(_).
 %  initial_state([dressed(Dressed)]).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',137).
% [agent]
 % HoldsAt(Awake(agent),0).

 /*  axiom(initially(awake(Agent)),
       []).
 */
initially awake(_).
 %  initial_state([awake(Awake)]).


% [agent]
 % HoldsAt(Sleep3(agent),0).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',137).

 /*  axiom(initially(sleep3(Agent)),
       []).
 */
initially sleep3(_).
 %  initial_state([sleep3(Sleep3)]).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',139).
% [agent]
 % HoldsAt(Standing(agent),0).

 /*  axiom(initially(standing(Agent)),
       []).
 */
initially standing(_).
 %  initial_state([standing(Standing)]).


% [agent]
 % HoldsAt(Standing(agent),0).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',139).

 /*  axiom(initially(standing(Agent)),
       []).
 */
initially standing(_).
 %  initial_state([standing(Standing)]).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',141).
% [agent,object]
 % !HoldsAt(Holding(agent,object),0).

 /*  axiom(initially(neg(holding(Agent, Object))),
       []).
 */
 %  initially(neg(holding(_,Holding))).
initially not holding(_, Holding).
 %  initial_state([not(holding(_,Holding))]).


% [food]
 % HoldsAt(At(food,Kitchen1),0).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',141).

 /*  axiom(initially(at(Food, kitchen1)),
       []).
 */
 %  initially(at(_,kitchen1)).
initially loc_at(_, kitchen1).
 %  initial_state([loc_at(_,kitchen1)]).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',143).
% [food]
 % !HoldsAt(FoodPrepared(food),0).

 /*  axiom(initially(neg(foodPrepared(Food))),
       []).
 */
 %  initially(neg(foodPrepared(Foodprepared))).
initially not foodPrepared(Foodprepared).
 %  initial_state([not(foodPrepared(Foodprepared))]).


% [agent]
 % HoldsAt(Hungry(agent),0).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',143).

 /*  axiom(initially(hungry(Agent)),
       []).
 */
initially hungry(_).
 %  initial_state([hungry(Hungry)]).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',145).
% [door]
 % HoldsAt(DoorIsOpen(door),0).

 /*  axiom(initially(doorIsOpen(Door)),
       []).
 */
initially doorIsOpen(_).
 %  initial_state([doorIsOpen(Doorisopen)]).


% [clothing]
 % HoldsAt(At(clothing,Upstairs1),0).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',145).

 /*  axiom(initially(at(Clothing, upstairs1)),
       []).
 */
 %  initially(at(_,upstairs1)).
initially loc_at(_, upstairs1).
 %  initial_state([loc_at(_,upstairs1)]).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',147).
% [chair]
 % HoldsAt(At(chair,DiningRoom1),0).

 /*  axiom(initially(at(Chair, diningRoom1)),
       []).
 */
 %  initially(at(_,diningRoom1)).
initially loc_at(_, diningRoom1).
 %  initial_state([loc_at(_,diningRoom1)]).


% HoldsAt(At(Cook1,Kitchen1),0).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',147).

 /*  axiom(initially(at(cook1, kitchen1)),
       []).
 */
 %  initially(at(cook1,kitchen1)).
initially loc_at(cook1, kitchen1).
 %  initial_state([loc_at(cook1,kitchen1)]).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',149).
% HoldsAt(At(Table1,DiningRoom1),0).

 /*  axiom(initially(at(table1, diningRoom1)),
       []).
 */
 %  initially(at(table1,diningRoom1)).
initially loc_at(table1, diningRoom1).
 %  initial_state([loc_at(table1,diningRoom1)]).


% [agent,clothing]
 % !HoldsAt(Wearing(agent,clothing),0).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',149).

 /*  axiom(initially(neg(wearing(Agent, Clothing))),
       []).
 */
 %  initially(neg(wearing(_,Wearing))).
initially not wearing(_, Wearing).
 %  initial_state([not(wearing(_,Wearing))]).


%; narrative


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',153).
% HoldsAt(At(Cook1,Kitchen1),0).

 /*  axiom(initially(at(cook1, kitchen1)),
       []).
 */
 %  initially(at(cook1,kitchen1)).
initially loc_at(cook1, kitchen1).
 %  initial_state([loc_at(cook1,kitchen1)]).


% HoldsAt(At(Eater1,Upstairs1),0).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',153).

 /*  axiom(initially(at(eater1, upstairs1)),
       []).
 */
 %  initially(at(eater1,upstairs1)).
initially loc_at(eater1, upstairs1).
 %  initial_state([loc_at(eater1,upstairs1)]).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',155).
% HoldsAt(At(Eater2,Upstairs1),0).

 /*  axiom(initially(at(eater2, upstairs1)),
       []).
 */
 %  initially(at(eater2,upstairs1)).
initially loc_at(eater2, upstairs1).
 %  initial_state([loc_at(eater2,upstairs1)]).


% Happens(FoodPrepare(Cook1,Food1),0).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',155).

 /*  axiom(happens(foodPrepare(cook1, food1), start),
       []).
 */
 %  happens(foodPrepare(cook1,food1),start).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',155).
observe(at(foodPrepare(cook1,food1),start)).


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',157).
% Happens(PutOn(Eater1,Clothing1),1).

 /*  axiom(happens(putOn(eater1, clothing1), When),
       [b(start, When)]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',157).

 /*  b(start, When1) ->
       happens(putOn(eater1, clothing1), When1).
 */
if b(start, When1)then happens(putOn(eater1, clothing1), When1).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',157).

 /*  reactive_rule([b(start,When1)],
   	      [happens(putOn(eater1,clothing1),When1)]).
 */


% Happens(PutOn(Eater2,Clothing2),2).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',157).

 /*  axiom(happens(putOn(eater2, clothing2), Start_Num2),
       [b(start, Start_Num2), toffset(start, 2, Start_Num2)]).
 */

 /*  (   b(start, When),
       toffset(start, 2, When)
   ->  happens(putOn(eater2, clothing2), When)
   ).
 */
if b(start, When), toffset(start, 2, When)then happens(putOn(eater2, clothing2), When).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',157).

 /*  reactive_rule([b(start,When),toffset(start,2,When)],
   	      [happens(putOn(eater2,clothing2),When)]).
 */


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',159).
% Happens(WalkDownStaircase(Eater1,Staircase1),3).

 /*  axiom(happens(walkDownStaircase(eater1, staircase1), Start_Num3),
       [b(start, Start_Num3), toffset(start, 3, Start_Num3)]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',159).

 /*  (   b(start, When),
       toffset(start, 3, When)
   ->  happens(walkDownStaircase(eater1, staircase1), When)
   ).
 */
if b(start, When), toffset(start, 3, When)then happens(walkDownStaircase(eater1, staircase1), When).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',159).

 /*  reactive_rule([b(start,When),toffset(start,3,When)],
   	      [ happens(walkDownStaircase(eater1,staircase1),
   			When)
   	      ]).
 */


% Happens(WalkDownStaircase(Eater2,Staircase1),4).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',159).

 /*  axiom(happens(walkDownStaircase(eater2, staircase1), Start_Num4),
       [b(start, Start_Num4), toffset(start, 4, Start_Num4)]).
 */

 /*  (   b(start, When),
       toffset(start, 4, When)
   ->  happens(walkDownStaircase(eater2, staircase1), When)
   ).
 */
if b(start, When), toffset(start, 4, When)then happens(walkDownStaircase(eater2, staircase1), When).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',159).

 /*  reactive_rule([b(start,When),toffset(start,4,When)],
   	      [ happens(walkDownStaircase(eater2,staircase1),
   			When)
   	      ]).
 */


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',161).
% Happens(WalkThroughDoor12(Eater1,DiningRoomDoor1),5).

 /*  axiom(happens(walkThroughDoor12(eater1, diningRoomDoor1), Start_Num5),
       [b(start, Start_Num5), toffset(start, 5, Start_Num5)]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',161).

 /*  (   b(start, When),
       toffset(start, 5, When)
   ->  happens(walkThroughDoor12(eater1, diningRoomDoor1), When)
   ).
 */
if b(start, When), toffset(start, 5, When)then happens(walkThroughDoor12(eater1, diningRoomDoor1), When).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',161).

 /*  reactive_rule([b(start,When),toffset(start,5,When)],
   	      [ happens(walkThroughDoor12(eater1,diningRoomDoor1),
   			When)
   	      ]).
 */


% Happens(WalkThroughDoor12(Eater2,DiningRoomDoor1),6).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',161).

 /*  axiom(happens(walkThroughDoor12(eater2, diningRoomDoor1), Start_Num6),
       [b(start, Start_Num6), toffset(start, 6, Start_Num6)]).
 */

 /*  (   b(start, When),
       toffset(start, 6, When)
   ->  happens(walkThroughDoor12(eater2, diningRoomDoor1), When)
   ).
 */
if b(start, When), toffset(start, 6, When)then happens(walkThroughDoor12(eater2, diningRoomDoor1), When).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',161).

 /*  reactive_rule([b(start,When),toffset(start,6,When)],
   	      [ happens(walkThroughDoor12(eater2,diningRoomDoor1),
   			When)
   	      ]).
 */


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',163).
% Happens(SitOn(Eater1,Chair1),7).

 /*  axiom(happens(sitOn(eater1, chair1), Start_Num7),
       [b(start, Start_Num7), toffset(start, 7, Start_Num7)]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',163).

 /*  (   b(start, When),
       toffset(start, 7, When)
   ->  happens(sitOn(eater1, chair1), When)
   ).
 */
if b(start, When), toffset(start, 7, When)then happens(sitOn(eater1, chair1), When).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',163).

 /*  reactive_rule([b(start,When),toffset(start,7,When)],
   	      [happens(sitOn(eater1,chair1),When)]).
 */


% Happens(SitOn(Eater2,Chair2),8).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',163).

 /*  axiom(happens(sitOn(eater2, chair2), Start_Num8),
       [b(start, Start_Num8), toffset(start, 8, Start_Num8)]).
 */

 /*  (   b(start, When),
       toffset(start, 8, When)
   ->  happens(sitOn(eater2, chair2), When)
   ).
 */
if b(start, When), toffset(start, 8, When)then happens(sitOn(eater2, chair2), When).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',163).

 /*  reactive_rule([b(start,When),toffset(start,8,When)],
   	      [happens(sitOn(eater2,chair2),When)]).
 */


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',165).
% Happens(PickUp(Cook1, Food1),9).

 /*  axiom(happens(pickUp(cook1, food1), Start_Num9),
       [b(start, Start_Num9), toffset(start, 9, Start_Num9)]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',165).

 /*  (   b(start, When),
       toffset(start, 9, When)
   ->  happens(pickUp(cook1, food1), When)
   ).
 */
if b(start, When), toffset(start, 9, When)then happens(pickUp(cook1, food1), When).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',165).

 /*  reactive_rule([b(start,When),toffset(start,9,When)],
   	      [happens(pickUp(cook1,food1),When)]).
 */


% Happens(WalkThroughDoor21(Cook1, KitchenDoor1),10).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',165).

 /*  axiom(happens(walkThroughDoor21(cook1, kitchenDoor1), Start_Num10),
       [b(start, Start_Num10), toffset(start, 10, Start_Num10)]).
 */

 /*  (   b(start, When),
       toffset(start, 10, When)
   ->  happens(walkThroughDoor21(cook1, kitchenDoor1), When)
   ).
 */
if b(start, When), toffset(start, 10, When)then happens(walkThroughDoor21(cook1, kitchenDoor1), When).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',165).

 /*  reactive_rule([b(start,When),toffset(start,10,When)],
   	      [ happens(walkThroughDoor21(cook1,kitchenDoor1),
   			When)
   	      ]).
 */


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',167).
% Happens(PlaceOn(Cook1, Food1, Table1),11).

 /*  axiom(happens(placeOn(cook1, food1, table1), Start_Num11),
       [b(start, Start_Num11), toffset(start, 11, Start_Num11)]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',167).

 /*  (   b(start, When),
       toffset(start, 11, When)
   ->  happens(placeOn(cook1, food1, table1), When)
   ).
 */
if b(start, When), toffset(start, 11, When)then happens(placeOn(cook1, food1, table1), When).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',167).

 /*  reactive_rule([b(start,When),toffset(start,11,When)],
   	      [happens(placeOn(cook1,food1,table1),When)]).
 */


% Happens(WalkThroughDoor12(Cook1, KitchenDoor1),12).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',167).

 /*  axiom(happens(walkThroughDoor12(cook1, kitchenDoor1), Start_Num12),
       [b(start, Start_Num12), toffset(start, 12, Start_Num12)]).
 */

 /*  (   b(start, When),
       toffset(start, 12, When)
   ->  happens(walkThroughDoor12(cook1, kitchenDoor1), When)
   ).
 */
if b(start, When), toffset(start, 12, When)then happens(walkThroughDoor12(cook1, kitchenDoor1), When).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',167).

 /*  reactive_rule([b(start,When),toffset(start,12,When)],
   	      [ happens(walkThroughDoor12(cook1,kitchenDoor1),
   			When)
   	      ]).
 */


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',169).
% Happens(Eat(Eater1,Food1),13).

 /*  axiom(happens(eat(eater1, food1), Start_Num13),
       [b(start, Start_Num13), toffset(start, 13, Start_Num13)]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',169).

 /*  (   b(start, When),
       toffset(start, 13, When)
   ->  happens(eat(eater1, food1), When)
   ).
 */
if b(start, When), toffset(start, 13, When)then happens(eat(eater1, food1), When).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',169).

 /*  reactive_rule([b(start,When),toffset(start,13,When)],
   	      [happens(eat(eater1,food1),When)]).
 */


% Happens(Eat(Eater2,Food1),14).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',169).

 /*  axiom(happens(eat(eater2, food1), Start_Num14),
       [b(start, Start_Num14), toffset(start, 14, Start_Num14)]).
 */

 /*  (   b(start, When),
       toffset(start, 14, When)
   ->  happens(eat(eater2, food1), When)
   ).
 */
if b(start, When), toffset(start, 14, When)then happens(eat(eater2, food1), When).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',169).

 /*  reactive_rule([b(start,When),toffset(start,14,When)],
   	      [happens(eat(eater2,food1),When)]).
 */


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',171).
% Happens(Converse(Eater1,Eater2),15).

 /*  axiom(happens(converse(eater1, eater2), Start_Num15),
       [b(start, Start_Num15), toffset(start, 15, Start_Num15)]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',171).

 /*  (   b(start, When),
       toffset(start, 15, When)
   ->  happens(converse(eater1, eater2), When)
   ).
 */
if b(start, When), toffset(start, 15, When)then happens(converse(eater1, eater2), When).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',171).

 /*  reactive_rule([b(start,When),toffset(start,15,When)],
   	      [happens(converse(eater1,eater2),When)]).
 */


% Happens(TalkAbout(Eater1,Content1),16).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',171).

 /*  axiom(happens(talkAbout(eater1, content1), Start_Num16),
       [b(start, Start_Num16), toffset(start, 16, Start_Num16)]).
 */

 /*  (   b(start, When),
       toffset(start, 16, When)
   ->  happens(talkAbout(eater1, content1), When)
   ).
 */
if b(start, When), toffset(start, 16, When)then happens(talkAbout(eater1, content1), When).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',171).

 /*  reactive_rule([b(start,When),toffset(start,16,When)],
   	      [happens(talkAbout(eater1,content1),When)]).
 */


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',173).
% Happens(TalkAbout(Eater2,Content2),17).

 /*  axiom(happens(talkAbout(eater2, content2), Start_Num17),
       [b(start, Start_Num17), toffset(start, 17, Start_Num17)]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',173).

 /*  (   b(start, When),
       toffset(start, 17, When)
   ->  happens(talkAbout(eater2, content2), When)
   ).
 */
if b(start, When), toffset(start, 17, When)then happens(talkAbout(eater2, content2), When).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',173).

 /*  reactive_rule([b(start,When),toffset(start,17,When)],
   	      [happens(talkAbout(eater2,content2),When)]).
 */


% Happens(RiseFrom(Eater1,Chair1),18).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',173).

 /*  axiom(happens(riseFrom(eater1, chair1), Start_Num18),
       [b(start, Start_Num18), toffset(start, 18, Start_Num18)]).
 */

 /*  (   b(start, When),
       toffset(start, 18, When)
   ->  happens(riseFrom(eater1, chair1), When)
   ).
 */
if b(start, When), toffset(start, 18, When)then happens(riseFrom(eater1, chair1), When).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',173).

 /*  reactive_rule([b(start,When),toffset(start,18,When)],
   	      [happens(riseFrom(eater1,chair1),When)]).
 */


:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',175).
% Happens(RiseFrom(Eater2,Chair2),19).

 /*  axiom(happens(riseFrom(eater2, chair2), Start_Num19),
       [b(start, Start_Num19), toffset(start, 19, Start_Num19)]).
 */
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',175).

 /*  (   b(start, When),
       toffset(start, 19, When)
   ->  happens(riseFrom(eater2, chair2), When)
   ).
 */
if b(start, When), toffset(start, 19, When)then happens(riseFrom(eater2, chair2), When).
:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',175).

 /*  reactive_rule([b(start,When),toffset(start,19,When)],
   	      [happens(riseFrom(eater2,chair2),When)]).
 */

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',177).
% range time 0 20
range(time,0,20).

% range offset 0 0
range(offset,0,0).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',179).
% range diameter 0 0
range(diameter,0,0).

:-was_s_l('/pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e',181).
% completion Happens
completion(happens).
%; End of file.
% translate: ending  File: /pack/logicmoo_ec/ext/ec_sources/ecnet/EatingInAHouse.e.lps 
