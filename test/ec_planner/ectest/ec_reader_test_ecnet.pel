:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test.e',4647).
:- call_pel_directive(translate(unskipped,
                                '/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.pel')).
:-include(library('ec_planner/ec_test_incl')).
:-expects_dialect(ecalc).
:- call_pel_directive(translate(begining,
                                '/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.pel')).
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%; FILE: foundations/Root.e
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;
%; Copyright (c) 2005 IBM Corporation and others.
%; All rights reserved. This program and the accompanying materials
%; are made available under the terms of the Common Public License v1.0
%; which accompanies this distribution, and is available at
%; http://www.eclipse.org/legal/cpl-v10.html
%;
%; Contributors:
%; IBM - Initial implementation
%;

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',18).
% sort boolean
sort(boolean).

% sort integer
sort(integer).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',20).
% reified sort predicate
reified_sort(predicate).

% reified sort function
reified_sort(function).
%; End of file.
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%; FILE: foundations/EC.e
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;
%; Copyright (c) 2005 IBM Corporation and others.
%; All rights reserved. This program and the accompanying materials
%; are made available under the terms of the Common Public License v1.0
%; which accompanies this distribution, and is available at
%; http://www.eclipse.org/legal/cpl-v10.html
%;
%; Contributors:
%; IBM - Initial implementation
%;
%; Event Calculus (EC)
%;
%; @incollection{MillerShanahan:2002,
%;   author = "Rob Miller and Murray Shanahan",
%;   year = "2002",
%;   title = "Some alternative formulations of the event calculus",
%;   editor = "Antonis C. Kakas and Fariba Sadri",
%;   booktitle = "Computational Logic: Logic Programming and Beyond: Essays in Honour of \uppercase{R}obert \uppercase{A}. \uppercase{K}owalski, Part \uppercase{II}",
%;   series = "Lecture Notes in Computer Science",
%;   volume = "2408",
%;   pages = "452--490",
%;   address = "Berlin",
%;   publisher = "Springer",
%; }
%;

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',57).
% sort time: integer
subsort(time,integer).

% sort offset: integer
subsort(offset,integer).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',60).
% reified sort fluent
reified_sort(fluent).

% reified sort event
reified_sort(event).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',63).
% predicate Happens(event,time)
predicate(happens_at(event,time)).

% predicate HoldsAt(fluent,time)
predicate(holds_at(fluent,time)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',65).
% predicate ReleasedAt(fluent,time)
predicate(released_at(fluent,time)).

% predicate Initiates(event,fluent,time)
predicate(initiates_at(event,fluent,time)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',67).
% predicate Terminates(event,fluent,time)
predicate(terminates_at(event,fluent,time)).

% predicate Releases(event,fluent,time)
predicate(releases_at(event,fluent,time)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',69).
% predicate Trajectory(fluent,time,fluent,offset)
predicate(trajectory(fluent,time,fluent,offset)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',71).
%; End of file.
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%; FILE: foundations/DEC.e
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;
%; Copyright (c) 2005 IBM Corporation and others.
%; All rights reserved. This program and the accompanying materials
%; are made available under the terms of the Common Public License v1.0
%; which accompanies this distribution, and is available at
%; http://www.eclipse.org/legal/cpl-v10.html
%;
%; Contributors:
%; IBM - Initial implementation
%;
%; Discrete Event Calculus (DEC)
%;
%; @article{Mueller:2004a,
%;   author = "Erik T. Mueller",
%;   year = "2004",
%;   title = "Event calculus reasoning through satisfiability",
%;   journal = "Journal of Logic and Computation",
%;   volume = "14",
%;   number = "5",
%;   pages = "703--730",
%; }
%;

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',102).
% sort time: integer
subsort(time,integer).

% sort offset: integer
subsort(offset,integer).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',105).
% reified sort fluent
reified_sort(fluent).

% reified sort event
reified_sort(event).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',108).
% predicate Happens(event,time)
predicate(happens_at(event,time)).

% predicate HoldsAt(fluent,time)
predicate(holds_at(fluent,time)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',110).
% predicate ReleasedAt(fluent,time)
predicate(released_at(fluent,time)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',112).
% predicate Initiates(event,fluent,time)
predicate(initiates_at(event,fluent,time)).

% predicate Terminates(event,fluent,time)
predicate(terminates_at(event,fluent,time)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',114).
% predicate Releases(event,fluent,time)
predicate(releases_at(event,fluent,time)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',116).
% [fluent,time]
% (HoldsAt(fluent,time) &
%  !ReleasedAt(fluent,time+1) &
%  !({event} Happens(event,time) & Terminates(event,fluent,time))) ->
% HoldsAt(fluent,time+1).
holds_at(Fluent, Time), not(released_at(Fluent, Time+1)), not(exists([Event],  (happens_at(Event, Time), terminates_at(Event, Fluent, Time)))) ->
    holds_at(Fluent, Time+1).


% [fluent,time]
% (!HoldsAt(fluent,time) &
%  !ReleasedAt(fluent,time+1) &
%  !({event} Happens(event,time) & Initiates(event,fluent,time))) ->
% !HoldsAt(fluent,time+1).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',123).
holds_at(not(Fluent), Time), not(released_at(Fluent, Time+1)), not(exists([Event],  (happens_at(Event, Time), initiates_at(Event, Fluent, Time)))) ->
    holds_at(not(Fluent), Time+1).


% [fluent,time]
% (!ReleasedAt(fluent,time) &
%  !({event} Happens(event,time) & Releases(event,fluent,time))) ->
% !ReleasedAt(fluent,time+1).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',129).
not(released_at(Fluent, Time)), not(exists([Event],  (happens_at(Event, Time), releases_at(Event, Fluent, Time)))) ->
    not(released_at(Fluent, Time+1)).


% [fluent,time]
% (ReleasedAt(fluent,time) &
%  !({event} Happens(event,time) &
%    (Initiates(event,fluent,time) |
%     Terminates(event,fluent,time)))) ->
% ReleasedAt(fluent,time+1).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',134).
released_at(Fluent, Time), not(exists([Event],  (happens_at(Event, Time), (initiates_at(Event, Fluent, Time);terminates_at(Event, Fluent, Time))))) ->
    released_at(Fluent, Time+1).


% [event,fluent,time]
% (Happens(event,time) & Initiates(event,fluent,time)) ->
% (HoldsAt(fluent,time+1) & !ReleasedAt(fluent,time+1)).
happens_at(Event, Time), initiates_at(Event, Fluent, Time) ->
    holds_at(Fluent, Time+1),
    not(released_at(Fluent, Time+1)).


% [event,fluent,time]
% (Happens(event,time) & Terminates(event,fluent,time)) ->
% (!HoldsAt(fluent,time+1) & !ReleasedAt(fluent,time+1)).
happens_at(Event, Time), terminates_at(Event, Fluent, Time) ->
    holds_at(not(Fluent), Time+1),
    not(released_at(Fluent, Time+1)).


% [event,fluent,time]
% (Happens(event,time) & Releases(event,fluent,time)) ->
% ReleasedAt(fluent,time+1).
happens_at(Event, Time), releases_at(Event, Fluent, Time) ->
    released_at(Fluent, Time+1).


%; End of file.
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%; FILE: foundations/ECCausal.e
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;
%; Copyright (c) 2005 IBM Corporation and others.
%; All rights reserved. This program and the accompanying materials
%; are made available under the terms of the Common Public License v1.0
%; which accompanies this distribution, and is available at
%; http://www.eclipse.org/legal/cpl-v10.html
%;
%; Contributors:
%; IBM - Initial implementation
%;
%; Causal Constraints
%;
%; @inproceedings{Shanahan:1999a,
%;   author = "Murray Shanahan",
%;   year = "1999",
%;   title = "The ramification problem in the event calculus",
%;   booktitle = "\uppercase{P}roceedings of the \uppercase{S}ixteenth \uppercase{I}nternational \uppercase{J}oint \uppercase{C}onference on \uppercase{A}rtificial \uppercase{I}ntelligence",
%;   pages = "140--146",
%;   address = "San Mateo, CA",
%;   publisher = "Morgan Kaufmann",
%; }
%;

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',183).
% predicate Started(fluent,time)
predicate(started(fluent,time)).

% predicate Stopped(fluent,time)
predicate(stopped(fluent,time)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',186).
% [fluent,time]
% Started(fluent,time) <->
% (HoldsAt(fluent,time) |
%  ({event} Happens(event,time) & Initiates(event,fluent,time))).
started(Fluent, Time) <->
    (   holds_at(Fluent, Time)
    ;   exists([Event],
                (happens_at(Event, Time), initiates_at(Event, Fluent, Time)))
    ).


% [fluent,time]
% Stopped(fluent,time) <->
% (!HoldsAt(fluent,time) |
%  ({event} Happens(event,time) & Terminates(event,fluent,time))).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',192).
stopped(Fluent, Time) <->
    (   holds_at(not(Fluent), Time)
    ;   exists([Event],
                (happens_at(Event, Time), terminates_at(Event, Fluent, Time)))
    ).

% predicate Initiated(fluent,time)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',195).
predicate(initiated(fluent,time)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',197).
% predicate Terminated(fluent,time)
predicate(terminated(fluent,time)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',199).
% [fluent,time]
% Initiated(fluent,time) <->
% (Started(fluent,time) &
%  !({event} Happens(event,time) & Terminates(event,fluent,time))).
initiated(Fluent, Time) <->
    started(Fluent, Time),
    not(exists([Event],
                (happens_at(Event, Time), terminates_at(Event, Fluent, Time)))).


% [fluent,time]
% Terminated(fluent,time) <->
% (Stopped(fluent,time) &
%  !({event} Happens(event,time) & Initiates(event,fluent,time))).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',205).
terminated(Fluent, Time) <->
    stopped(Fluent, Time),
    not(exists([Event],
                (happens_at(Event, Time), initiates_at(Event, Fluent, Time)))).


%; End of file.
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%; FILE: foundations/ECTraj.e
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;
%; Copyright (c) 2005 IBM Corporation and others.
%; All rights reserved. This program and the accompanying materials
%; are made available under the terms of the Common Public License v1.0
%; which accompanies this distribution, and is available at
%; http://www.eclipse.org/legal/cpl-v10.html
%;
%; Contributors:
%; IBM - Initial implementation
%;
%; @incollection{MillerShanahan:2002,
%;   author = "Rob Miller and Murray Shanahan",
%;   year = "2002",
%;   title = "Some alternative formulations of the event calculus",
%;   editor = "Antonis C. Kakas and Fariba Sadri",
%;   booktitle = "Computational Logic: Logic Programming and Beyond: Essays in Honour of \uppercase{R}obert \uppercase{A}. \uppercase{K}owalski, Part \uppercase{II}",
%;   series = "Lecture Notes in Computer Science",
%;   volume = "2408",
%;   pages = "452--490",
%;   address = "Berlin",
%;   publisher = "Springer",
%; }
%;

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',241).
% predicate Clipped(time,fluent,time)
predicate(clipped(time,fluent,time)).

% predicate Declipped(time,fluent,time)
predicate(declipped(time,fluent,time)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',244).
% predicate Trajectory(fluent,time,fluent,offset)
predicate(trajectory(fluent,time,fluent,offset)).

% predicate AntiTrajectory(fluent,time,fluent,offset)
predicate(antiTrajectory(fluent,time,fluent,offset)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',247).
% [event,fluent,fluent2,offset,time]
% Happens(event,time) &
% Initiates(event,fluent,time) &
% 0 < offset &
% Trajectory(fluent,time,fluent2,offset) &
% !Clipped(time,fluent,time+offset) ->
% HoldsAt(fluent2,time+offset).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',247).
happens_at(Event, Time), initiates_at(Event, Fluent, Time), 0<Offset, trajectory(Fluent, Time, Fluent2, Offset), not(clipped(Time, Fluent, Time+Offset)) ->
    holds_at(Fluent2, Time+Offset).


% [event,fluent,fluent2,offset,time]
% Happens(event,time) &
% Terminates(event,fluent,time) &
% 0 < offset &
% AntiTrajectory(fluent,time,fluent2,offset) &
% !Declipped(time,fluent,time+offset) ->
% HoldsAt(fluent2,time+offset).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',256).
happens_at(Event, Time), terminates_at(Event, Fluent, Time), 0<Offset, antiTrajectory(Fluent, Time, Fluent2, Offset), not(declipped(Time, Fluent, Time+Offset)) ->
    holds_at(Fluent2, Time+Offset).


%; End of file.
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%; FILE: ecnet/Ontology.e
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;
%; Copyright (c) 2005 IBM Corporation and others.
%; All rights reserved. This program and the accompanying materials
%; are made available under the terms of the Common Public License v1.0
%; which accompanies this distribution, and is available at
%; http://www.eclipse.org/legal/cpl-v10.html
%;
%; Contributors:
%; IBM - Initial implementation
%;
%; integer
%;

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',284).
% sort diameter: integer
subsort(diameter,integer).
%; object

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',288).
% sort object
sort(object).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',290).
% sort agent: object
subsort(agent,object).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',292).
% sort physobj: object
subsort(physobj,object).

% sort bed: physobj
subsort(bed,physobj).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',294).
% sort snowflake: physobj
subsort(snowflake,physobj).

% sort sky: physobj
subsort(sky,physobj).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',297).
% sort stuff: physobj
subsort(stuff,physobj).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',299).
% sort surface: physobj
subsort(surface,physobj).

% sort ground: surface
subsort(ground,surface).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',302).
% sort snow: stuff
subsort(snow,stuff).

% sort ball
sort(ball).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',305).
% sort food: physobj
subsort(food,physobj).

% sort fruit: food
subsort(fruit,food).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',307).
% sort orange: fruit
subsort(orange,fruit).

% sort salad: food
subsort(salad,food).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',310).
% sort clothing: physobj
subsort(clothing,physobj).

% sort scarf: clothing
subsort(scarf,clothing).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',312).
% sort hat: clothing
subsort(hat,clothing).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',314).
% sort vegetablematter: physobj
subsort(vegetablematter,physobj).

% sort coal: vegetablematter
subsort(coal,vegetablematter).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',317).
% sort bodypart: physobj
subsort(bodypart,physobj).

% sort hand: bodypart
subsort(hand,bodypart).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',320).
% sort papertowels: physobj
subsort(papertowels,physobj).

% sort device: physobj
subsort(device,physobj).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',322).
% sort electronicdevice: device
subsort(electronicdevice,device).

% sort lamp: electronicdevice
subsort(lamp,electronicdevice).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',325).
% sort cat: physobj
subsort(cat,physobj).

% sort horse: physobj
subsort(horse,physobj).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',328).
% sort weapon: physobj
subsort(weapon,physobj).

% sort gun: weapon
subsort(gun,weapon).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',330).
% sort bomb: weapon
subsort(bomb,weapon).

% sort bullet: weapon
subsort(bullet,weapon).
%; location

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',335).
% sort location
sort(location).

% sort room: location, outside: location
subsort(room,location).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',335).
subsort(outside,location).
%; portal

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',340).
% sort portal
sort(portal).

% sort door: portal, staircase: portal
subsort(door,portal).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',340).
subsort(staircase,portal).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',342).
% sort street: portal
subsort(street,portal).

% sort track: portal
subsort(track,portal).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',345).
% sort building
sort(building).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',347).
% sort fire: object
subsort(fire,object).

% sort smoke: physobj
subsort(smoke,physobj).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',350).
% sort furniture: physobj
subsort(furniture,physobj).

% sort chair: furniture
subsort(chair,furniture).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',352).
% sort table: furniture
subsort(table,furniture).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',354).
% sort bill: physobj
subsort(bill,physobj).

% sort ticket: physobj
subsort(ticket,physobj).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',356).
% sort envelope: physobj
subsort(envelope,physobj).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',358).
% sort text: physobj
subsort(text,physobj).

% sort book: text
subsort(book,text).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',360).
% sort letter: text
subsort(letter,text).

% sort menu: text
subsort(menu,text).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',363).
% sort paper: physobj
subsort(paper,physobj).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',365).
% sort content
sort(content).

% sort script
sort(script).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',368).
% sort container: physobj
subsort(container,physobj).

% sort cigarette: physobj
subsort(cigarette,physobj).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',370).
% sort ashtray: physobj
subsort(ashtray,physobj).

% sort umbrella: physobj
subsort(umbrella,physobj).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',373).
% sort pen: physobj
subsort(pen,physobj).
%; End of file.
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%; FILE: ecnet/RTSpace.e
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;
%; Copyright (c) 2005 IBM Corporation and others.
%; All rights reserved. This program and the accompanying materials
%; are made available under the terms of the Common Public License v1.0
%; which accompanies this distribution, and is available at
%; http://www.eclipse.org/legal/cpl-v10.html
%;
%; Contributors:
%; IBM - Initial implementation
%;
%; RTSpace: room-scale topological space
%;
%; We use topological and metric representations of space,
%; at two levels of granularity---room-scale and object-scale.
%; The RTSpace representation deals with topological space at
%; the scale of rooms and outdoor locations.
%; This representation of space consists of locations, which
%; are connected by portals. There are two types of locations:
%; rooms and outside areas (outsides).
%;
%; object is at location.

% fluent At(object,location)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',404).
fluent(at_loc(object,location)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',406).
% manualrelease At
:- call_pel_directive(manualrelease(at_loc)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',408).
% [object1,location,time]
% (% {object2} PartOf(object1,object2)) ->
% ReleasedAt(At(object1,location),time).
exists([Object2],  (partOf(Object1, Object2)->released_at(at_loc(Object1, Location), Time))).


%; A state constraint says that an object
%; is at one location at a time:
% [object,location1,location2,time]
% HoldsAt(At(object,location1),time) &
% HoldsAt(At(object,location2),time) ->
% location1=location2.
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',414).
holds_at(at_loc(Object, Location1), Time), holds_at(at_loc(Object, Location2), Time) ->
    Location1=Location2.


%; connectivity
%; Side one of portal is location.

% function Side1(portal): location
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',421).
function(side1(portal),location).
%; Side two of portal is location.

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',424).
% function Side2(portal): location
function(side2(portal),location).
%; The building of room is building.

% function BuildingOf(room): building
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',426).
function(buildingOf(room),building).
%; object is at a location that has portal.

% fluent NearPortal(object,portal)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',429).
fluent(nearPortal(object,portal)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',431).
% noninertial NearPortal
:- call_pel_directive(noninertial(nearPortal)).
%; A state constraint says that an object is near
%; a portal if and only if there is a location such that
%; the object is at the location and one of the sides
%; of the portal is the location:
% [object,portal,time]
% HoldsAt(NearPortal(object,portal),time) <->
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',437).
% {location}% 
%  (Side1(portal)=location|
%   Side2(portal)=location) &
%  HoldsAt(At(object,location),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',439).
exists([Location],  (holds_at(nearPortal(Object, Portal), Time)<->(side1(Portal)=Location;side2(Portal)=Location), holds_at(at_loc(Object, Location), Time))).


%; locking and unlocking doors
%; agent unlocks door.

% event DoorUnlock(agent,door)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',446).
event(doorUnlock(agent,door)).


%; agent locks door.

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',449).
% event DoorLock(agent,door)
event(doorLock(agent,door)).


%; door is unlocked.

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',451).
% fluent DoorUnlocked(door)
fluent(doorUnlocked(door)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',453).
%; A precondition axiom states that
%; for an agent to unlock a door,
%; the agent must be awake,
%; the door must not already be unlocked, and
%; the agent must be near the door:
% [agent,door,time]
% Happens(DoorUnlock(agent,door),time) ->
% HoldsAt(Awake(agent),time) &
% !HoldsAt(DoorUnlocked(door),time) &
% HoldsAt(NearPortal(agent,door),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',458).
happens_at(doorUnlock(Agent, Door), Time) ->
    holds_at(awake(Agent), Time),
    holds_at(not(doorUnlocked(Door)), Time),
    holds_at(nearPortal(Agent, Door), Time).


%; An effect axiom states that
%; if an agent unlocks a door,
%; the door will be unlocked:
% [agent,door,time]
% Initiates(DoorUnlock(agent,door),DoorUnlocked(door),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',467).
initiates_at(doorUnlock(Agent,Door),
	     doorUnlocked(Door),
	     Time).


%; A precondition axiom states that
%; for an agent to lock a door,
%; the agent must be awake,
%; the door must be unlocked, and
%; the agent must be near the door:
% [agent,door,time]
% Happens(DoorLock(agent,door),time) ->
% HoldsAt(Awake(agent),time) &
% HoldsAt(DoorUnlocked(door),time) &
% HoldsAt(NearPortal(agent,door),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',475).
happens_at(doorLock(Agent, Door), Time) ->
    holds_at(awake(Agent), Time),
    holds_at(doorUnlocked(Door), Time),
    holds_at(nearPortal(Agent, Door), Time).


%; An effect axiom states that
%; if an agent locks a door,
%; the door will no longer be unlocked.
% [agent,door,time]
% Terminates(DoorLock(agent,door),DoorUnlocked(door),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',484).
terminates_at(doorLock(Agent,Door),
	      doorUnlocked(Door),
	      Time).


%; A state constraint says that if a door is open,
%; it is unlocked:
% [door,time]
% HoldsAt(DoorIsOpen(door),time) -> HoldsAt(DoorUnlocked(door),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',489).
holds_at(doorIsOpen(Door), Time) ->
    holds_at(doorUnlocked(Door), Time).


%; opening and closing doors
%; agent opens door.

% event DoorOpen(agent,door)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',494).
event(doorOpen(agent,door)).


%; agent closes door.

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',497).
% event DoorClose(agent,door)
event(doorClose(agent,door)).


%; door is open.

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',499).
% fluent DoorIsOpen(door)
fluent(doorIsOpen(door)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',501).
%; A precondition axiom states that
%; for an agent to open a door,
%; the agent must be awake,
%; the door must not already be open,
%; the door must be unlocked, and
%; the agent must be near the door:
% [agent,door,time]
% Happens(DoorOpen(agent,door),time) ->
% HoldsAt(Awake(agent),time) &
% !HoldsAt(DoorIsOpen(door),time) &
% HoldsAt(DoorUnlocked(door),time) &
% HoldsAt(NearPortal(agent,door),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',507).
happens_at(doorOpen(Agent, Door), Time) ->
    holds_at(awake(Agent), Time),
    holds_at(not(doorIsOpen(Door)), Time),
    holds_at(doorUnlocked(Door), Time),
    holds_at(nearPortal(Agent, Door), Time).


%; An effect axiom states that
%; if an agent opens a door,
%; the door will be open:
% [agent,door,time]
% Initiates(DoorOpen(agent,door),DoorIsOpen(door),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',517).
initiates_at(doorOpen(Agent,Door),
	     doorIsOpen(Door),
	     Time).


%; A precondition axiom states that
%; for an agent to close a door,
%; the agent must be awake,
%; the door must be open,
%; the door must be unlocked, and
%; the agent must be near the door:
% [agent,door,time]
% Happens(DoorClose(agent,door),time) ->
% HoldsAt(Awake(agent),time) &
% HoldsAt(DoorIsOpen(door),time) &
% HoldsAt(DoorUnlocked(door),time) &
% HoldsAt(NearPortal(agent,door),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',526).
happens_at(doorClose(Agent, Door), Time) ->
    holds_at(awake(Agent), Time),
    holds_at(doorIsOpen(Door), Time),
    holds_at(doorUnlocked(Door), Time),
    holds_at(nearPortal(Agent, Door), Time).


%; An effect axiom states that
%; if an agent closes a door,
%; the door will no longer be open:
% [agent,door,time]
% Terminates(DoorClose(agent,door),DoorIsOpen(door),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',536).
terminates_at(doorClose(Agent,Door),
	      doorIsOpen(Door),
	      Time).


%; passing through doors
%; agent walks through side one of door.

% event WalkThroughDoor12(agent,door)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',541).
event(walkThroughDoor12(agent,door)).


%; agent walks through side two of door.

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',544).
% event WalkThroughDoor21(agent,door)
event(walkThroughDoor21(agent,door)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',546).
%; Precondition axioms state that
%; for an agent to walk through a side of a door,
%; the agent must be awake and standing,
%; the door must be open, and
%; the agent must be at the side of the door that
%; the agent walks through:
% [agent,door,time]
% Happens(WalkThroughDoor12(agent,door),time) ->
% HoldsAt(Awake(agent),time) &
% HoldsAt(Standing(agent),time) &
% HoldsAt(DoorIsOpen(door),time) &
% HoldsAt(At(agent,Side1(door)),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',552).
happens_at(walkThroughDoor12(Agent, Door), Time) ->
    holds_at(awake(Agent), Time),
    holds_at(standing(Agent), Time),
    holds_at(doorIsOpen(Door), Time),
    holds_at(at_loc(Agent, side1(Door)), Time).


% [agent,door,time]
% Happens(WalkThroughDoor21(agent,door),time) ->
% HoldsAt(Awake(agent),time) &
% HoldsAt(Standing(agent),time) &
% HoldsAt(DoorIsOpen(door),time) &
% HoldsAt(At(agent,Side2(door)),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',560).
happens_at(walkThroughDoor21(Agent, Door), Time) ->
    holds_at(awake(Agent), Time),
    holds_at(standing(Agent), Time),
    holds_at(doorIsOpen(Door), Time),
    holds_at(at_loc(Agent, side2(Door)), Time).


%; Effect axioms state that
%; if an agent walks through one side of a door,
%; the agent will be at the other side of the door:
% [agent,door,location,time]
% Side2(door)=location ->
% Initiates(WalkThroughDoor12(agent,door),At(agent,location),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',569).
side2(Door)=Location ->
    initiates_at(walkThroughDoor12(Agent, Door),
                 at_loc(Agent, Location),
                 Time).


% [agent,door,location,time]
% Side1(door)=location ->
% Initiates(WalkThroughDoor21(agent,door),At(agent,location),time).
side1(Door)=Location ->
    initiates_at(walkThroughDoor21(Agent, Door),
                 at_loc(Agent, Location),
                 Time).


% [agent,door,location,time]
% Side1(door)=location ->
% Terminates(WalkThroughDoor12(agent,door),At(agent,location),time).
side1(Door)=Location ->
    terminates_at(walkThroughDoor12(Agent, Door),
                  at_loc(Agent, Location),
                  Time).


% [agent,door,location,time]
% Side2(door)=location ->
% Terminates(WalkThroughDoor21(agent,door),At(agent,location),time).
side2(Door)=Location ->
    terminates_at(walkThroughDoor21(Agent, Door),
                  at_loc(Agent, Location),
                  Time).


%; walking from one end of a street to another
%; agent walks from the first end of street to the second end.

% event WalkStreet12(agent,street)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',587).
event(walkStreet12(agent,street)).


%; agent walks from the second end of street to the first end.

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',590).
% event WalkStreet21(agent,street)
event(walkStreet21(agent,street)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',592).
%; Precondition axioms state that
%; for an agent to walk from one end of a street to another,
%; the agent must be awake,
%; the agent must be standing, and
%; the agent must be at the first end of the street:
% [agent,street,time]
% Happens(WalkStreet12(agent,street),time) ->
% HoldsAt(Awake(agent),time) &
% HoldsAt(Standing(agent),time) &
% HoldsAt(At(agent,Side1(street)),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',597).
happens_at(walkStreet12(Agent, Street), Time) ->
    holds_at(awake(Agent), Time),
    holds_at(standing(Agent), Time),
    holds_at(at_loc(Agent, side1(Street)), Time).


% [agent,street,time]
% Happens(WalkStreet21(agent,street),time) ->
% HoldsAt(Awake(agent),time) &
% HoldsAt(Standing(agent),time) &
% HoldsAt(At(agent,Side2(street)),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',604).
happens_at(walkStreet21(Agent, Street), Time) ->
    holds_at(awake(Agent), Time),
    holds_at(standing(Agent), Time),
    holds_at(at_loc(Agent, side2(Street)), Time).


%; Effect axioms state that
%; if an agent walks from one end of a street to another,
%; the agent will be at the other end of the street:
% [agent,street,location,time]
% Side2(street)=location ->
% Initiates(WalkStreet12(agent,street),At(agent,location),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',612).
side2(Street)=Location ->
    initiates_at(walkStreet12(Agent, Street),
                 at_loc(Agent, Location),
                 Time).


% [agent,street,location,time]
% Side1(street)=location ->
% Initiates(WalkStreet21(agent,street),At(agent,location),time).
side1(Street)=Location ->
    initiates_at(walkStreet21(Agent, Street),
                 at_loc(Agent, Location),
                 Time).


% [agent,street,location,time]
% Side1(street)=location ->
% Terminates(WalkStreet12(agent,street),At(agent,location),time).
side1(Street)=Location ->
    terminates_at(walkStreet12(Agent, Street),
                  at_loc(Agent, Location),
                  Time).


% [agent,street,location,time]
% Side2(street)=location ->
% Terminates(WalkStreet21(agent,street),At(agent,location),time).
side2(Street)=Location ->
    terminates_at(walkStreet21(Agent, Street),
                  at_loc(Agent, Location),
                  Time).


%; floors
%; The floor of room is integer.

% function Floor(room): integer
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',630).
function(floor(room),integer).
%; walking up and down staircases
%; agent walks down staircase.

% event WalkDownStaircase(agent,staircase)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',635).
event(walkDownStaircase(agent,staircase)).


%; agent walks up staircase.

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',638).
% event WalkUpStaircase(agent,staircase)
event(walkUpStaircase(agent,staircase)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',640).
%; Precondition axioms state that
%; for an agent to walk down (up) a staircase,
%; the agent must be awake, standing, and
%; at the top (bottom) of the staircase:
% [agent,staircase,time]
% Happens(WalkDownStaircase(agent,staircase),time) ->
% HoldsAt(Awake(agent),time) &
% HoldsAt(Standing(agent),time) &
% HoldsAt(At(agent,Side2(staircase)),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',644).
happens_at(walkDownStaircase(Agent, Staircase), Time) ->
    holds_at(awake(Agent), Time),
    holds_at(standing(Agent), Time),
    holds_at(at_loc(Agent, side2(Staircase)), Time).


% [agent,staircase,time]
% Happens(WalkUpStaircase(agent,staircase),time) ->
% HoldsAt(Awake(agent),time) &
% HoldsAt(Standing(agent),time) &
% HoldsAt(At(agent,Side1(staircase)),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',651).
happens_at(walkUpStaircase(Agent, Staircase), Time) ->
    holds_at(awake(Agent), Time),
    holds_at(standing(Agent), Time),
    holds_at(at_loc(Agent, side1(Staircase)), Time).


%; Effect axioms state that
%; if an agent walks down (up) a staircase,
%; the agent will be at the bottom (top) of the staircase:
% [agent,staircase,room,time]
% Side1(staircase)=room ->
% Initiates(WalkDownStaircase(agent,staircase),At(agent,room),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',659).
side1(Staircase)=Room ->
    initiates_at(walkDownStaircase(Agent, Staircase),
                 at_loc(Agent, Room),
                 Time).


% [agent,staircase,room,time]
% Side2(staircase)=room ->
% Terminates(WalkDownStaircase(agent,staircase),At(agent,room),time).
side2(Staircase)=Room ->
    terminates_at(walkDownStaircase(Agent, Staircase),
                  at_loc(Agent, Room),
                  Time).


% [agent,staircase,room,time]
% Side2(staircase)=room ->
% Initiates(WalkUpStaircase(agent,staircase),At(agent,room),time).
side2(Staircase)=Room ->
    initiates_at(walkUpStaircase(Agent, Staircase),
                 at_loc(Agent, Room),
                 Time).


% [agent,staircase,room,time]
% Side1(staircase)=room ->
% Terminates(WalkUpStaircase(agent,staircase),At(agent,room),time).
side1(Staircase)=Room ->
    terminates_at(walkUpStaircase(Agent, Staircase),
                  at_loc(Agent, Room),
                  Time).


%; A state constraint says that if an agent is outside,
%; the agent is dressed.
% [agent,outside,time]
% HoldsAt(At(agent,outside),time) ->
% HoldsAt(Dressed(agent),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',677).
holds_at(at_loc(Agent, Outside), Time) ->
    holds_at(dressed(Agent), Time).


%; room looks out onto outside.

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',682).
% function LookOutOnto(room): outside
function(lookOutOnto(room),outside).
%; location1 is adjacent to location2.

% predicate Adjacent(location,location)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',684).
predicate(adjacent(location,location)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',687).
%; A state constraint says that
%; two locations are adjacent if and only if
%; they have a portal in common:
% [location1,location2]
 
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',690).
% Adjacent(location1,location2) <->
% {portal}% 
% (Side1(portal)=location1 &
%  Side2(portal)=location2) |
% (Side2(portal)=location1 &
%  Side1(portal)=location2).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',690).
exists([Portal],  (adjacent(Location1, Location2)<->side1(Portal)=Location1, side2(Portal)=Location2;side2(Portal)=Location1, side1(Portal)=Location2)).


%; The ground of outside is ground.

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',698).
% function GroundOf(outside): ground
function(groundOf(outside),ground).
%; The sky of outside is sky.

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',700).
% function SkyOf(outside): sky
function(skyOf(outside),sky).
%; State constraints fix the location of ground and sky:
% [outside,ground,time]
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',704).
% GroundOf(outside) = ground ->
% HoldsAt(At(ground,outside),time).
groundOf(Outside)=Ground ->
    holds_at(at_loc(Ground, Outside), Time).


% [outside,sky,time]
% SkyOf(outside) = sky ->
% HoldsAt(At(sky,outside),time).
skyOf(Outside)=Sky ->
    holds_at(at_loc(Sky, Outside), Time).


%; End of file.
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%; FILE: ecnet/OTSpace.e
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;
%; Copyright (c) 2005 IBM Corporation and others.
%; All rights reserved. This program and the accompanying materials
%; are made available under the terms of the Common Public License v1.0
%; which accompanies this distribution, and is available at
%; http://www.eclipse.org/legal/cpl-v10.html
%;
%; Contributors:
%; IBM - Initial implementation
%;
%; OTSpace: object-scale topological space
%;
%; The OTSpace representation deals with topological space at
%; the scale of objects such as agents (humans and animals)
%; and physical objects.
%;
%; PartOf
%; physobj is a part of object.

% predicate PartOf(physobj,object)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',738).
predicate(partOf(physobj,object)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',741).
%; A state constraint says that if a physical object
%; is part of an object, the location of the
%; physical object is the same as the location of the object:
% [physobj,object,location,time]
% PartOf(physobj,object) &
% HoldsAt(At(object,location),time) ->
% HoldsAt(At(physobj,location),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',744).
partOf(Physobj, Object), holds_at(at_loc(Object, Location), Time) ->
    holds_at(at_loc(Physobj, Location), Time).


%; rolling a snowball bigger
%; agent rolls stuff1 along stuff2.

% event RollAlong(agent,stuff,stuff)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',751).
event(rollAlong(agent,stuff,stuff)).


%; The diameter of ball is diameter.

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',754).
% fluent Diameter(ball,diameter)
fluent(diameter(ball,diameter)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',756).
%; A state constraint says that a ball has a unique diameter:
% [ball,diameter1,diameter2,time]
% HoldsAt(Diameter(ball,diameter1),time) &
% HoldsAt(Diameter(ball,diameter2),time) ->
% diameter1=diameter2.
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',758).
holds_at(diameter(Ball, Diameter1), Time), holds_at(diameter(Ball, Diameter2), Time) ->
    Diameter1=Diameter2.


%; Effect axiom state that if an agent rolls some snow along
%; some other snow, the diameter of the first snow will increase:
% [agent,snow1,snow2,diameter1,diameter2,time]
% HoldsAt(Diameter(snow1,diameter1),time) &
% diameter2 = diameter1+1 ->
% Initiates(RollAlong(agent,snow1,snow2),
%           Diameter(snow1,diameter2),
%           time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',764).
holds_at(diameter(Snow1, Diameter1), Time), Diameter2=Diameter1+1 ->
    initiates_at(rollAlong(Agent, Snow1, Snow2),
                 diameter(Snow1, Diameter2),
                 Time).


% [agent,snow1,snow2,diameter1,time]
% HoldsAt(Diameter(snow1,diameter1),time) ->
% Terminates(RollAlong(agent,snow1,snow2),
%            Diameter(snow1,diameter1),
%            time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',772).
holds_at(diameter(Snow1, Diameter1), Time) ->
    terminates_at(rollAlong(Agent, Snow1, Snow2),
                  diameter(Snow1, Diameter1),
                  Time).


%; A precondition axiom states that
%; for an agent to roll some snow along some other snow,
%; there must be a location such that
%; the agent is at the location,
%; the first snow is at the location, and
%; the second snow is at the location:
%;[agent,snow1,snow2,time]
%;Happens(RollAlong(agent,snow1,snow2),time) ->
%;{location}
%;HoldsAt(At(agent,location),time) &
%;HoldsAt(At(snow1,location),time) &
%;HoldsAt(At(snow2,location),time).
%; motion
%; object moves (in place).

% event Move(object)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',792).
event(move(object)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',795).
%; Holding
%; agent is holding physobj.

% fluent Holding(agent,physobj)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',797).
fluent(holding(agent,physobj)).


%; agent holds or picks up physobj.

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',800).
% event Hold(agent,physobj)
event(hold(agent,physobj)).


%; agent picks up some stuff1 from stuff2.

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',802).
% event HoldSome(agent,stuff,stuff)
event(holdSome(agent,stuff,stuff)).


%; agent releases or lets go of physobj.

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',804).
% event LetGoOf(agent,physobj)
event(letGoOf(agent,physobj)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',806).
%; An effect axiom states that if an agent holds
%; a physical object, the agent will be holding the
%; physical object:
% [agent,physobj,time]
% Initiates(Hold(agent,physobj),Holding(agent,physobj),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',809).
initiates_at(hold(Agent,Physobj),
	     holding(Agent,Physobj),
	     Time).


%; A precondition axiom states that
%; for an agent to hold a physical object,
%; there must be a location such that
%; the agent is at the location and
%; the physical object is at the location:
%;[agent,physobj,time]
%;Happens(Hold(agent,physobj),time) ->
%;{location}
%;  HoldsAt(At(agent,location),time) &
%;  HoldsAt(At(physobj,location),time).
%; An effect axiom states that if an agent
%; lets go of a physical object, the agent is no longer holding
%; the physical object:
% [agent,physobj,time]
% Terminates(LetGoOf(agent,physobj),Holding(agent,physobj),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',826).
terminates_at(letGoOf(Agent,Physobj),
	      holding(Agent,Physobj),
	      Time).


%; A precondition axiom states that
%; for an agent to let go of a physical object,
%; the agent must be holding the physical object:
% [agent,physobj,time]
% Happens(LetGoOf(agent,physobj),time) ->
% HoldsAt(Holding(agent,physobj),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',832).
happens_at(letGoOf(Agent, Physobj), Time) ->
    holds_at(holding(Agent, Physobj), Time).


%; A releases axiom states that if an agent holds
%; a physical object,
%; the physical object's location will be released
%; from inertia:
% [agent,physobj,location,time]
% Releases(Hold(agent,physobj),At(physobj,location),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',840).
releases_at(hold(Agent,Physobj),
	    at_loc(Physobj,Location),
	    Time).


%; A state constraint says that if an agent is holding
%; a physical object and the agent is at a location,
%; the physical object is also at the location:
% [agent,physobj,location,time]
% HoldsAt(Holding(agent,physobj),time) &
% HoldsAt(At(agent,location),time) ->
% HoldsAt(At(physobj,location),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',846).
holds_at(holding(Agent, Physobj), Time), holds_at(at_loc(Agent, Location), Time) ->
    holds_at(at_loc(Physobj, Location), Time).


%; A releases axiom states that if an agent holds
%; a physical object,
%; the locations of the parts of the physical object
%; will be released from inertia:
% [agent,physobj1,physobj2,location,time]
% PartOf(physobj1,physobj2) ->
% Releases(Hold(agent,physobj2),At(physobj1,location),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',855).
partOf(Physobj1, Physobj2) ->
    releases_at(hold(Agent, Physobj2),
                at_loc(Physobj1, Location),
                Time).


%; Further, if an agent holds a physical object,
%; the locations of the physical objects of which
%; the physical object is a part
%; will be released from inertia:
% [agent,physobj1,physobj2,location,time]
% PartOf(physobj1,physobj2) ->
% Releases(Hold(agent,physobj1),At(physobj2,location),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',863).
partOf(Physobj1, Physobj2) ->
    releases_at(hold(Agent, Physobj1),
                at_loc(Physobj2, Location),
                Time).


%;[agent,physobj,location1,location2,time]
%;(!{object} PartOf(physobj,object)) &
%;HoldsAt(At(agent,location1),time) &
%;location1 != location2 ->
%;Terminates(LetGoOf(agent,physobj),At(physobj,location2),time).
% [agent,physobj,location,time]
% (!{object} PartOf(physobj,object)) &
% HoldsAt(At(agent,location),time) ->
% Initiates(LetGoOf(agent,physobj),At(physobj,location),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',873).
not(exists([Object], partOf(Physobj, Object))), holds_at(at_loc(Agent, Location), Time) ->
    initiates_at(letGoOf(Agent, Physobj),
                 at_loc(Physobj, Location),
                 Time).


%;[agent,physobj1,physobj2,location1,location2,time]
%;PartOf(physobj1,physobj2) &
%;(!{object} PartOf(physobj2,object)) &
%;HoldsAt(At(agent,location1),time) &
%;location1 != location2 ->
%;Terminates(LetGoOf(agent,physobj1),At(physobj2,location2),time).
% [agent,physobj1,physobj2,location,time]
% PartOf(physobj1,physobj2) &
% (!{object} PartOf(physobj2,object)) &
% HoldsAt(At(agent,location),time) ->
% Initiates(LetGoOf(agent,physobj1),At(physobj2,location),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',885).
partOf(Physobj1, Physobj2), not(exists([Object], partOf(Physobj2, Object))), holds_at(at_loc(Agent, Location), Time) ->
    initiates_at(letGoOf(Agent, Physobj1),
                 at_loc(Physobj2, Location),
                 Time).


%; An effect axiom states that if an agent is at a location
%; and lets go of a physical object, the physical object
%; will be at the location:
% [agent,physobj,location,time]
% HoldsAt(At(agent,location),time) ->
% Initiates(LetGoOf(agent,physobj),At(physobj,location),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',894).
holds_at(at_loc(Agent, Location), Time) ->
    initiates_at(letGoOf(Agent, Physobj),
                 at_loc(Physobj, Location),
                 Time).


%; An effect axiom states that if an agent picks up
%; some stuff out of some other stuff, the agent will
%; be holding the first stuff:
% [agent,stuff1,stuff2,time]
% Initiates(HoldSome(agent,stuff1,stuff2),
%           Holding(agent,stuff1),
%           time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',901).
initiates_at(holdSome(Agent,Stuff1,Stuff2),
	     holding(Agent,Stuff1),
	     Time).


%; A precondition axiom states that
%; for an agent to pick up some stuff out of some other stuff,
%; the first stuff must be a part of the second stuff and
%; there must be a location such that the agent is at the location,
%; the first stuff is at the location, and the second stuff is
%; at the location:
% [agent,stuff1,stuff2,time]
% Happens(HoldSome(agent,stuff1,stuff2),time) ->
% PartOf(stuff1,stuff2) &
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',912).
% {location}% 
%   HoldsAt(At(agent,location),time) &
%   HoldsAt(At(stuff1,location),time) &
%   HoldsAt(At(stuff2,location),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',915).
exists([Location],  (happens_at(holdSome(Agent, Stuff1, Stuff2), Time)->partOf(Stuff1, Stuff2), holds_at(at_loc(Agent, Location), Time), holds_at(at_loc(Stuff1, Location), Time), holds_at(at_loc(Stuff2, Location), Time))).


%; A releases axiom states that if an agent picks up some
%; stuff out of some other stuff,
%; the first stuff's location will be released
%; from inertia:
% [agent,stuff1,stuff2,location,time]
% Releases(HoldSome(agent,stuff1,stuff2),At(stuff1,location),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',924).
releases_at(holdSome(Agent,Stuff1,Stuff2),
	    at_loc(Stuff1,Location),
	    Time).


%; Inside
%; physobj1 is inside physobj2.

% fluent Inside(physobj,physobj)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',929).
fluent(inside(physobj,physobj)).


%; agent puts physobj1 inside physobj2.

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',932).
% event PutInside(agent,physobj,physobj)
event(putInside(agent,physobj,physobj)).


%; agent takes physobj1 out of physobj2.

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',934).
% event TakeOutOf(agent,physobj,physobj)
event(takeOutOf(agent,physobj,physobj)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',936).
%; A state constraint says that a physical object cannot
%; be inside itself:
% [physobj1,physobj2,time]
% HoldsAt(Inside(physobj1,physobj2),time) ->
% physobj1!=physobj2.
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',938).
holds_at(inside(Physobj1, Physobj2), Time) ->
    Physobj1\=Physobj2.


%; A state constraint says that if a physical object is
%; inside another physical object, the second physical object
%; is not inside the first physical object:
% [physobj1,physobj2,time]
% HoldsAt(Inside(physobj1,physobj2),time) ->
% !HoldsAt(Inside(physobj2,physobj1),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',945).
holds_at(inside(Physobj1, Physobj2), Time) ->
    holds_at(not(inside(Physobj2, Physobj1)), Time).


%; An effect axiom states that if an agent puts a physical
%; object inside another physical object, the first
%; physical object will be inside the second physical object:
% [agent,physobj1,physobj2,time]
% Initiates(PutInside(agent,physobj1,physobj2),
%           Inside(physobj1,physobj2),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',952).
initiates_at(putInside(Agent,Physobj1,Physobj2),
	     inside(Physobj1,Physobj2),
	     Time).


%; An effect axiom states that if an agent puts a physical
%; object inside another physical object, the agent will
%; no longer be holding the first physical object:
% [agent,physobj1,physobj2,time]
% Terminates(PutInside(agent,physobj1,physobj2),
%            Holding(agent,physobj1),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',959).
terminates_at(putInside(Agent,Physobj1,Physobj2),
	      holding(Agent,Physobj1),
	      Time).


%; A precondition axiom states that
%; for an agent to put a physical object inside another
%; physical object,
%; the agent must be holding the first physical object
%; and there must be a location such that
%; the agent is at the location and
%; the second physical object is at the location:
%;[agent,physobj1,physobj2,time]
%;Happens(PutInside(agent,physobj1,physobj2),time) ->
%;HoldsAt(Holding(agent,physobj1),time) &
%;{location}
%; HoldsAt(At(agent,location),time) &
%; HoldsAt(At(physobj2,location),time).
%; An effect axiom states that
%; if an agent takes a physical object out of another
%; physical object, the first physical object
%; will no longer be inside the second physical object:
% [agent,physobj1,physobj2,time]
% Terminates(TakeOutOf(agent,physobj1,physobj2),
%            Inside(physobj1,physobj2),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',981).
terminates_at(takeOutOf(Agent,Physobj1,Physobj2),
	      inside(Physobj1,Physobj2),
	      Time).


%; A precondition axiom states that
%; for an agent to take a physical object out of another
%; physical object,
%; the first physical object must be inside the second physical object
%; and there must be a location such that
%; the agent is at the location,
%; the first physical object is at the location, and
%; the second physical object is at the location:
% [agent,physobj1,physobj2,time]
% Happens(TakeOutOf(agent,physobj1,physobj2),time) ->
% HoldsAt(Inside(physobj1,physobj2),time) &
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',993).
% {location}% 
%  HoldsAt(At(agent,location),time) &
%  HoldsAt(At(physobj1,location),time) &
%  HoldsAt(At(physobj2,location),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',996).
exists([Location],  (happens_at(takeOutOf(Agent, Physobj1, Physobj2), Time)->holds_at(inside(Physobj1, Physobj2), Time), holds_at(at_loc(Agent, Location), Time), holds_at(at_loc(Physobj1, Location), Time), holds_at(at_loc(Physobj2, Location), Time))).


%; A releases axiom states that if an agent puts a physical
%; object inside another physical object,
%; the first physical object's location will be released
%; from inertia:
% [agent,physobj1,physobj2,location,time]
% Releases(PutInside(agent,physobj1,physobj2),
%          At(physobj1,location),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1005).
releases_at(putInside(Agent,Physobj1,Physobj2),
	    at_loc(Physobj1,Location),
	    Time).


%; A state constraint says that if a physical object is inside
%; another physical object and the second physical object is
%; at a location, the first physical object is also at the location:
% [physobj1,physobj2,location,time]
% HoldsAt(Inside(physobj1,physobj2),time) &
% HoldsAt(At(physobj2,location),time) ->
% HoldsAt(At(physobj1,location),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1012).
holds_at(inside(Physobj1, Physobj2), Time), holds_at(at_loc(Physobj2, Location), Time) ->
    holds_at(at_loc(Physobj1, Location), Time).


%; An effect axiom states that if an agent takes a physical
%; object out of another physical object,
%; the agent will be holding the first physical object:
% [agent,physobj1,physobj2,time]
% Initiates(TakeOutOf(agent,physobj1,physobj2),
%           Holding(agent,physobj1),
%           time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1020).
initiates_at(takeOutOf(Agent,Physobj1,Physobj2),
	     holding(Agent,Physobj1),
	     Time).


%; On
%; physobj1 is on physobj2.

% fluent On(physobj,physobj)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1027).
fluent(on(physobj,physobj)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1030).
%; agent places physobj1 on physobj2.

% event PlaceOn(agent,physobj,physobj)
event(placeOn(agent,physobj,physobj)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1030).
%; agent takes physobj1 off of physobj2.

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1033).
% event TakeOffOf(agent,physobj,physobj)
event(takeOffOf(agent,physobj,physobj)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1035).
%; A state constraint says that a physical object cannot
%; be on itself:
% [physobj1,physobj2,time]
% HoldsAt(On(physobj1,physobj2),time) ->
% physobj1!=physobj2.
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1037).
holds_at(on(Physobj1, Physobj2), Time) ->
    Physobj1\=Physobj2.


%; A state constraint says that if a physical object is
%; on another physical object, the second physical object
%; is not on the first physical object:
% [physobj1,physobj2,time]
% HoldsAt(On(physobj1,physobj2),time) ->
% !HoldsAt(On(physobj2,physobj1),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1044).
holds_at(on(Physobj1, Physobj2), Time) ->
    holds_at(not(on(Physobj2, Physobj1)), Time).


%; An effect axiom states that if an agent places a physical
%; object on another physical object, the first
%; physical object will be on the second physical object:
% [agent,physobj1,physobj2,time]
% Initiates(PlaceOn(agent,physobj1,physobj2),
%           On(physobj1,physobj2),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1051).
initiates_at(placeOn(Agent,Physobj1,Physobj2),
	     on(Physobj1,Physobj2),
	     Time).


%; An effect axiom states that if an agent places a physical
%; object on another physical object, the agent will
%; no longer be holding the first physical object:
% [agent,physobj1,physobj2,time]
% Terminates(PlaceOn(agent,physobj1,physobj2),
%            Holding(agent,physobj1),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1058).
terminates_at(placeOn(Agent,Physobj1,Physobj2),
	      holding(Agent,Physobj1),
	      Time).


%; A precondition axiom states that
%; for an agent to place a physical object on another
%; physical object,
%; the agent must be holding the first physical object
%; and there must be a location such that
%; the agent is at the location and
%; the second physical object is at the location:
%;[agent,physobj1,physobj2,time]
%;Happens(PlaceOn(agent,physobj1,physobj2),time) ->
%;HoldsAt(Holding(agent,physobj1),time) &
%;{location}
%; HoldsAt(At(agent,location),time) &
%; HoldsAt(At(physobj2,location),time).
%; An effect axiom states that
%; if an agent takes a physical object off of another
%; physical object, the first physical object
%; will no longer be on the second physical object:
% [agent,physobj1,physobj2,time]
% Terminates(TakeOffOf(agent,physobj1,physobj2),
%            On(physobj1,physobj2),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1080).
terminates_at(takeOffOf(Agent,Physobj1,Physobj2),
	      on(Physobj1,Physobj2),
	      Time).


%; An effect axiom states that if an agent takes a physical
%; object off of another physical object,
%; the agent will be holding the first physical object:
% [agent,physobj1,physobj2,time]
% Initiates(TakeOffOf(agent,physobj1,physobj2),
%           Holding(agent,physobj1),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1087).
initiates_at(takeOffOf(Agent,Physobj1,Physobj2),
	     holding(Agent,Physobj1),
	     Time).


%; A precondition axiom states that
%; for an agent to take a physical object off of another
%; physical object,
%; the first physical object must be on the second physical object
%; and there must be a location such that
%; the agent is at the location and
%; the first physical object is at the location:
%; the second physical object is at the location:
% [agent,physobj1,physobj2,time]
% Happens(TakeOffOf(agent,physobj1,physobj2),time) ->
% HoldsAt(On(physobj1,physobj2),time) &
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1099).
% {location}% 
%  HoldsAt(At(agent,location),time) &
%  HoldsAt(At(physobj1,location),time) &
%  HoldsAt(At(physobj2,location),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1102).
exists([Location],  (happens_at(takeOffOf(Agent, Physobj1, Physobj2), Time)->holds_at(on(Physobj1, Physobj2), Time), holds_at(at_loc(Agent, Location), Time), holds_at(at_loc(Physobj1, Location), Time), holds_at(at_loc(Physobj2, Location), Time))).


%; A releases axiom states that if an agent places a physical
%; object on another physical object,
%; the first physical object's location will be released
%; from inertia:
% [agent,physobj1,physobj2,location,time]
% Releases(PlaceOn(agent,physobj1,physobj2),
%          At(physobj1,location),
%          time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1111).
releases_at(placeOn(Agent,Physobj1,Physobj2),
	    at_loc(Physobj1,Location),
	    Time).


%; A state constraint says that if a physical object is on
%; another physical object and the second physical object is
%; at a location, the first physical object is also at the location:
% [physobj1,physobj2,location,time]
% HoldsAt(On(physobj1,physobj2),time) &
% HoldsAt(At(physobj2,location),time) ->
% HoldsAt(At(physobj1,location),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1119).
holds_at(on(Physobj1, Physobj2), Time), holds_at(at_loc(Physobj2, Location), Time) ->
    holds_at(at_loc(Physobj1, Location), Time).

% fluent Near(agent,object)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1123).
fluent(near(agent,object)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1125).
% event WalkFromTo(agent,object,object)
event(walkFromTo(agent,object,object)).

% event WalkFrom(agent,object)
event(walkFrom(agent,object)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1127).
% event RunFromTo(agent,object,object)
event(runFromTo(agent,object,object)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1129).
% [agent,object1,object2,time]
% Initiates(WalkFromTo(agent,object1,object2),
%           Near(agent,object2),
%           time).
initiates_at(walkFromTo(Agent,Object1,Object2),
	     near(Agent,Object2),
	     Time).


% [agent,object1,object2,time]
% Terminates(WalkFromTo(agent,object1,object2),
%            Near(agent,object1),
%            time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1135).
terminates_at(walkFromTo(Agent,Object1,Object2),
	      near(Agent,Object1),
	      Time).


% [agent,object1,object2,time]
% Happens(WalkFromTo(agent,object1,object2),time) ->
% {location}% 
% HoldsAt(At(agent,location),time) &
% HoldsAt(At(object1,location),time) &
% HoldsAt(At(object2,location),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1140).
exists([Location],  (happens_at(walkFromTo(Agent, Object1, Object2), Time)->holds_at(at_loc(Agent, Location), Time), holds_at(at_loc(Object1, Location), Time), holds_at(at_loc(Object2, Location), Time))).


% [agent,object1,object2,time]
% Initiates(RunFromTo(agent,object1,object2),
%           Near(agent,object2),
%           time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1147).
initiates_at(runFromTo(Agent,Object1,Object2),
	     near(Agent,Object2),
	     Time).


% [agent,object1,object2,time]
% Terminates(RunFromTo(agent,object1,object2),
%            Near(agent,object1),
%            time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1152).
terminates_at(runFromTo(Agent,Object1,Object2),
	      near(Agent,Object1),
	      Time).


% [agent,object1,object2,time]
% Happens(RunFromTo(agent,object1,object2),time) ->
% {location}% 
% HoldsAt(At(agent,location),time) &
% HoldsAt(At(object1,location),time) &
% HoldsAt(At(object2,location),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1157).
exists([Location],  (happens_at(runFromTo(Agent, Object1, Object2), Time)->holds_at(at_loc(Agent, Location), Time), holds_at(at_loc(Object1, Location), Time), holds_at(at_loc(Object2, Location), Time))).


% [agent,object,time]
% Terminates(WalkFrom(agent,object),
%            Near(agent,object),
%            time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1164).
terminates_at(walkFrom(Agent,Object),
	      near(Agent,Object),
	      Time).


% [agent,object,location,door,time]
% HoldsAt(Near(agent,object),time) &
% HoldsAt(At(agent,location),time) &
% HoldsAt(At(object,location),time) &
% Side1(door)=location &
% Happens(WalkThroughDoor12(agent,door),time) ->
% Happens(WalkFrom(agent,object),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1169).
holds_at(near(Agent, Object), Time), holds_at(at_loc(Agent, Location), Time), holds_at(at_loc(Object, Location), Time), side1(Door)=Location, happens_at(walkThroughDoor12(Agent, Door), Time) ->
    happens_at(walkFrom(Agent, Object), Time).


% [agent,object,location,door,time]
% HoldsAt(Near(agent,object),time) &
% HoldsAt(At(agent,location),time) &
% HoldsAt(At(object,location),time) &
% Side2(door)=location &
% Happens(WalkThroughDoor21(agent,door),time) ->
% Happens(WalkFrom(agent,object),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1177).
holds_at(near(Agent, Object), Time), holds_at(at_loc(Agent, Location), Time), holds_at(at_loc(Object, Location), Time), side2(Door)=Location, happens_at(walkThroughDoor21(Agent, Door), Time) ->
    happens_at(walkFrom(Agent, Object), Time).


% [agent,object,room,staircase,time]
% HoldsAt(Near(agent,object),time) &
% HoldsAt(At(agent,room),time) &
% HoldsAt(At(object,room),time) &
% Side1(staircase)=room &
% Happens(WalkUpStaircase(agent,staircase),time) ->
% Happens(WalkFrom(agent,object),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1185).
holds_at(near(Agent, Object), Time), holds_at(at_loc(Agent, Room), Time), holds_at(at_loc(Object, Room), Time), side1(Staircase)=Room, happens_at(walkUpStaircase(Agent, Staircase), Time) ->
    happens_at(walkFrom(Agent, Object), Time).


% [agent,object,room,staircase,time]
% HoldsAt(Near(agent,object),time) &
% HoldsAt(At(agent,room),time) &
% HoldsAt(At(object,room),time) &
% Side2(staircase)=room &
% Happens(WalkDownStaircase(agent,staircase),time) ->
% Happens(WalkFrom(agent,object),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1193).
holds_at(near(Agent, Object), Time), holds_at(at_loc(Agent, Room), Time), holds_at(at_loc(Object, Room), Time), side2(Staircase)=Room, happens_at(walkDownStaircase(Agent, Staircase), Time) ->
    happens_at(walkFrom(Agent, Object), Time).


%; End of file.
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%; FILE: ecnet/OMSpace.e
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;
%; Copyright (c) 2005 IBM Corporation and others.
%; All rights reserved. This program and the accompanying materials
%; are made available under the terms of the Common Public License v1.0
%; which accompanies this distribution, and is available at
%; http://www.eclipse.org/legal/cpl-v10.html
%;
%; Contributors:
%; IBM - Initial implementation
%;
%; OMSpace: object-scale metric space
%;
%; The OMSpace representation deals with metric space at
%; the scale of objects.
%;
%; @article{Morgenstern:2001,
%;   author = "Morgenstern, Leora",
%;   year = "2001",
%;   title = "Mid-sized axiomatizations of commonsense problems: A case study in egg cracking",
%;   journal = "Studia Logica",
%;   volume = "67",
%;   pages = "333--384",
%; }
%;
%; @article{Shanahan:2003,
%;   author = "Shanahan, Murray",
%;   year = "2004",
%;   title = "An attempt to formalise a non-trivial benchmark problem in common sense reasoning",
%;   journal = "Artificial Intelligence",
%;   volume = "153",
%;   pages = "141--165",
%; }
%;

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1242).
% sort height: integer
subsort(height,integer).

% sort distance: integer
subsort(distance,integer).
%; Height
%; The height of object is height.

% fluent Height(object,height)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1247).
fluent(height(object,height)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1250).
%; State constraint represent the fact that each
%; object has a unique height:
% [object,height1,height2,time]
% HoldsAt(Height(object,height1),time) &
% HoldsAt(Height(object,height2),time) ->
% height1=height2.
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1252).
holds_at(height(Object, Height1), Time), holds_at(height(Object, Height2), Time) ->
    Height1=Height2.


% [object,time]
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1258).
% {height}% HoldsAt(Height(object,height),time).
exists([Height],
 holds_at(height(Object,Height),Time)).


%; falling
%; physobj1 is falling from physobj2 to physobj3.

% fluent FallingFromTo(physobj,physobj,physobj)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1263).
fluent(fallingFromTo(physobj,physobj,physobj)).


%; physobj1 starts falling from physobj2 to physobj3.

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1266).
% event StartFallingFromTo(physobj,physobj,physobj)
event(startFallingFromTo(physobj,physobj,physobj)).


%; physobj1 collides with physobj2.

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1268).
% event CollideWith(physobj,physobj)
event(collideWith(physobj,physobj)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1270).
%; An effect axiom states that if a first physical object starts
%; falling from a second physical object to a third physical
%; object, the first physical object will be falling from the
%; second physical object to the third physical object:
% [physobj1,physobj2,physobj3,time]
% Initiates(StartFallingFromTo(physobj1,physobj2,physobj3),
%           FallingFromTo(physobj1,physobj2,physobj3),
%           time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1274).
initiates_at(startFallingFromTo(Physobj1,
				Physobj2,
				Physobj3),
	     fallingFromTo(Physobj1,
			   Physobj2,
			   Physobj3),
	     Time).


%; A precondition axiom states that for
%; a first physical object to start
%; falling from a second physical object to a third physical
%; object,
%; the height of the first physical object and the
%; second physical object must be the same.
% [physobj1,physobj2,physobj3,height1,height2,time]
% Happens(StartFallingFromTo(physobj1,physobj2,physobj3),time) &
% HoldsAt(Height(physobj1,height1),time) &
% HoldsAt(Height(physobj2,height2),time) ->
% height1=height2.
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1285).
happens_at(startFallingFromTo(Physobj1, Physobj2, Physobj3), Time), holds_at(height(Physobj1, Height1), Time), holds_at(height(Physobj2, Height2), Time) ->
    Height1=Height2.


%; A state constraint says that a physical object
%; cannot fall from itself, cannot fall to itself,
%; and cannot fall from and to the same physical object:
% [physobj1,physobj2,physobj3,time]
% HoldsAt(FallingFromTo(physobj1,physobj2,physobj3),time) ->
% physobj1!=physobj2 &
% physobj1!=physobj3 &
% physobj2!=physobj3.
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1294).
holds_at(fallingFromTo(Physobj1, Physobj2, Physobj3), Time) ->
    Physobj1\=Physobj2,
    Physobj1\=Physobj3,
    Physobj2\=Physobj3.


%; A state constraint says that the sky cannot fall:
% [sky,physobj1,physobj2,time]
% !HoldsAt(FallingFromTo(sky,physobj1,physobj2),time).
holds_at(not(fallingFromTo(Sky,Physobj1,Physobj2)),
	 Time).


%; A releases axiom states that if
%; if a first physical object starts
%; falling from a second physical object to a third physical
%; object, the height of the first physical object
%; will be released from inertia:
% [physobj1,physobj2,physobj3,height,time]
% Releases(StartFallingFromTo(physobj1,physobj2,physobj3),
%          Height(physobj1,height),
%          time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1309).
releases_at(startFallingFromTo(Physobj1,
			       Physobj2,
			       Physobj3),
	    height(Physobj1,Height),
	    Time).


%; A trajectory axiom states that
%; if a first physical object starts falling
%; from a second physical object
%; to a third physical object
%; at a time and
%; the first physical object has a height at the time,
%; then the first physical object will have a height
%; equal to the height minus an offset
%; at a time equal to the time plus the offset:
% [physobj1,physobj2,physobj3,height1,height2,offset,time]
% HoldsAt(Height(physobj1,height1),time) &
% height2=height1-offset ->
% Trajectory(FallingFromTo(physobj1,physobj2,physobj3),time,
%            Height(physobj1,height2),offset).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1323).
holds_at(height(Physobj1, Height1), Time), Height2=Height1-Offset ->
    trajectory(fallingFromTo(Physobj1, Physobj2, Physobj3),
               Time,
               height(Physobj1, Height2),
               Offset).


%; A trigger axiom states that
%; if a first physical object is falling
%; from a second physical object
%; to a third physical object and
%; the height of the first physical object
%; is the same as the height of the third physical object,
%; the first physical object collides with the
%; third physical object:
% [physobj1,physobj2,physobj3,height,time]
% HoldsAt(FallingFromTo(physobj1,physobj2,physobj3),time) &
% HoldsAt(Height(physobj1,height),time) &
% HoldsAt(Height(physobj3,height),time) ->
% Happens(CollideWith(physobj1,physobj3),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1337).
holds_at(fallingFromTo(Physobj1, Physobj2, Physobj3), Time), holds_at(height(Physobj1, Height), Time), holds_at(height(Physobj3, Height), Time) ->
    happens_at(collideWith(Physobj1, Physobj3), Time).


%; An effect axiom states that
%; if a first physical object is falling
%; from a second physical object
%; to a third physical object and
%; the first physical object collides with
%; the third physical object,
%; the first physical object will be on the third physical object:
% [physobj1,physobj2,physobj3,time]
% HoldsAt(FallingFromTo(physobj1,physobj2,physobj3),time) ->
% Initiates(CollideWith(physobj1,physobj3),
%           On(physobj1,physobj3),
%           time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1350).
holds_at(fallingFromTo(Physobj1, Physobj2, Physobj3), Time) ->
    initiates_at(collideWith(Physobj1, Physobj3),
                 on(Physobj1, Physobj3),
                 Time).


%; An effect axiom states that
%; if a physical object collides with another
%; physical object,
%; the height of the first physical object will
%; be the height of the second physical object:
% [physobj1,physobj2,height,time]
% HoldsAt(Height(physobj2,height),time) ->
% Initiates(CollideWith(physobj1,physobj2),
%           Height(physobj1,height),
%           time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1361).
holds_at(height(Physobj2, Height), Time) ->
    initiates_at(collideWith(Physobj1, Physobj2),
                 height(Physobj1, Height),
                 Time).


%;[physobj1,physobj2,height1,height2,time]
%;HoldsAt(Height(physobj2,height1),time) &
%;height1 != height2 ->
%;Terminates(CollideWith(physobj1,physobj2),
%;           Height(physobj1,height2),
%;           time).
%; An effect axiom states that
%; if a first physical object is falling
%; from a second physical object
%; to a third physical object and
%; the first physical object collides with
%; the third physical object,
%; the first physical object will no longer be
%; falling from the second physical object to the
%; third physical object:
% [physobj1,physobj2,physobj3,time]
% HoldsAt(FallingFromTo(physobj1,physobj2,physobj3),time) ->
% Terminates(CollideWith(physobj1,physobj3),
%            FallingFromTo(physobj1,physobj2,physobj3),
%            time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1383).
holds_at(fallingFromTo(Physobj1, Physobj2, Physobj3), Time) ->
    terminates_at(collideWith(Physobj1, Physobj3),
                  fallingFromTo(Physobj1, Physobj2, Physobj3),
                  Time).


%; flying
%; agent is flying from physobj1 to physobj2.

% fluent FlyingFromTo(agent,physobj,physobj)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1391).
fluent(flyingFromTo(agent,physobj,physobj)).


%; agent starts flying from physobj1 to physobj2.

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1394).
% event StartFlyingFromTo(agent,physobj,physobj)
event(startFlyingFromTo(agent,physobj,physobj)).


%; agent reaches physobj.

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1396).
% event Reach(agent,physobj)
event(reach(agent,physobj)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1398).
%; An effect axiom states that if an agent starts
%; flying from a physical object to another physical object,
%; the agent will be flying from the first physical object
%; to the second physical object:
% [agent,physobj1,physobj2,time]
% Initiates(StartFlyingFromTo(agent,physobj1,physobj2),
%           FlyingFromTo(agent,physobj1,physobj2),
%           time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1402).
initiates_at(startFlyingFromTo(Agent,
			       Physobj1,
			       Physobj2),
	     flyingFromTo(Agent,Physobj1,Physobj2),
	     Time).


%; A precondition axiom states that for
%; an agent to start flying from a physical object to
%; another physical object,
%; the height of the agent and
%; the first physical object must be the same:
% [agent,physobj1,physobj2,height1,height2,time]
% Happens(StartFlyingFromTo(agent,physobj1,physobj2),time) &
% HoldsAt(Height(agent,height1),time) &
% HoldsAt(Height(physobj1,height2),time) ->
% height1=height2.
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1412).
happens_at(startFlyingFromTo(Agent, Physobj1, Physobj2), Time), holds_at(height(Agent, Height1), Time), holds_at(height(Physobj1, Height2), Time) ->
    Height1=Height2.


%; A state constraint says that an agent
%; cannot fly from and to the same physical object:
% [agent,physobj1,physobj2,time]
% HoldsAt(FlyingFromTo(agent,physobj1,physobj2),time) ->
% physobj1!=physobj2.
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1420).
holds_at(flyingFromTo(Agent, Physobj1, Physobj2), Time) ->
    Physobj1\=Physobj2.


%; A releases axiom states that if an agent
%; starts flying from a physical object to another
%; physical object, the height of the agent will
%; be released from inertia:
% [agent,physobj1,physobj2,height,time]
% Releases(StartFlyingFromTo(agent,physobj1,physobj2),
%          Height(agent,height),
%          time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1428).
releases_at(startFlyingFromTo(Agent,
			      Physobj1,
			      Physobj2),
	    height(Agent,Height),
	    Time).


%; A trajectory axiom states that
%; if an agent starts flying from
%; from a physical object
%; to another physical object
%; at a time and
%; the agent has a height at the time,
%; then the agent will have a height
%; equal to the height plus an offset
%; at a time equal to the time plus the offset:
% [agent,physobj1,physobj2,height1,height2,offset,time]
% HoldsAt(Height(agent,height1),time) &
% height2=height1+offset ->
% Trajectory(FlyingFromTo(agent,physobj1,physobj2),time,
%            Height(agent,height2),offset).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1442).
holds_at(height(Agent, Height1), Time), Height2=Height1+Offset ->
    trajectory(flyingFromTo(Agent, Physobj1, Physobj2),
               Time,
               height(Agent, Height2),
               Offset).


%; A trigger axiom states that
%; if an agent is flying
%; from a physical object
%; to another physical object and
%; the height of the agent
%; is the same as the height of the second physical object,
%; the agent reaches the second physical object:
% [agent,physobj1,physobj2,height,time]
% HoldsAt(FlyingFromTo(agent,physobj1,physobj2),time) &
% HoldsAt(Height(agent,height),time) &
% HoldsAt(Height(physobj2,height),time) ->
% Happens(Reach(agent,physobj2),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1455).
holds_at(flyingFromTo(Agent, Physobj1, Physobj2), Time), holds_at(height(Agent, Height), Time), holds_at(height(Physobj2, Height), Time) ->
    happens_at(reach(Agent, Physobj2), Time).


%; An effect axiom states that
%; if an agent reaches a physical object,
%; the height of the agent will be the
%; height of the physical object:
% [agent,physobj,height,time]
% HoldsAt(Height(physobj,height),time) ->
% Initiates(Reach(agent,physobj),Height(agent,height),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1465).
holds_at(height(Physobj, Height), Time) ->
    initiates_at(reach(Agent, Physobj),
                 height(Agent, Height),
                 Time).


%;[agent,physobj,height1,height2,time]
%;HoldsAt(Height(physobj,height1),time) &
%;height1!=height2 ->
%;Terminates(Reach(agent,physobj),Height(agent,height2),time).
%; An effect axiom states that
%; if an agent is flying
%; from a physical object
%; to another physical object and
%; the agent reaches the second physical object,
%; the agent will no longer be
%; flying from the first physical object
%; to the second physical object:
% [agent,physobj1,physobj2,time]
% HoldsAt(FlyingFromTo(agent,physobj1,physobj2),time) ->
% Terminates(Reach(agent,physobj2),
%            FlyingFromTo(agent,physobj1,physobj2),
%            time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1482).
holds_at(flyingFromTo(Agent, Physobj1, Physobj2), Time) ->
    terminates_at(reach(Agent, Physobj2),
                  flyingFromTo(Agent, Physobj1, Physobj2),
                  Time).


%; A releases axiom states that
%; if an agent holds a physical object,
%; the height of the physical object is released from inertia:
% [agent,physobj,height,time]
% Releases(Hold(agent,physobj),Height(physobj,height),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1491).
releases_at(hold(Agent,Physobj),
	    height(Physobj,Height),
	    Time).


%;[agent,physobj,height1,height2,time]
%;(!{object} PartOf(physobj,object)) &
%;HoldsAt(Height(physobj,height1),time) &
%;height1 != height2 ->
%;Terminates(LetGoOf(agent,physobj),Height(physobj,height2),time).
% [agent,physobj,height,time]
% (!{object} PartOf(physobj,object)) &
% HoldsAt(Height(physobj,height),time) ->
% Initiates(LetGoOf(agent,physobj),Height(physobj,height),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1500).
not(exists([Object], partOf(Physobj, Object))), holds_at(height(Physobj, Height), Time) ->
    initiates_at(letGoOf(Agent, Physobj),
                 height(Physobj, Height),
                 Time).


%; A state constraint says that
%; if an agent is holding a physical object and
%; the height of the agent is height,
%; the height of the physical object is height:
% [agent,physobj,height,time]
% HoldsAt(Holding(agent,physobj),time) &
% HoldsAt(Height(agent,height),time) ->
% HoldsAt(Height(physobj,height),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1509).
holds_at(holding(Agent, Physobj), Time), holds_at(height(Agent, Height), Time) ->
    holds_at(height(Physobj, Height), Time).


%; A state constraint says that if a physical object
%; is part of an object,
%; the height of the physical object
%; is the same as the height of the object:
% [physobj,object,height,time]
% PartOf(physobj,object) &
% HoldsAt(Height(object,height),time) ->
% HoldsAt(Height(physobj,height),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1518).
partOf(Physobj, Object), holds_at(height(Object, Height), Time) ->
    holds_at(height(Physobj, Height), Time).


%;event Catch(agent,physobj)
%;event HitFromTo(agent,physobj,object,object)
%;fluent Distance(physobj,physobj,distance)
%;fluent FlyingAcrossFromTo(physobj,object,object)
%;[agent,physobj1,physobj2,physobj3,time]
%;Initiates(HitFromTo(agent,physobj1,physobj2,physobj3),
%;          FlyingAcrossFromTo(physobj1,physobj2,physobj3),
%;          time).
%;[agent,physobj1,physobj2,physobj3,distance,time]
%;Releases(HitFromTo(agent,physobj1,physobj2,physobj3),
%;         Distance(physobj1,physobj2,distance),
%;         time).
%;[agent,physobj1,physobj2,physobj3,distance,time]
%;Releases(HitFromTo(agent,physobj1,physobj2,physobj3),
%;         Distance(physobj1,physobj3,distance),
%;         time).
%;[physobj1,physobj2,physobj3,offset,time]
%;Trajectory(FlyingAcrossFromTo(physobj1,physobj2,physobj3),time,
%;           Distance(physobj1,physobj2,offset),offset).
%;[physobj1,physobj2,physobj3,distance1,distance2,offset,time]
%;HoldsAt(Distance(physobj2,physobj3,distance1),time) &
%;distance2 = distance1 - time ->
%;Trajectory(FlyingAcrossFromTo(physobj1,physobj2,physobj3),time,
%;           Distance(physobj1,physobj3,distance2),offset).
%;[agent,physobj1,physobj2,physobj3,time]
%;HoldsAt(FlyingAcrossFromTo(physobj1,physobj2,physobj3),time) ->
%;Initiates(Catch(agent,physobj1),
%;          Holding(agent,physobj1),
%;          time).
%;[agent,physobj1,physobj2,physobj3,time]
%;HoldsAt(FlyingAcrossFromTo(physobj1,physobj2,physobj3),time) ->
%;Terminates(Catch(agent,physobj1),
%;           FlyingAcrossFromTo(physobj1,physobj2,physobj3),
%;           time).
%; End of file.
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%; FILE: ecnet/GSpace.e
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;
%; Copyright (c) 2005 IBM Corporation and others.
%; All rights reserved. This program and the accompanying materials
%; are made available under the terms of the Common Public License v1.0
%; which accompanies this distribution, and is available at
%; http://www.eclipse.org/legal/cpl-v10.html
%;
%; Contributors:
%; IBM - Initial implementation
%;
%; GSpace: grid space
%;
%; @book{Mueller:1998,
%;   author = "Erik T. Mueller",
%;   year = "1998",
%;   title = "Natural Language Processing with \uppercase{T}hought\uppercase{T}reasure",
%;   address = "New York",
%;   publisher = "Signiform",
%; }
%;

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1594).
% sort coord: integer
subsort(coord,integer).

% sort grid
sort(grid).
%; object is at (coord1, coord2) in grid.

% fluent GridAt(grid,object,coord,coord)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1597).
fluent(gridAt(grid,object,coord,coord)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1600).
%; agent walks from (coord1, coord2)
%; to (coord3, coord4) in grid.

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1602).
% event GridWalk(grid,agent,coord,coord,coord,coord)
event(gridWalk(grid,agent,coord,coord,coord,coord)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1604).
%; A state constraint says that for a given grid an
%; object is at one cell in that grid at a time:
% [grid,object,coord1,coord2,coord3,coord4,time]
% HoldsAt(GridAt(grid,object,coord1,coord2),time) &
% HoldsAt(GridAt(grid,object,coord3,coord4),time) ->
% coord1=coord3 & coord2=coord4.
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1606).
holds_at(gridAt(Grid, Object, Coord1, Coord2), Time), holds_at(gridAt(Grid, Object, Coord3, Coord4), Time) ->
    Coord1=Coord3,
    Coord2=Coord4.


%; An effect axiom states that
%; if an agent walks from one cell in a grid to another cell,
%; the agent will be at second cell:
% [grid,agent,coord1,coord2,coord3,coord4,time]
% Initiates(GridWalk(grid,agent,coord1,coord2,coord3,coord4),
%           GridAt(grid,agent,coord3,coord4),
%           time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1614).
initiates_at(gridWalk(Grid,
		      Agent,
		      Coord1,
		      Coord2,
		      Coord3,
		      Coord4),
	     gridAt(Grid,Agent,Coord3,Coord4),
	     Time).


%; An effect axiom states that
%; if an agent walks from one cell in a grid to another cell,
%; the agent will no longer be at the first cell:
% [grid,agent,coord1,coord2,coord3,coord4,time]
% Terminates(GridWalk(grid,agent,coord1,coord2,coord3,coord4),
%            GridAt(grid,agent,coord1,coord2),
%            time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1622).
terminates_at(gridWalk(Grid,
		       Agent,
		       Coord1,
		       Coord2,
		       Coord3,
		       Coord4),
	      gridAt(Grid,Agent,Coord1,Coord2),
	      Time).


%; A precondition axiom states that for an agent to walk
%; from one cell in a grid to another cell, the agent
%; must be at the first cell, the second cell must not
%; be occupied, and the first cell must be adjacent to
%; the second cell:
% [grid,agent,coord1,coord2,coord3,coord4,time]
% Happens(GridWalk(grid,agent,coord1,coord2,coord3,coord4),time) ->
% HoldsAt(GridAt(grid,agent,coord1,coord2),time) &
% (!{object} HoldsAt(GridAt(grid,object,coord3,coord4),time)) &
% (coord1=coord3 |
%  coord1=coord3+1 |
%  coord1=coord3-1) &
% (coord2=coord4 |
%  coord2=coord4+1 |
%  coord2=coord4-1).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1632).
happens_at(gridWalk(Grid, Agent, Coord1, Coord2, Coord3, Coord4), Time) ->
    holds_at(gridAt(Grid, Agent, Coord1, Coord2),
             Time),
    not(exists([Object],
               holds_at(gridAt(Grid,
                               Object,
                               Coord3,
                               Coord4),
                        Time))),
    (   Coord1=Coord3
    ;   Coord1=Coord3+1
    ;   Coord1=Coord3-1
    ),
    (   Coord2=Coord4
    ;   Coord2=Coord4+1
    ;   Coord2=Coord4-1
    ).


%; End of file.
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%; FILE: ecnet/PolySpace.e
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;
%; Copyright (c) 2005 IBM Corporation and others.
%; All rights reserved. This program and the accompanying materials
%; are made available under the terms of the Common Public License v1.0
%; which accompanies this distribution, and is available at
%; http://www.eclipse.org/legal/cpl-v10.html
%;
%; Contributors:
%; IBM - Initial implementation
%;
%; @phdthesis{Cassimatis:2002,
%;   author = "Nicholas L. Cassimatis",
%;   year = "2002",
%;   title = "Polyscheme: A Cognitive Architecture for Integrating Multiple Representation and Inference Schemes",
%;   address = "Cambridge, MA",
%;   school = "Program in Media Arts and Sciences, School of Architecture and Planning, Massachusetts Institute of Technology",
%; }
%;
%; sorts

% sort object
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1670).
sort(object).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1672).
% sort xcoord: integer
subsort(xcoord,integer).

% sort ycoord: integer
subsort(ycoord,integer).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1674).
% sort grid
sort(grid).

% sort shape
sort(shape).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1676).
% sort color
sort(color).
%; constants

% shape Round,Square
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1678).
t(shape,round).
t(shape,square).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1680).
% color Red,Green
t(color,red).
t(color,green).
%; predicates, fluents, and events

% predicate Equal(object,object)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1682).
predicate(equal(object,object)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1684).
% predicate Shape(object,shape)
predicate(shape(object,shape)).

% predicate Color(object,color)
predicate(color(object,color)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1686).
% fluent Location(grid,object,xcoord,ycoord)
fluent(location(grid,object,xcoord,ycoord)).

% event Move(grid,object,xcoord,ycoord,xcoord,ycoord)
event(move(grid,object,xcoord,ycoord,xcoord,ycoord)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1689).
%; axioms
% [object1,object2]
 % Equal(object1,object2) -> Equal(object2,object1).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1691).
equal(Object1, Object2) ->
    equal(Object2, Object1).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1693).
%; objects have unique shape
% [object,shape1,shape2]
% Shape(object,shape1) & Shape(object,shape2) ->
% shape1=shape2.
shape(Object, Shape1), shape(Object, Shape2) ->
    Shape1=Shape2.


%; objects have unique color
% [object,color1,color2]
% Color(object,color1) & Color(object,color2) ->
% color1=color2.
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1699).
color(Object, Color1), color(Object, Color2) ->
    Color1=Color2.


%; if objects are the same, they have the same shape
% [object1,object2]
% Equal(object1,object2) ->
% ({shape} Shape(object1,shape) & Shape(object2,shape)).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1704).
equal(Object1, Object2) ->
    exists([Shape],
            (shape(Object1, Shape), shape(Object2, Shape))).


%; if objects are the same, they have the same color
% [object1,object2]
% Equal(object1,object2) ->
% ({color} Color(object1,color) & Color(object2,color)).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1709).
equal(Object1, Object2) ->
    exists([Color],
            (color(Object1, Color), color(Object2, Color))).


%; if objects are the same, they have the same location
% [grid,object1,object2,xcoord1,ycoord1,xcoord2,ycoord2,time]
% Equal(object1,object2) ->
% (HoldsAt(Location(grid,object1,xcoord1,ycoord1),time) &
%  HoldsAt(Location(grid,object2,xcoord2,ycoord2),time) ->
%  xcoord1=xcoord2 & ycoord1=ycoord2).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1714).
equal(Object1, Object2) ->
    ( holds_at(location(Grid, Object1, Xcoord1, Ycoord1), Time), holds_at(location(Grid, Object2, Xcoord2, Ycoord2), Time)->Xcoord1=Xcoord2, Ycoord1=Ycoord2
    ).


%; object in one location at a time
% [grid,object,xcoord1,ycoord1,xcoord2,ycoord2,time]
% HoldsAt(Location(grid,object,xcoord1,ycoord1),time) &
% HoldsAt(Location(grid,object,xcoord2,ycoord2),time) ->
% xcoord1=xcoord2 & ycoord1=ycoord2.
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1721).
holds_at(location(Grid, Object, Xcoord1, Ycoord1), Time), holds_at(location(Grid, Object, Xcoord2, Ycoord2), Time) ->
    Xcoord1=Xcoord2,
    Ycoord1=Ycoord2.


%; objects have locations
% [grid,object,time]
% (% {xcoord,ycoord} HoldsAt(Location(grid,object,xcoord,ycoord),time)).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1727).
exists([Xcoord,Ycoord],
 holds_at(location(Grid,Object,Xcoord,Ycoord),
	 Time)).


%; different objects are not at same location
% [grid,object1,object2,xcoord1,ycoord1,time]
% HoldsAt(Location(grid,object1,xcoord1,ycoord1),time) &
% HoldsAt(Location(grid,object2,xcoord1,ycoord1),time) ->
% Equal(object1,object2).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1731).
holds_at(location(Grid, Object1, Xcoord1, Ycoord1), Time), holds_at(location(Grid, Object2, Xcoord1, Ycoord1), Time) ->
    equal(Object1, Object2).


%; moving to a location causes an object to be at that location
% [grid,object,xcoord1,ycoord1,xcoord2,ycoord2,time]
% Initiates(Move(grid,object,xcoord1,ycoord1,xcoord2,ycoord2),
%           Location(grid,object,xcoord2,ycoord2),
%           time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1737).
initiates_at(move(Grid,
		  Object,
		  Xcoord1,
		  Ycoord1,
		  Xcoord2,
		  Ycoord2),
	     location(Grid,
		      Object,
		      Xcoord2,
		      Ycoord2),
	     Time).


%; moving to a location causes the object no longer to be at its previous
%; location
% [grid,object,xcoord1,ycoord1,xcoord2,ycoord2,time]
% Terminates(Move(grid,object,xcoord1,ycoord1,xcoord2,ycoord2),
%            Location(grid,object,xcoord1,ycoord1),
%            time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1744).
terminates_at(move(Grid,
		   Object,
		   Xcoord1,
		   Ycoord1,
		   Xcoord2,
		   Ycoord2),
	      location(Grid,
		       Object,
		       Xcoord1,
		       Ycoord1),
	      Time).


%;; allow diagonal movements
%;[grid,object,xcoord1,ycoord1,xcoord2,ycoord2,time]
%;Happens(Move(grid,object,xcoord1,ycoord1,xcoord2,ycoord2),time) ->
%;HoldsAt(Location(grid,object,xcoord1,ycoord1),time) &
%;(xcoord1=xcoord2 |
%; xcoord1=xcoord2+1 |
%; xcoord1=xcoord2-1) &
%;(ycoord1=ycoord2 |
%; ycoord1=ycoord2+1 |
%; ycoord1=ycoord2-1).
%; only allow right angle movements
% [grid,object,xcoord1,ycoord1,xcoord2,ycoord2,time]
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1762).
% Happens(Move(grid,object,xcoord1,ycoord1,xcoord2,ycoord2),time) ->
% HoldsAt(Location(grid,object,xcoord1,ycoord1),time) &
% ((xcoord1=xcoord2 & (ycoord1=ycoord2+1 | ycoord1=ycoord2-1)) |
%  (ycoord1=ycoord2 & (xcoord1=xcoord2+1 | xcoord1=xcoord2-1))).
happens_at(move(Grid, Object, Xcoord1, Ycoord1, Xcoord2, Ycoord2), Time) ->
    holds_at(location(Grid, Object, Xcoord1, Ycoord1),
             Time),
    (   Xcoord1=Xcoord2,
        (   Ycoord1=Ycoord2+1
        ;   Ycoord1=Ycoord2-1
        )
    ;   Ycoord1=Ycoord2,
        (   Xcoord1=Xcoord2+1
        ;   Xcoord1=Xcoord2-1
        )
    ).


%; End of file.
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%; FILE: ecnet/HandTo.e
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;
%; Copyright (c) 2005 IBM Corporation and others.
%; All rights reserved. This program and the accompanying materials
%; are made available under the terms of the Common Public License v1.0
%; which accompanies this distribution, and is available at
%; http://www.eclipse.org/legal/cpl-v10.html
%;
%; Contributors:
%; IBM - Initial implementation
%;

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1786).
% event HandTo(agent,agent,physobj)
event(handTo(agent,agent,physobj)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1788).
% [agent1,agent2,physobj,time]
% Initiates(HandTo(agent1,agent2,physobj),
%           Holding(agent2,physobj),
%           time).
initiates_at(handTo(Agent1,Agent2,Physobj),
	     holding(Agent2,Physobj),
	     Time).


% [agent1,agent2,physobj,time]
% Terminates(HandTo(agent1,agent2,physobj),
%            Holding(agent1,physobj),
%            time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1794).
terminates_at(handTo(Agent1,Agent2,Physobj),
	      holding(Agent1,Physobj),
	      Time).


% [agent1,agent2,physobj,time]
% Happens(HandTo(agent1,agent2,physobj),time) ->
% HoldsAt(Holding(agent1,physobj),time).
happens_at(handTo(Agent1, Agent2, Physobj), Time) ->
    holds_at(holding(Agent1, Physobj), Time).

% event ShakeHands(agent,agent)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1801).
event(shakeHands(agent,agent)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1804).
% event WriteOn(agent,paper,pen)
event(writeOn(agent,paper,pen)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1808).
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%; FILE: ecnet/Container.e
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;
%; Copyright (c) 2005 IBM Corporation and others.
%; All rights reserved. This program and the accompanying materials
%; are made available under the terms of the Common Public License v1.0
%; which accompanies this distribution, and is available at
%; http://www.eclipse.org/legal/cpl-v10.html
%;
%; Contributors:
%; IBM - Initial implementation
%;
%;
%; Container: container
%;
%; linkage to OTSpace(M):
% [agent,container1,container2,time]
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1828).
% Happens(TakeOutOf(agent,container1,container2),time) ->
% HoldsAt(ContainerIsOpen(container2),time).
happens_at(takeOutOf(Agent, Container1, Container2), Time) ->
    holds_at(containerIsOpen(Container2), Time).


% [agent,container1,container2,time]
% Happens(PutInside(agent,container1,container2),time) ->
% HoldsAt(ContainerIsOpen(container2),time).
happens_at(putInside(Agent, Container1, Container2), Time) ->
    holds_at(containerIsOpen(Container2), Time).


%; agent opens container.

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1836).
% event ContainerOpen(agent,container)
event(containerOpen(agent,container)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1838).
%; agent closes container.

% event ContainerClose(agent,container)
event(containerClose(agent,container)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1841).
%; container is open.

% fluent ContainerIsOpen(container)
fluent(containerIsOpen(container)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1844).
% fluent ContainerClosed(container)
fluent(containerClosed(container)).

% noninertial ContainerClosed
:- call_pel_directive(noninertial(containerClosed)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1847).
% [container,time]
% HoldsAt(ContainerClosed(container),time) <->
% !HoldsAt(ContainerIsOpen(container),time).
holds_at(containerClosed(Container), Time) <->
    holds_at(not(containerIsOpen(Container)), Time).


%; A precondition axiom states that
%; for an agent to open a container,
%; the agent must be awake,
%; the container must not already be open, and
%; the agent must be holding the container.
% [agent,container,time]
% Happens(ContainerOpen(agent,container),time) ->
% HoldsAt(Awake(agent),time) &
% !HoldsAt(ContainerIsOpen(container),time) &
% HoldsAt(Holding(agent,container),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1856).
happens_at(containerOpen(Agent, Container), Time) ->
    holds_at(awake(Agent), Time),
    holds_at(not(containerIsOpen(Container)), Time),
    holds_at(holding(Agent, Container), Time).


%; An effect axiom states that
%; if an agent opens a container,
%; the container will be open:
% [agent,container,time]
% Initiates(ContainerOpen(agent,container),ContainerIsOpen(container),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1865).
initiates_at(containerOpen(Agent,Container),
	     containerIsOpen(Container),
	     Time).


%; A precondition axiom states that
%; for an agent to close a container,
%; the agent must be awake,
%; the container must be open, and
%; the agent must be holding the container.
% [agent,container,time]
% Happens(ContainerClose(agent,container),time) ->
% HoldsAt(Awake(agent),time) &
% HoldsAt(ContainerIsOpen(container),time) &
% HoldsAt(Holding(agent,container),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1873).
happens_at(containerClose(Agent, Container), Time) ->
    holds_at(awake(Agent), Time),
    holds_at(containerIsOpen(Container), Time),
    holds_at(holding(Agent, Container), Time).


%; An effect axiom states that
%; if an agent closes a container,
%; the container will no longer be open:
% [agent,container,time]
% Terminates(ContainerClose(agent,container),ContainerIsOpen(container),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1882).
terminates_at(containerClose(Agent,Container),
	      containerIsOpen(Container),
	      Time).


%; End of file.
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%; FILE: ecnet/SpeechAct.e
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;
%; Copyright (c) 2005 IBM Corporation and others.
%; All rights reserved. This program and the accompanying materials
%; are made available under the terms of the Common Public License v1.0
%; which accompanies this distribution, and is available at
%; http://www.eclipse.org/legal/cpl-v10.html
%;
%; Contributors:
%; IBM - Initial implementation
%;
%; The SpeechAct representation deals with a few speech acts
%; \fullcite{Searle:1969}.
%;
%; @book{Searle:1969,
%;   author = "John R. Searle",
%;   year = "1969",
%;   title = "Speech Acts: An Essay in the Philosophy of Language",
%;   address = "Cambridge",
%;   publisher = "Cambridge University Press",
%; }
%;
%; We handle
%; the illocutionary acts of
%; inviting someone into one's house (a form of request) and
%; greeting someone,
%; and the expressive speech act of crying for joy.
%;
%; inviting in
%; agent1 invites agent2 into room.

% event InviteIn(agent,agent,room)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1923).
event(inviteIn(agent,agent,room)).


%; agent1 is invited into room by agent2.

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1926).
% fluent InvitedIn(agent,room,agent)
fluent(invitedIn(agent,room,agent)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1928).
%; A precondition axiom states that for
%; an agent to invite another agent into a room,
%; the first agent must be in the room and
%; there must be an outside area such that
%; the second agent is at the outside area and
%; the outside area is adjacent to the room:
% [agent1,agent2,room,time]
% Happens(InviteIn(agent1,agent2,room),time) ->
% HoldsAt(At(agent1,room),time) &
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1934).
% {outside}% 
% HoldsAt(At(agent2,outside),time) &
% Adjacent(room,outside).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1937).
exists([Outside],  (happens_at(inviteIn(Agent1, Agent2, Room), Time)->holds_at(at_loc(Agent1, Room), Time), holds_at(at_loc(Agent2, Outside), Time), adjacent(Room, Outside))).


%; An effect axiom states that if
%; an agent invites another agent into a room,
%; the second agent will be invited into the room by the first agent:
% [agent1,agent2,room,time]
% Initiates(InviteIn(agent1,agent2,room),
%           InvitedIn(agent2,room,agent1),
%           time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1944).
initiates_at(inviteIn(Agent1,Agent2,Room),
	     invitedIn(Agent2,Room,Agent1),
	     Time).


%; agent intends to walk into room.

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1950).
% event IntendToWalkIn(agent,room)
event(intendToWalkIn(agent,room)).


%; agent has the intention to walk into room.

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1952).
% fluent IntentionToWalkIn(agent,room)
fluent(intentionToWalkIn(agent,room)).


%; agent acts on the intention to walk into room.

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1954).
% fluent ActOnIntentionToWalkIn(agent,room)
fluent(actOnIntentionToWalkIn(agent,room)).

% noninertial ActOnIntentionToWalkIn
:- call_pel_directive(noninertial(actOnIntentionToWalkIn)).
%; A trigger axiom states that
%; if an agent is invited into a room by another agent,
%; the first agent likes the second agent, and
%; the first agent does not already have the intention to
%; walk into the room,
%; the first agent intends to walk into the room:
% [agent1,agent2,room,time]
% HoldsAt(InvitedIn(agent1,room,agent2),time) &
% HoldsAt(Like(agent1,agent2),time) &
% !HoldsAt(IntentionToWalkIn(agent1,room),time) ->
% Happens(IntendToWalkIn(agent1,room),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1963).
holds_at(invitedIn(Agent1, Room, Agent2), Time), holds_at(like(Agent1, Agent2), Time), holds_at(not(intentionToWalkIn(Agent1, Room)), Time) ->
    happens_at(intendToWalkIn(Agent1, Room), Time).


%; An effect axiom states that
%; if an agent intends to walk into a room,
%; the agent will have the intention to walk into the room:
% [agent,room,time]
% Initiates(IntendToWalkIn(agent,room),
%           IntentionToWalkIn(agent,room),
%           time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1972).
initiates_at(intendToWalkIn(Agent,Room),
	     intentionToWalkIn(Agent,Room),
	     Time).


%; Two trigger axioms state that
%; if an agent has the intention to walk into a room,
%; the agent acts on the intention to walk into the room,
%; the agent is at a location,
%; side one (two) of a door is the room,
%; side two (one) of the door is the location,
%; agent will walk through side two (one) of the door:
% [agent,room,location,door,time]
% HoldsAt(IntentionToWalkIn(agent,room),time) &
% HoldsAt(ActOnIntentionToWalkIn(agent,room),time) &
% HoldsAt(At(agent,location),time) &
% Side1(door)=room &
% Side2(door)=location ->
% Happens(WalkThroughDoor21(agent,door),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1984).
holds_at(intentionToWalkIn(Agent, Room), Time), holds_at(actOnIntentionToWalkIn(Agent, Room), Time), holds_at(at_loc(Agent, Location), Time), side1(Door)=Room, side2(Door)=Location ->
    happens_at(walkThroughDoor21(Agent, Door), Time).


% [agent,room,location,door,time]
% HoldsAt(IntentionToWalkIn(agent,room),time) &
% HoldsAt(ActOnIntentionToWalkIn(agent,room),time) &
% HoldsAt(At(agent,location),time) &
% Side2(door)=room &
% Side1(door)=location ->
% Happens(WalkThroughDoor12(agent,door),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',1993).
holds_at(intentionToWalkIn(Agent, Room), Time), holds_at(actOnIntentionToWalkIn(Agent, Room), Time), holds_at(at_loc(Agent, Location), Time), side2(Door)=Room, side1(Door)=Location ->
    happens_at(walkThroughDoor12(Agent, Door), Time).


%; Two effect axioms state that
%; if side one (two) of a door is a room and
%; an agent walks through side two (one) of the door,
%; the agent will no longer have the intention to
%; walk into the room:
% [agent,room,door,time]
% Side1(door)=room ->
% Terminates(WalkThroughDoor21(agent,door),
%            IntentionToWalkIn(agent,room),
%            time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2005).
side1(Door)=Room ->
    terminates_at(walkThroughDoor21(Agent, Door),
                  intentionToWalkIn(Agent, Room),
                  Time).


% [agent,room,door,time]
% Side2(door)=room ->
% Terminates(WalkThroughDoor12(agent,door),
%            IntentionToWalkIn(agent,room),
%            time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2012).
side2(Door)=Room ->
    terminates_at(walkThroughDoor12(Agent, Door),
                  intentionToWalkIn(Agent, Room),
                  Time).


%; agent greets object.

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2018).
% event Greet(agent,object)
event(greet(agent,object)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2020).
% event SayPleasedToMeet(agent,agent)
event(sayPleasedToMeet(agent,agent)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2022).
%; agent says goodbye to object.

% event SayGoodbye(agent,object)
event(sayGoodbye(agent,object)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2025).
% event TalkAbout(agent,content)
event(talkAbout(agent,content)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2027).
% event Converse(agent,agent)
event(converse(agent,agent)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2029).
% [agent1,agent2,time]
% Happens(Converse(agent1,agent2),time) ->
% {location}% 
% HoldsAt(At(agent1,location),time) &
% HoldsAt(At(agent2,location),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2031).
exists([Location],  (happens_at(converse(Agent1, Agent2), Time)->holds_at(at_loc(Agent1, Location), Time), holds_at(at_loc(Agent2, Location), Time))).


%; A precondition axiom states that for
%; an agent to greet an object,
%; there must be a location such that
%; the agent is at the location and
%; the object is at the location:
% [agent,object,time]
% Happens(Greet(agent,object),time) ->
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2040).
% {location}% 
% HoldsAt(At(agent,location),time) &
% HoldsAt(At(object,location),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2042).
exists([Location],  (happens_at(greet(Agent, Object), Time)->holds_at(at_loc(Agent, Location), Time), holds_at(at_loc(Object, Location), Time))).


% [agent,object,time]
% Happens(SayGoodbye(agent,object),time) ->
% {location}% 
% HoldsAt(At(agent,location),time) &
% HoldsAt(At(object,location),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2047).
exists([Location],  (happens_at(sayGoodbye(Agent, Object), Time)->holds_at(at_loc(Agent, Location), Time), holds_at(at_loc(Object, Location), Time))).


%; speech: expression of emotions
%; agent cries for joy.

% event CryForJoy(agent)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2054).
event(cryForJoy(agent)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2057).
%; A precondition axiom states that for
%; an agent to cry for joy,
%; the agent must be happy:
% [agent,time]
% Happens(CryForJoy(agent),time) ->
% HoldsAt(Happy(agent),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2060).
happens_at(cryForJoy(Agent), Time) ->
    holds_at(happy(Agent), Time).

% event Threaten(agent,agent,weapon)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2063).
event(threaten(agent,agent,weapon)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2066).
% event ReleaseFromThreat(agent,agent)
event(releaseFromThreat(agent,agent)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2068).
% fluent ThreatenedBy(agent,agent)
fluent(threatenedBy(agent,agent)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2070).
% [agent1,agent2,weapon,time]
% Happens(Threaten(agent1,agent2,weapon), time) ->
% HoldsAt(Holding(agent1,weapon),time) &
% {location}% 
% HoldsAt(At(agent1,location),time) &
% HoldsAt(At(agent2,location),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2073).
exists([Location],  (happens_at(threaten(Agent1, Agent2, Weapon), Time)->holds_at(holding(Agent1, Weapon), Time), holds_at(at_loc(Agent1, Location), Time), holds_at(at_loc(Agent2, Location), Time))).


% [agent1,agent2,weapon,time]
% Happens(Threaten(agent1,agent2,weapon), time) ->
% Happens(BecomeAngryAt(agent2,agent1),time).
happens_at(threaten(Agent1, Agent2, Weapon), Time) ->
    happens_at(becomeAngryAt(Agent2, Agent1), Time).


% [agent1,agent2,weapon,time]
% Initiates(Threaten(agent1,agent2,weapon),
%           ThreatenedBy(agent2,agent1),
%           time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2082).
initiates_at(threaten(Agent1,Agent2,Weapon),
	     threatenedBy(Agent2,Agent1),
	     Time).


% [agent1,agent2,time]
% Terminates(ReleaseFromThreat(agent1,agent2),
%            ThreatenedBy(agent2,agent1),
%            time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2087).
terminates_at(releaseFromThreat(Agent1,Agent2),
	      threatenedBy(Agent2,Agent1),
	      Time).

% event Order(agent,agent,physobj)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2090).
event(order(agent,agent,physobj)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2093).
% fluent KnowOrder(agent,agent,physobj)
fluent(knowOrder(agent,agent,physobj)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2095).
% [agent1,agent2,physobj,time]
% Initiates(Order(agent1,agent2,physobj),
%           KnowOrder(agent2,agent1,physobj),
%           time).
initiates_at(order(Agent1,Agent2,Physobj),
	     knowOrder(Agent2,Agent1,Physobj),
	     Time).


% [agent1,agent2,physobj,time]
% Happens(Order(agent1,agent2,physobj),time) ->
% {location}% 
% HoldsAt(At(agent1,location),time) &
% HoldsAt(At(agent2,location),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2101).
exists([Location],  (happens_at(order(Agent1, Agent2, Physobj), Time)->holds_at(at_loc(Agent1, Location), Time), holds_at(at_loc(Agent2, Location), Time))).

% event Request(agent,agent,physobj)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2105).
event(request(agent,agent,physobj)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2108).
% fluent KnowRequest(agent,agent,physobj)
fluent(knowRequest(agent,agent,physobj)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2110).
% [agent1,agent2,physobj,time]
% Initiates(Request(agent1,agent2,physobj),
%           KnowRequest(agent2,agent1,physobj),
%           time).
initiates_at(request(Agent1,Agent2,Physobj),
	     knowRequest(Agent2,Agent1,Physobj),
	     Time).


% [agent1,agent2,physobj,time]
% Happens(Request(agent1,agent2,physobj),time) ->
% {location}% 
% HoldsAt(At(agent1,location),time) &
% HoldsAt(At(agent2,location),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2116).
exists([Location],  (happens_at(request(Agent1, Agent2, Physobj), Time)->holds_at(at_loc(Agent1, Location), Time), holds_at(at_loc(Agent2, Location), Time))).


%; End of file.
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%; FILE: ecnet/Sleep.e
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;
%; Copyright (c) 2005 IBM Corporation and others.
%; All rights reserved. This program and the accompanying materials
%; are made available under the terms of the Common Public License v1.0
%; which accompanies this distribution, and is available at
%; http://www.eclipse.org/legal/cpl-v10.html
%;
%; Contributors:
%; IBM - Initial implementation
%;
%; The Sleep representation deals with the activity of sleeping and
%; body posture.
%; It is similar to the finite automaton representation of sleep
%; used in ThoughtTreasure \fullcite[chap. 7]{Mueller:1998}.
%;
%; @book{Mueller:1998,
%;   author = "Erik T. Mueller",
%;   year = "1998",
%;   title = "Natural Language Processing with \uppercase{T}hought\uppercase{T}reasure",
%;   address = "New York",
%;   publisher = "Signiform",
%; }
%;
%; sleep
%; agent wakes up.

% event WakeUp(agent)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2155).
event(wakeUp(agent)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2158).
%; agent gets tired.

% event GetTired(agent)
event(getTired(agent)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2161).
%; agent falls asleep.

% event FallAsleep(agent)
event(fallAsleep(agent)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2164).
%; agent is asleep.

% fluent Sleep0(agent)
fluent(sleep0(agent)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2164).
%; agent is awake and in bed.

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2167).
% fluent Sleep1(agent)
fluent(sleep1(agent)).


%; agent is awake, out of bed, and undressed.

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2169).
% fluent Sleep2(agent)
fluent(sleep2(agent)).


%; agent is awake and dressed.

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2171).
% fluent Sleep3(agent)
fluent(sleep3(agent)).


%; agent is tired and dressed.

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2173).
% fluent Sleep4(agent)
fluent(sleep4(agent)).


%; agent is tired and undressed.

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2175).
% fluent Sleep5(agent)
fluent(sleep5(agent)).


%; agent is in bed, waiting to fall asleep.

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2177).
% fluent Sleep6(agent)
fluent(sleep6(agent)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2179).
%; At any time, an agent is in one of seven sleep states:

% xor Sleep0, Sleep1, Sleep2, Sleep3, Sleep4, Sleep5, Sleep6
xor([sleep0,sleep1,sleep2,sleep3,sleep4,sleep5,sleep6]).
%; constraints
%; agent is asleep.

% fluent Asleep(agent)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2184).
fluent(asleep(agent)).


%; agent is awake.

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2187).
% fluent Awake(agent)
fluent(awake(agent)).

% noninertial Asleep
:- call_pel_directive(noninertial(asleep)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2189).
% noninertial Awake
:- call_pel_directive(noninertial(awake)).
%; Sleep0 indicates that the agent is asleep:
% [agent,time]
 % HoldsAt(Asleep(agent),time) <-> HoldsAt(Sleep0(agent),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2191).
holds_at(asleep(Agent), Time) <->
    holds_at(sleep0(Agent), Time).


%; In all other sleep states, the agent is awake:
% [agent,time]
% HoldsAt(Awake(agent),time) <->
% HoldsAt(Sleep1(agent),time) |
% HoldsAt(Sleep2(agent),time) |
% HoldsAt(Sleep3(agent),time) |
% HoldsAt(Sleep4(agent),time) |
% HoldsAt(Sleep5(agent),time) |
% HoldsAt(Sleep6(agent),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2195).
holds_at(awake(Agent), Time) <->
    (   holds_at(sleep1(Agent), Time)
    ;   holds_at(sleep2(Agent), Time)
    ;   holds_at(sleep3(Agent), Time)
    ;   holds_at(sleep4(Agent), Time)
    ;   holds_at(sleep5(Agent), Time)
    ;   holds_at(sleep6(Agent), Time)
    ).


%; A number of axioms are used to specify the transitions of
%; a finite automaton.
%;--
%; Waking up causes a transition from Sleep0
%; to Sleep1:
% [agent,time]
 
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2210).
% Terminates(WakeUp(agent),Sleep0(agent),time).
terminates_at(wakeUp(Agent),sleep0(Agent),Time).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2212).
% [agent,time]
 % Initiates(WakeUp(agent),Sleep1(agent),time).
initiates_at(wakeUp(Agent),sleep1(Agent),Time).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2214).
% [agent,time]
 % Happens(WakeUp(agent),time) -> HoldsAt(Sleep0(agent),time).
happens_at(wakeUp(Agent), Time) ->
    holds_at(sleep0(Agent), Time).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2216).
%;--
%; Getting out of bed causes a transition from Sleep1
%; to Sleep2:
% [agent,bed,time]
 
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2220).
% Terminates(RiseFrom(agent,bed),Sleep1(agent),time).
terminates_at(riseFrom(Agent,Bed),
	      sleep1(Agent),
	      Time).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2222).
% [agent,bed,time]
 % Initiates(RiseFrom(agent,bed),Sleep2(agent),time).
initiates_at(riseFrom(Agent,Bed),
	     sleep2(Agent),
	     Time).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2224).
% [agent,bed,time]
% Happens(RiseFrom(agent,bed),time) -> HoldsAt(Sleep1(agent),time).
happens_at(riseFrom(Agent, Bed), Time) ->
    holds_at(sleep1(Agent), Time).


%;--
%; Getting dressed causes a transition from Sleep2
%; to Sleep3, the normal state of awakeness:
% [agent,time]
 
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2231).
% Terminates(GetDressed(agent),Sleep2(agent),time).
terminates_at(getDressed(Agent),sleep2(Agent),Time).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2233).
% [agent,time]
 % Initiates(GetDressed(agent),Sleep3(agent),time).
initiates_at(getDressed(Agent),sleep3(Agent),Time).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2235).
% [agent,time]
 % Happens(GetDressed(agent),time) -> HoldsAt(Sleep2(agent),time).
happens_at(getDressed(Agent), Time) ->
    holds_at(sleep2(Agent), Time).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2237).
%;--
%; Getting tired causes a transition from Sleep3
%; to Sleep4:
% [agent,time]
 
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2241).
% Terminates(GetTired(agent),Sleep3(agent),time).
terminates_at(getTired(Agent),sleep3(Agent),Time).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2243).
% [agent,time]
 % Initiates(GetTired(agent),Sleep4(agent),time).
initiates_at(getTired(Agent),sleep4(Agent),Time).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2245).
% [agent,time]
 % Happens(GetTired(agent),time) -> HoldsAt(Sleep3(agent),time).
happens_at(getTired(Agent), Time) ->
    holds_at(sleep3(Agent), Time).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2247).
%;--
%; Getting undressed causes a transition from Sleep4
%; to Sleep5:
% [agent,time]
 
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2251).
% Terminates(GetUndressed(agent),Sleep4(agent),time).
terminates_at(getUndressed(Agent),sleep4(Agent),Time).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2253).
% [agent,time]
 % Initiates(GetUndressed(agent),Sleep5(agent),time).
initiates_at(getUndressed(Agent),sleep5(Agent),Time).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2255).
% [agent,time]
 % Happens(GetUndressed(agent),time) -> HoldsAt(Sleep4(agent),time).
happens_at(getUndressed(Agent), Time) ->
    holds_at(sleep4(Agent), Time).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2257).
%;--
%; Lying on a bed causes a transition from Sleep5
%; to Sleep6:
% [agent,bed,time]
 
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2261).
% Terminates(LieOn(agent,bed),Sleep5(agent),time).
terminates_at(lieOn(Agent,Bed),
	      sleep5(Agent),
	      Time).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2263).
% [agent,bed,time]
 % Initiates(LieOn(agent,bed),Sleep6(agent),time).
initiates_at(lieOn(Agent,Bed),
	     sleep6(Agent),
	     Time).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2265).
% [agent,bed,time]
 % Happens(LieOn(agent,bed),time) -> HoldsAt(Sleep5(agent),time).
happens_at(lieOn(Agent, Bed), Time) ->
    holds_at(sleep5(Agent), Time).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2267).
%;--
%; Falling asleep causes a transition from Sleep6
%; to Sleep0:
% [agent,time]
 
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2271).
% Terminates(FallAsleep(agent),Sleep6(agent),time).
terminates_at(fallAsleep(Agent),sleep6(Agent),Time).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2273).
% [agent,time]
 % Initiates(FallAsleep(agent),Sleep0(agent),time).
initiates_at(fallAsleep(Agent),sleep0(Agent),Time).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2275).
% [agent,time]
 % Happens(FallAsleep(agent),time) -> HoldsAt(Sleep6(agent),time).
happens_at(fallAsleep(Agent), Time) ->
    holds_at(sleep6(Agent), Time).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2277).
%;--
%; agent acts on being in state Sleep5.

% fluent ActOnSleep5(agent)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2279).
fluent(actOnSleep5(agent)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2281).
% noninertial ActOnSleep5
:- call_pel_directive(noninertial(actOnSleep5)).
%; We reduce the number of models by asserting that
%; an agent only acts on being in state Sleep5 while in
%; that state:
% [agent,time]
% !HoldsAt(Sleep5(agent),time) ->
% !HoldsAt(ActOnSleep5(agent),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2286).
holds_at(not(sleep5(Agent)), Time) ->
    holds_at(not(actOnSleep5(Agent)), Time).


%; Undressed is like IntentionToPlay
%; ActOnSleep5 is like ActOnIntentionToPlay
%; A trigger axiom states that if an agent is in state Sleep5,
%; the agent acts on this state, the agent is in a room, and
%; a bed is at the room, the agent lies on the bed:
% [agent,room,bed,time]
% HoldsAt(Sleep5(agent),time) &
% HoldsAt(ActOnSleep5(agent),time) &
% HoldsAt(At(agent,room),time) &
% HoldsAt(At(bed,room),time) ->
% Happens(LieOn(agent,bed),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2296).
holds_at(sleep5(Agent), Time), holds_at(actOnSleep5(Agent), Time), holds_at(at_loc(Agent, Room), Time), holds_at(at_loc(Bed, Room), Time) ->
    happens_at(lieOn(Agent, Bed), Time).


%; A precondition axiom states that for
%; an agent to lie on a bed,
%; the agent must be in state Sleep5,
%; the agent must act on this state, and
%; there must be a room such that
%; the agent is in the room and the bed is in the room:
% [agent,bed,time]
% Happens(LieOn(agent,bed),time) ->
% HoldsAt(Sleep5(agent),time) &
% HoldsAt(ActOnSleep5(agent),time) &
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2309).
% {room}% 
%  HoldsAt(At(agent,room),time) &
%  HoldsAt(At(bed,room),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2313).
exists([Room],  (happens_at(lieOn(Agent, Bed), Time)->holds_at(sleep5(Agent), Time), holds_at(actOnSleep5(Agent), Time), holds_at(at_loc(Agent, Room), Time), holds_at(at_loc(Bed, Room), Time))).


%; (body) posture
%; agent lies on physobj.

% event LieOn(agent,physobj)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2319).
event(lieOn(agent,physobj)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2322).
%; agent sits on physobj.

% event SitOn(agent,physobj)
event(sitOn(agent,physobj)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2325).
% [agent,physobj,time]
% Happens(SitOn(agent,physobj),time) ->
% {location}% 
%  HoldsAt(At(agent,location),time) &
%  HoldsAt(At(physobj,location),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2327).
exists([Location],  (happens_at(sitOn(Agent, Physobj), Time)->holds_at(at_loc(Agent, Location), Time), holds_at(at_loc(Physobj, Location), Time))).


%; agent rises from physobj.

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2332).
% event RiseFrom(agent,physobj)
event(riseFrom(agent,physobj)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2334).
%; agent is lying on physobj.

% fluent LyingOn(agent,physobj)
fluent(lyingOn(agent,physobj)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2334).
%; agent is sitting on physobj.

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2337).
% fluent SittingOn(agent,physobj)
fluent(sittingOn(agent,physobj)).


%; agent is standing.

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2339).
% fluent Standing(agent)
fluent(standing(agent)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2341).
%; agent is lying down.

% fluent Lying(agent)
fluent(lying(agent)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2341).
%; agent is sitting.

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2344).
% fluent Sitting(agent)
fluent(sitting(agent)).

% noninertial Lying
:- call_pel_directive(noninertial(lying)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2346).
% noninertial Sitting
:- call_pel_directive(noninertial(sitting)).
%; At any time, an agent is either lying, sitting, or standing:

% xor Lying, Sitting, Standing
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2348).
xor([lying,sitting,standing]).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2351).
% [agent,physobj,time]
% HoldsAt(LyingOn(agent,physobj),time) ->
% HoldsAt(Lying(agent),time).
holds_at(lyingOn(Agent, Physobj), Time) ->
    holds_at(lying(Agent), Time).


% [agent,physobj,time]
% HoldsAt(SittingOn(agent,physobj),time) ->
% HoldsAt(Sitting(agent),time).
holds_at(sittingOn(Agent, Physobj), Time) ->
    holds_at(sitting(Agent), Time).


%; State constraints represent that an agent can lie or sit
%; on at most one object at a time:
% [agent,physobj1,physobj2,time]
% HoldsAt(LyingOn(agent,physobj1),time) &
% HoldsAt(LyingOn(agent,physobj2),time) ->
% physobj1=physobj2.
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2361).
holds_at(lyingOn(Agent, Physobj1), Time), holds_at(lyingOn(Agent, Physobj2), Time) ->
    Physobj1=Physobj2.


% [agent,physobj1,physobj2,time]
% HoldsAt(SittingOn(agent,physobj1),time) &
% HoldsAt(SittingOn(agent,physobj2),time) ->
% physobj1=physobj2.
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2367).
holds_at(sittingOn(Agent, Physobj1), Time), holds_at(sittingOn(Agent, Physobj2), Time) ->
    Physobj1=Physobj2.


%; An effect axiom states that if an agent is standing and
%; lies on a physical object, the agent will be lying on
%; the physical object:
% [agent,physobj,time]
% HoldsAt(Standing(agent),time) ->
% Initiates(LieOn(agent,physobj),
%           LyingOn(agent,physobj),
%           time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2374).
holds_at(standing(Agent), Time) ->
    initiates_at(lieOn(Agent, Physobj),
                 lyingOn(Agent, Physobj),
                 Time).


%; An effect axiom states that if an agent
%; lies on a physical object, the agent will no longer
%; be standing:
% [agent,physobj,time]
% Terminates(LieOn(agent,physobj),
%            Standing(agent),
%            time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2383).
terminates_at(lieOn(Agent,Physobj),
	      standing(Agent),
	      Time).


%; An effect axiom states that if an agent is standing and
%; sits on a physical object, the agent will be sitting on
%; the physical object:
% [agent,physobj,time]
% HoldsAt(Standing(agent),time) ->
% Initiates(SitOn(agent,physobj),
%           SittingOn(agent,physobj),
%           time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2391).
holds_at(standing(Agent), Time) ->
    initiates_at(sitOn(Agent, Physobj),
                 sittingOn(Agent, Physobj),
                 Time).


%; An effect axiom states that if an agent
%; sits on a physical object, the agent will no longer
%; be standing:
% [agent,physobj,time]
% Terminates(SitOn(agent,physobj),
%            Standing(agent),
%            time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2400).
terminates_at(sitOn(Agent,Physobj),
	      standing(Agent),
	      Time).


%; An effect axiom states that if an agent
%; is sitting or lying on a physical object and
%; the agent rises from the physical object,
%; the agent will be standing:
% [agent,physobj,time]
% (HoldsAt(SittingOn(agent,physobj),time) |
%  HoldsAt(LyingOn(agent,physobj),time)) ->
% Initiates(RiseFrom(agent,physobj),
%           Standing(agent),
%           time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2409).
holds_at(sittingOn(Agent, Physobj), Time);holds_at(lyingOn(Agent, Physobj), Time) ->
    initiates_at(riseFrom(Agent, Physobj),
                 standing(Agent),
                 Time).


%; An effect axiom states that if an agent is sitting on
%; a physical object and the agent rises from the physical
%; object, the agent will no longer be sitting on the
%; physical object:
% [agent,physobj,time]
% HoldsAt(SittingOn(agent,physobj),time) ->
% Terminates(RiseFrom(agent,physobj),
%            SittingOn(agent,physobj),
%            time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2420).
holds_at(sittingOn(Agent, Physobj), Time) ->
    terminates_at(riseFrom(Agent, Physobj),
                  sittingOn(Agent, Physobj),
                  Time).


%; An effect axiom states that if an agent is lying on
%; a physical object and the agent rises from the physical
%; object, the agent will no longer be lying on the
%; physical object:
% [agent,physobj,time]
% HoldsAt(LyingOn(agent,physobj),time) ->
% Terminates(RiseFrom(agent,physobj),
%            LyingOn(agent,physobj),
%            time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2430).
holds_at(lyingOn(Agent, Physobj), Time) ->
    terminates_at(riseFrom(Agent, Physobj),
                  lyingOn(Agent, Physobj),
                  Time).


%; dressing
%; agent gets undressed.

% event GetDressed(agent)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2438).
event(getDressed(agent)).


%; agent gets dressed.

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2441).
% event GetUndressed(agent)
event(getUndressed(agent)).


%; agent is dressed.

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2443).
% fluent Dressed(agent)
fluent(dressed(agent)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2445).
%; Effect axioms deal with getting dressed and undressed:
% [agent,time]
 % Initiates(GetDressed(agent),Dressed(agent),time).
initiates_at(getDressed(Agent),dressed(Agent),Time).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2447).
% [agent,time]
 % Terminates(GetUndressed(agent),Dressed(agent),time).
terminates_at(getUndressed(Agent),
	      dressed(Agent),
	      Time).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2449).
%; End of file.
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%; FILE: ecnet/Sleeping.e
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;
%; Copyright (c) 2005 IBM Corporation and others.
%; All rights reserved. This program and the accompanying materials
%; are made available under the terms of the Common Public License v1.0
%; which accompanies this distribution, and is available at
%; http://www.eclipse.org/legal/cpl-v10.html
%;
%; Contributors:
%; IBM - Initial implementation
%;
%; @article{Mueller:2004c,
%;   author = "Erik T. Mueller",
%;   year = "2004",
%;   title = "Understanding script-based stories using commonsense reasoning",
%;   journal = "Cognitive Systems Research",
%;   volume = "5",
%;   number = "4",
%;   pages = "307--340",
%; }
%;

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2478).
% option modeldiff on
:- call_pel_directive(option(modeldiff, on)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2480).
% ignore Love, ThreatenedBy
:- call_pel_directive(ignore(love)).
:- call_pel_directive(ignore(threatenedBy)).

% ignore LookOutOnto, Floor, BuildingOf, SkyOf, GroundOf
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2480).
:- call_pel_directive(ignore(lookOutOnto)).
:- call_pel_directive(ignore(floor)).
:- call_pel_directive(ignore(buildingOf)).
:- call_pel_directive(ignore(skyOf)).
:- call_pel_directive(ignore(groundOf)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2482).
% ignore Inside, Near
:- call_pel_directive(ignore(inside)).
:- call_pel_directive(ignore(near)).

% ignore See
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2482).
:- call_pel_directive(ignore(see)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2485).
% ignore ActOnSleep5
:- call_pel_directive(ignore(actOnSleep5)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2487).
% option renaming off
:- call_pel_directive(option(renaming, off)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2489).
% load foundations/Root.e
:- call_pel_directive(load('foundations/Root.e')).

% load foundations/EC.e
:- call_pel_directive(load('foundations/EC.e')).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2491).
% load answers/Mueller2003/Ontology.e
:- call_pel_directive(load('answers/Mueller2003/Ontology.e')).

% load answers/Mueller2004c/RTSpaceM.e
:- call_pel_directive(load('answers/Mueller2004c/RTSpaceM.e')).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2493).
% load answers/Mueller2004c/OTSpaceM.e
:- call_pel_directive(load('answers/Mueller2004c/OTSpaceM.e')).

% load answers/Mueller2004c/Cognition.e
:- call_pel_directive(load('answers/Mueller2004c/Cognition.e')).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2495).
% load answers/Mueller2003/Sleep.e
:- call_pel_directive(load('answers/Mueller2003/Sleep.e')).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2497).
% door Door1
t(door,door1).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2499).
% room Room0
t(room,room0).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2501).
% room Room1
t(room,room1).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2503).
% Side1(Door1)=Room0.
side1(door1)=room0.


% Side2(Door1)=Room1.
side2(door1)=room1.

% agent Sleeper1
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2505).
t(agent,sleeper1).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2508).
% bed Bed1
t(bed,bed1).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2510).
% outside Outside1
t(outside,outside1).
%; initial state
% [agent,object]
 % !HoldsAt(Holding(agent,object),0).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2512).
holds_at(not(holding(Agent,Object)),0).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2514).
% [agent,physobj]
 % !HoldsAt(SittingOn(agent,physobj),0).
holds_at(not(sittingOn(Agent,Physobj)),0).


% [agent,physobj]
 % !HoldsAt(LyingOn(agent,physobj),0).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2514).
holds_at(not(lyingOn(Agent,Physobj)),0).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2516).
% HoldsAt(Dressed(Sleeper1),0).
holds_at(dressed(sleeper1),0).


% HoldsAt(Awake(Sleeper1),0).
holds_at(awake(sleeper1),0).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2518).
% HoldsAt(Sleep3(Sleeper1),0).
holds_at(sleep3(sleeper1),0).


% HoldsAt(Standing(Sleeper1),0).
holds_at(standing(sleeper1),0).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2520).
% HoldsAt(DoorUnlocked(Door1),0).
holds_at(doorUnlocked(door1),0).


% HoldsAt(DoorIsOpen(Door1),0).
holds_at(doorIsOpen(door1),0).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2522).
% HoldsAt(At(Sleeper1,Room0),0).
holds_at(at_loc(sleeper1,room0),0).


% HoldsAt(At(Bed1,Room1),0).
holds_at(at_loc(bed1,room1),0).


%; narrative


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2526).
% Happens(GetTired(Sleeper1),0).
happens_at(getTired(sleeper1),0).


% Happens(WalkThroughDoor12(Sleeper1,Door1),1).
happens_at(walkThroughDoor12(sleeper1,door1),1).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2528).
% Happens(GetUndressed(Sleeper1),2).
happens_at(getUndressed(sleeper1),2).


% Happens(LieOn(Sleeper1,Bed1),3).
happens_at(lieOn(sleeper1,bed1),3).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2530).
% Happens(FallAsleep(Sleeper1),4).
happens_at(fallAsleep(sleeper1),4).


% Happens(Dream(Sleeper1),5).
happens_at(dream(sleeper1),5).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2532).
% Happens(WakeUp(Sleeper1),6).
happens_at(wakeUp(sleeper1),6).


% Happens(RiseFrom(Sleeper1,Bed1),7).
happens_at(riseFrom(sleeper1,bed1),7).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2534).
% Happens(GetDressed(Sleeper1),8).
happens_at(getDressed(sleeper1),8).


% Happens(WalkThroughDoor21(Sleeper1,Door1),9).
happens_at(walkThroughDoor21(sleeper1,door1),9).

% range time 0 10
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2536).
:- call_pel_directive(range(time, 0, 10)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2538).
% range offset 0 0
:- call_pel_directive(range(offset, 0, 0)).

% range diameter 0 0
:- call_pel_directive(range(diameter, 0, 0)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2541).
% completion Happens
:- call_pel_directive(completion(happens_at)).
%; End of file.
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%; FILE: ecnet/Rest.e
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;
%; Copyright (c) 2005 IBM Corporation and others.
%; All rights reserved. This program and the accompanying materials
%; are made available under the terms of the Common Public License v1.0
%; which accompanies this distribution, and is available at
%; http://www.eclipse.org/legal/cpl-v10.html
%;
%; Contributors:
%; IBM - Initial implementation
%;
%; @article{Mueller:InPress,
%;   author = "Erik T. Mueller",
%;   year = "in press",
%;   title = "Modelling space and time in narratives about restaurants",
%;   journal = "Literary and Linguistic Computing",
%; }
%;

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2569).
% option renaming off
:- call_pel_directive(option(renaming, off)).

% option encoding 3
:- call_pel_directive(option(encoding, 3)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2572).
% load foundations/Root.e
:- call_pel_directive(load('foundations/Root.e')).

% load foundations/EC.e
:- call_pel_directive(load('foundations/EC.e')).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2574).
% load answers/Mueller2003/Ontology.e
:- call_pel_directive(load('answers/Mueller2003/Ontology.e')).

% load answers/MuellerInPress/RepRest.e
:- call_pel_directive(load('answers/MuellerInPress/RepRest.e')).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2577).
% door MainEntrance1
t(door,mainEntrance1).
%; room-scale topological space

% outside Street1
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2579).
t(outside,street1).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2581).
% room DiningRoom1
t(room,diningRoom1).

% door KitchenDoor1
t(door,kitchenDoor1).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2583).
% room Kitchen1
t(room,kitchen1).


% Side1(MainEntrance1)=Street1.
side1(mainEntrance1)=street1.


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2585).
% Side2(MainEntrance1)=DiningRoom1.
side2(mainEntrance1)=diningRoom1.


% Side1(KitchenDoor1)=DiningRoom1.
side1(kitchenDoor1)=diningRoom1.


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2587).
% Side2(KitchenDoor1)=Kitchen1.
side2(kitchenDoor1)=kitchen1.

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2589).
% agent Customer1
t(agent,customer1).

% menu Menu1
t(menu,menu1).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2591).
% chair Chair1
t(chair,chair1).

% food Food1
t(food,food1).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2593).
% HoldsAt(At(Customer1,Street1),0).
holds_at(at_loc(customer1,street1),0).


% HoldsAt(Hungry(Customer1),0).
holds_at(hungry(customer1),0).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2595).
% HoldsAt(At(Chair1,DiningRoom1),0).
holds_at(at_loc(chair1,diningRoom1),0).


% HoldsAt(At(Menu1,DiningRoom1),0).
holds_at(at_loc(menu1,diningRoom1),0).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2597).
% HoldsAt(On(Menu1,Table1),0).
holds_at(on(menu1,table1),0).


% HoldsAt(At(Food1,Kitchen1),0).
holds_at(at_loc(food1,kitchen1),0).

% waiter Waiter1
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2599).
t(waiter,waiter1).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2601).
% cook Cook1
t(cook,cook1).
%; props

% table Table1
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2603).
t(table,table1).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2605).
% bill Bill1
t(bill,bill1).
%; restaurant

% restaurant Restaurant1
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2607).
t(restaurant,restaurant1).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2609).
% CookOf(Restaurant1)=Cook1.
cookOf(restaurant1)=cook1.


% TableOf(Restaurant1)=Table1.
tableOf(restaurant1)=table1.


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2611).
% WaiterOf(Restaurant1)=Waiter1.
waiterOf(restaurant1)=waiter1.


% KitchenDoorOf(Restaurant1)=KitchenDoor1.
kitchenDoorOf(restaurant1)=kitchenDoor1.


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2613).
% BillOf(Restaurant1)=Bill1.
billOf(restaurant1)=bill1.


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2615).
%; prune

% sort ona, onb
sort(ona).
sort(onb).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2617).
% fluent! On(ona,onb)
fluent(on(ona,onb)).

% event! PlaceOn(agent,ona,onb)
event(placeOn(agent,ona,onb)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2619).
% event! TakeOffOf(agent,ona,onb)
event(takeOffOf(agent,ona,onb)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2621).
% sort ordera, orderb, orderc
sort(ordera).
sort(orderb).
sort(orderc).

% event! Order(ordera,orderb,orderc)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2621).
event(order(ordera,orderb,orderc)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2623).
% fluent! KnowOrder(orderb,ordera,orderc)
fluent(knowOrder(orderb,ordera,orderc)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2625).
% sort requesta, requestb, requestc
sort(requesta).
sort(requestb).
sort(requestc).

% event! Request(requesta,requestb,requestc)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2625).
event(request(requesta,requestb,requestc)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2627).
% fluent! KnowRequest(requestb,requesta,requestc)
fluent(knowRequest(requestb,requesta,requestc)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2629).
% sort holda, holdb, holdc
sort(holda).
sort(holdb).
sort(holdc).

% event! TakeOffOf(holda,holdb,holdc)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2629).
event(takeOffOf(holda,holdb,holdc)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2631).
% event! PickUp(holda,holdb)
event(pickUp(holda,holdb)).

% event! LetGoOf(holda,holdb)
event(letGoOf(holda,holdb)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2633).
% event! Hold(holda,holdb)
event(hold(holda,holdb)).

% fluent! Holding(holda,holdb)
fluent(holding(holda,holdb)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2636).
% sort sita, sitb
sort(sita).
sort(sitb).

% event! LieOn(sita,sitb)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2636).
event(lieOn(sita,sitb)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2638).
% event! SitOn(sita,sitb)
event(sitOn(sita,sitb)).

% event! RiseFrom(sita,sitb)
event(riseFrom(sita,sitb)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2640).
% fluent! LyingOn(sita,sitb)
fluent(lyingOn(sita,sitb)).

% fluent! SittingOn(sita,sitb)
fluent(sittingOn(sita,sitb)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2643).
% sort greeta, greetb
sort(greeta).
sort(greetb).

% event! Greet(greeta,greetb)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2643).
event(greet(greeta,greetb)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2646).
% ona! Menu1, Food1, Bill1
t(ona,menu1).
t(ona,food1).
t(ona,bill1).

% onb! Table1
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2646).
t(onb,table1).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2648).
% ordera! Customer1, Waiter1
t(ordera,customer1).
t(ordera,waiter1).

% orderb! Waiter1, Cook1
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2648).
t(orderb,waiter1).
t(orderb,cook1).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2650).
% orderc! Food1
t(orderc,food1).

% requesta! Customer1
t(requesta,customer1).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2652).
% requestb! Waiter1
t(requestb,waiter1).

% requestc! Bill1
t(requestc,bill1).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2654).
% holda! Customer1, Waiter1
t(holda,customer1).
t(holda,waiter1).

% holdb! Menu1, Food1, Bill1
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2654).
t(holdb,menu1).
t(holdb,food1).
t(holdb,bill1).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2656).
% holdc! Table1
t(holdc,table1).

% sita! Customer1
t(sita,customer1).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2658).
% sitb! Chair1
t(sitb,chair1).

% greeta! Customer1, Waiter1
t(greeta,customer1).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2658).
t(greeta,waiter1).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2660).
% greetb! Customer1, Waiter1
t(greetb,customer1).
t(greetb,waiter1).
%; initial situation


% HoldsAt(At(Waiter1,DiningRoom1),0).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2662).
holds_at(at_loc(waiter1,diningRoom1),0).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2664).
% HoldsAt(At(Cook1,Kitchen1),0).
holds_at(at_loc(cook1,kitchen1),0).


% HoldsAt(At(Table1,DiningRoom1),0).
holds_at(at_loc(table1,diningRoom1),0).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2666).
% !HoldsAt(On(Bill1,Table1),0).
holds_at(not(on(bill1,table1)),0).


% HoldsAt(At(Bill1,DiningRoom1),0).
holds_at(at_loc(bill1,diningRoom1),0).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2668).
% [agent]
 % HoldsAt(Standing(agent),0).
holds_at(standing(Agent),0).


% [agent,object]
 % !HoldsAt(Holding(agent,object),0).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2668).
holds_at(not(holding(Agent,Object)),0).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2670).
% [agent1,agent2,physobj]
 % !HoldsAt(KnowOrder(agent1,agent2,physobj),0).
holds_at(not(knowOrder(Agent1,Agent2,Physobj)),0).


% [agent1,agent2,physobj]
 % !HoldsAt(KnowRequest(agent1,agent2,physobj),0).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2670).
holds_at(not(knowRequest(Agent1,Agent2,Physobj)),0).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2672).
% HoldsAt(BeWaiter0(Waiter1),0).
holds_at(beWaiter0(waiter1),0).


% HoldsAt(BeCook0(Cook1),0).
holds_at(beCook0(cook1),0).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2674).
% [food]
 % !HoldsAt(FoodPrepared(food),0).
holds_at(not(foodPrepared(Food)),0).


% !HoldsAt(Hungry(Cook1),0).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2674).
holds_at(not(hungry(cook1)),0).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2676).
% !HoldsAt(Hungry(Waiter1),0).
holds_at(not(hungry(waiter1)),0).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2678).
% Happens(WalkThroughDoor12(Customer1,MainEntrance1),0).
happens_at(walkThroughDoor12(customer1,mainEntrance1),0).


% Happens(Greet(Waiter1,Customer1),1).
happens_at(greet(waiter1,customer1),1).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2680).
% Happens(SitOn(Customer1,Chair1),2).
happens_at(sitOn(customer1,chair1),2).


% Happens(TakeOffOf(Customer1,Menu1,Table1),3).
happens_at(takeOffOf(customer1,menu1,table1),3).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2682).
% Happens(Order(Customer1,Waiter1,Food1),4).
happens_at(order(customer1,waiter1,food1),4).


% Happens(PlaceOn(Customer1,Menu1,Table1),5).
happens_at(placeOn(customer1,menu1,table1),5).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2684).
% Happens(Eat(Customer1,Food1),11).
happens_at(eat(customer1,food1),11).


% Happens(Request(Customer1,Waiter1,Bill1),12).
happens_at(request(customer1,waiter1,bill1),12).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2686).
% Happens(Pay(Customer1,Waiter1),15).
happens_at(pay(customer1,waiter1),15).


% Happens(Tip(Customer1,Waiter1),15).
happens_at(tip(customer1,waiter1),15).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2688).
% Happens(RiseFrom(Customer1,Chair1),16).
happens_at(riseFrom(customer1,chair1),16).


% Happens(SayGoodbye(Customer1,Waiter1),17).
happens_at(sayGoodbye(customer1,waiter1),17).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2690).
% Happens(WalkThroughDoor21(Customer1,MainEntrance1),18).
happens_at(walkThroughDoor21(customer1,mainEntrance1),18).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2692).
% range time 0 19
:- call_pel_directive(range(time, 0, 19)).

% range offset 0 0
:- call_pel_directive(range(offset, 0, 0)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2694).
% range diameter 0 0
:- call_pel_directive(range(diameter, 0, 0)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2696).
% completion Happens
:- call_pel_directive(completion(happens_at)).
%; End of file.
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%; FILE: ecnet/RepRest.e
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;
%; Copyright (c) 2005 IBM Corporation and others.
%; All rights reserved. This program and the accompanying materials
%; are made available under the terms of the Common Public License v1.0
%; which accompanies this distribution, and is available at
%; http://www.eclipse.org/legal/cpl-v10.html
%;
%; Contributors:
%; IBM - Initial implementation
%;
%; @article{Mueller:InPress,
%;   author = "Erik T. Mueller",
%;   year = "in press",
%;   title = "Modelling space and time in narratives about restaurants",
%;   journal = "Literary and Linguistic Computing",
%; }
%;
%;sort boolean
%;sort integer
%;reified sort predicate
%;reified sort function
%;
%;sort time: integer
%;sort offset: integer
%;
%;reified sort fluent
%;reified sort event
%;
%;predicate Happens(event,time)
%;predicate HoldsAt(fluent,time)
%;predicate ReleasedAt(fluent,time)
%;predicate Initiates(event,fluent,time)
%;predicate Terminates(event,fluent,time)
%;predicate Releases(event,fluent,time)
%;
%;sort diameter: integer
%;
%;sort object
%;
%;sort agent: object
%;
%;sort physobj: object
%;sort bed: physobj
%;sort snowflake: physobj
%;sort sky: physobj
%;
%;sort stuff: physobj
%;
%;sort surface: physobj
%;sort ground: surface
%;
%;sort snow: stuff
%;sort ball
%;
%;sort food: physobj
%;sort fruit: food
%;sort orange: fruit
%;sort salad: food
%;
%;sort clothing: physobj
%;sort scarf: clothing
%;sort hat: clothing
%;
%;sort vegetablematter: physobj
%;sort coal: vegetablematter
%;
%;sort bodypart: physobj
%;sort hand: bodypart
%;
%;sort papertowels: physobj
%;sort device: physobj
%;sort electronicdevice: device
%;sort lamp: electronicdevice
%;
%;sort cat: physobj
%;
%;sort weapon: physobj
%;sort gun: weapon
%;sort bomb: weapon
%;sort bullet: weapon
%;
%;sort location
%;sort room: location, outside: location
%;
%;sort portal
%;sort door: portal, staircase: portal
%;sort street: portal
%;
%;sort building
%;
%;sort fire: object
%;
%;sort furniture: physobj
%;sort chair: furniture
%;sort table: furniture
%;
%;sort menu: physobj
%;sort bill: physobj
%;
%;sort script
%;

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2808).
% fluent Holding(agent,physobj)
fluent(holding(agent,physobj)).

% event PickUp(agent,physobj)
event(pickUp(agent,physobj)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2810).
% event LetGoOf(agent,physobj)
event(letGoOf(agent,physobj)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2812).
% [agent,physobj,time]
% Initiates(PickUp(agent,physobj),Holding(agent,physobj),time).
initiates_at(pickUp(Agent,Physobj),
	     holding(Agent,Physobj),
	     Time).


% [agent,physobj,time]
% Happens(PickUp(agent,physobj),time) ->
% {location}% 
%   HoldsAt(At(agent,location),time) &
%   HoldsAt(At(physobj,location),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2816).
exists([Location],  (happens_at(pickUp(Agent, Physobj), Time)->holds_at(at_loc(Agent, Location), Time), holds_at(at_loc(Physobj, Location), Time))).


% [agent,physobj,time]
% Terminates(LetGoOf(agent,physobj),Holding(agent,physobj),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2822).
terminates_at(letGoOf(Agent,Physobj),
	      holding(Agent,Physobj),
	      Time).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2824).
% [agent,physobj,time]
% Happens(LetGoOf(agent,physobj),time) ->
% HoldsAt(Holding(agent,physobj),time).
happens_at(letGoOf(Agent, Physobj), Time) ->
    holds_at(holding(Agent, Physobj), Time).


% [agent,physobj,location,time]
% Releases(PickUp(agent,physobj),At(physobj,location),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2829).
releases_at(pickUp(Agent,Physobj),
	    at_loc(Physobj,Location),
	    Time).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2831).
% [agent,physobj,location,time]
% HoldsAt(Holding(agent,physobj),time) &
% HoldsAt(At(agent,location),time) ->
% HoldsAt(At(physobj,location),time).
holds_at(holding(Agent, Physobj), Time), holds_at(at_loc(Agent, Location), Time) ->
    holds_at(at_loc(Physobj, Location), Time).


%;[agent,physobj,location1,location2,time]
%;HoldsAt(At(agent,location1),time) &
%;location1!=location2 ->
%;Terminates(LetGoOf(agent,physobj),At(physobj,location2),time).
% [agent,physobj,location,time]
% HoldsAt(At(agent,location),time) ->
% Initiates(LetGoOf(agent,physobj),At(physobj,location),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2841).
holds_at(at_loc(Agent, Location), Time) ->
    initiates_at(letGoOf(Agent, Physobj),
                 at_loc(Physobj, Location),
                 Time).

% fluent On(physobj,physobj)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2844).
fluent(on(physobj,physobj)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2847).
% event PlaceOn(agent,physobj,physobj)
event(placeOn(agent,physobj,physobj)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2849).
% event TakeOffOf(agent,physobj,physobj)
event(takeOffOf(agent,physobj,physobj)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2851).
% [physobj1,physobj2,time]
% HoldsAt(On(physobj1,physobj2),time) ->
% physobj1!=physobj2.
holds_at(on(Physobj1, Physobj2), Time) ->
    Physobj1\=Physobj2.


% [physobj1,physobj2,time]
% HoldsAt(On(physobj1,physobj2),time) ->
% !HoldsAt(On(physobj2,physobj1),time).
holds_at(on(Physobj1, Physobj2), Time) ->
    holds_at(not(on(Physobj2, Physobj1)), Time).


% [agent,physobj1,physobj2,time]
% Initiates(PlaceOn(agent,physobj1,physobj2),
%           On(physobj1,physobj2),time).
initiates_at(placeOn(Agent,Physobj1,Physobj2),
	     on(Physobj1,Physobj2),
	     Time).


% [agent,physobj1,physobj2,time]
% Terminates(PlaceOn(agent,physobj1,physobj2),
%            Holding(agent,physobj1),time).
terminates_at(placeOn(Agent,Physobj1,Physobj2),
	      holding(Agent,Physobj1),
	      Time).


% [agent,physobj1,physobj2,time]
% Happens(PlaceOn(agent,physobj1,physobj2),time) ->
% HoldsAt(Holding(agent,physobj1),time) &
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2868).
% {location}% 
%  HoldsAt(At(agent,location),time) &
%  HoldsAt(At(physobj2,location),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2870).
exists([Location],  (happens_at(placeOn(Agent, Physobj1, Physobj2), Time)->holds_at(holding(Agent, Physobj1), Time), holds_at(at_loc(Agent, Location), Time), holds_at(at_loc(Physobj2, Location), Time))).


% [agent,physobj1,physobj2,time]
% Terminates(TakeOffOf(agent,physobj1,physobj2),
%            On(physobj1,physobj2),time).
terminates_at(takeOffOf(Agent,Physobj1,Physobj2),
	      on(Physobj1,Physobj2),
	      Time).


% [agent,physobj1,physobj2,time]
% Initiates(TakeOffOf(agent,physobj1,physobj2),
%           Holding(agent,physobj1),time).
initiates_at(takeOffOf(Agent,Physobj1,Physobj2),
	     holding(Agent,Physobj1),
	     Time).


% [agent,physobj1,physobj2,location,time]
% Releases(TakeOffOf(agent,physobj1,physobj2),
%          At(physobj1,location),
%          time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2883).
releases_at(takeOffOf(Agent,Physobj1,Physobj2),
	    at_loc(Physobj1,Location),
	    Time).


% [agent,physobj1,physobj2,time]
% Happens(TakeOffOf(agent,physobj1,physobj2),time) ->
% HoldsAt(On(physobj1,physobj2),time) &
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2888).
% {location}% 
%  HoldsAt(At(agent,location),time) &
%  HoldsAt(At(physobj1,location),time) &
%  HoldsAt(At(physobj2,location),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2890).
exists([Location],  (happens_at(takeOffOf(Agent, Physobj1, Physobj2), Time)->holds_at(on(Physobj1, Physobj2), Time), holds_at(at_loc(Agent, Location), Time), holds_at(at_loc(Physobj1, Location), Time), holds_at(at_loc(Physobj2, Location), Time))).


% [agent,physobj1,physobj2,location,time]
% Releases(PlaceOn(agent,physobj1,physobj2),
%          At(physobj1,location),
%          time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2896).
releases_at(placeOn(Agent,Physobj1,Physobj2),
	    at_loc(Physobj1,Location),
	    Time).


% [physobj1,physobj2,location,time]
% HoldsAt(On(physobj1,physobj2),time) &
% HoldsAt(At(physobj2,location),time) ->
% HoldsAt(At(physobj1,location),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2901).
holds_at(on(Physobj1, Physobj2), Time), holds_at(at_loc(Physobj2, Location), Time) ->
    holds_at(at_loc(Physobj1, Location), Time).

% fluent At(object,location)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2904).
fluent(at_loc(object,location)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2907).
% [object,time]
% {location} % HoldsAt(At(object,location),time).
exists([Location],
 holds_at(at_loc(Object,Location),Time)).


% [object,location1,location2,time]
% HoldsAt(At(object,location1),time) &
% HoldsAt(At(object,location2),time) ->
% location1=location2.
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2911).
holds_at(at_loc(Object, Location1), Time), holds_at(at_loc(Object, Location2), Time) ->
    Location1=Location2.

% function Side1(portal): location
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2914).
function(side1(portal),location).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2916).
% function Side2(portal): location
function(side2(portal),location).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2918).
% fluent NearPortal(object,portal)
fluent(nearPortal(object,portal)).

% noninertial NearPortal
:- call_pel_directive(noninertial(nearPortal)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2921).
% [object,portal,time]
% HoldsAt(NearPortal(object,portal),time) <->
% {location}% 
%  (Side1(portal)=location|
%   Side2(portal)=location) &
%  HoldsAt(At(object,location),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2923).
exists([Location],  (holds_at(nearPortal(Object, Portal), Time)<->(side1(Portal)=Location;side2(Portal)=Location), holds_at(at_loc(Object, Location), Time))).

% event WalkThroughDoor12(agent,door)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2927).
event(walkThroughDoor12(agent,door)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2929).
% event WalkThroughDoor21(agent,door)
event(walkThroughDoor21(agent,door)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2931).
% [agent,door,time]
% Happens(WalkThroughDoor12(agent,door),time) ->
% HoldsAt(Standing(agent),time) &
% HoldsAt(At(agent,Side1(door)),time).
happens_at(walkThroughDoor12(Agent, Door), Time) ->
    holds_at(standing(Agent), Time),
    holds_at(at_loc(Agent, side1(Door)), Time).


% [agent,door,time]
% Happens(WalkThroughDoor21(agent,door),time) ->
% HoldsAt(Standing(agent),time) &
% HoldsAt(At(agent,Side2(door)),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2937).
happens_at(walkThroughDoor21(Agent, Door), Time) ->
    holds_at(standing(Agent), Time),
    holds_at(at_loc(Agent, side2(Door)), Time).


% [agent,door,location,time]
% Side2(door)=location ->
% Initiates(WalkThroughDoor12(agent,door),At(agent,location),time).
side2(Door)=Location ->
    initiates_at(walkThroughDoor12(Agent, Door),
                 at_loc(Agent, Location),
                 Time).


% [agent,door,location,time]
% Side1(door)=location ->
% Initiates(WalkThroughDoor21(agent,door),At(agent,location),time).
side1(Door)=Location ->
    initiates_at(walkThroughDoor21(Agent, Door),
                 at_loc(Agent, Location),
                 Time).


% [agent,door,location,time]
% Side1(door)=location ->
% Terminates(WalkThroughDoor12(agent,door),At(agent,location),time).
side1(Door)=Location ->
    terminates_at(walkThroughDoor12(Agent, Door),
                  at_loc(Agent, Location),
                  Time).


% [agent,door,location,time]
% Side2(door)=location ->
% Terminates(WalkThroughDoor21(agent,door),At(agent,location),time).
side2(Door)=Location ->
    terminates_at(walkThroughDoor21(Agent, Door),
                  at_loc(Agent, Location),
                  Time).

% fluent Hungry(agent)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2956).
fluent(hungry(agent)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2959).
% fluent Satiated(agent)
fluent(satiated(agent)).

% noninertial Satiated
:- call_pel_directive(noninertial(satiated)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2962).
% [agent,time]
 % HoldsAt(Hungry(agent),time) <-> !HoldsAt(Satiated(agent),time).
holds_at(hungry(Agent), Time) <->
    holds_at(not(satiated(Agent)), Time).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2964).
% event Eat(agent,food)
event(eat(agent,food)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2966).
% [agent,food,time]
% Happens(Eat(agent,food),time) ->
% {location}% 
% HoldsAt(At(agent,location),time) &
% HoldsAt(At(food,location),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2968).
exists([Location],  (happens_at(eat(Agent, Food), Time)->holds_at(at_loc(Agent, Location), Time), holds_at(at_loc(Food, Location), Time))).


% [agent,food,time]
% Terminates(Eat(agent,food),Hungry(agent),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2973).
terminates_at(eat(Agent,Food),
	      hungry(Agent),
	      Time).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2975).
% sort restaurant: script
subsort(restaurant,script).

% sort waiter: agent
subsort(waiter,agent).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2977).
% sort cook: agent
subsort(cook,agent).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2979).
% function BillOf(restaurant): bill
function(billOf(restaurant),bill).

% function CookOf(restaurant): cook
function(cookOf(restaurant),cook).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2981).
% function TableOf(restaurant): table
function(tableOf(restaurant),table).

% function WaiterOf(restaurant): waiter
function(waiterOf(restaurant),waiter).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2983).
% function KitchenDoorOf(restaurant): door
function(kitchenDoorOf(restaurant),door).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2985).
% fluent BeWaiter0(waiter)
fluent(beWaiter0(waiter)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2987).
% fluent BeWaiter1(waiter)
fluent(beWaiter1(waiter)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2989).
% fluent BeWaiter2(waiter)
fluent(beWaiter2(waiter)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2991).
% fluent BeWaiter3(waiter)
fluent(beWaiter3(waiter)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2993).
% fluent BeWaiter4(waiter)
fluent(beWaiter4(waiter)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2995).
% fluent BeWaiter5(waiter)
fluent(beWaiter5(waiter)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2997).
% fluent BeWaiter6(waiter)
fluent(beWaiter6(waiter)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',2999).
% fluent BeWaiter7(waiter)
fluent(beWaiter7(waiter)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3001).
% fluent BeWaiter8(waiter)
fluent(beWaiter8(waiter)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3003).
% fluent BeWaiter9(waiter)
fluent(beWaiter9(waiter)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3005).
% xor BeWaiter0, BeWaiter1, BeWaiter2, BeWaiter3, BeWaiter4, BeWaiter5, BeWaiter6, BeWaiter7, BeWaiter8, BeWaiter9
xor([ beWaiter0,
      beWaiter1,
      beWaiter2,
      beWaiter3,
      beWaiter4,
      beWaiter5,
      beWaiter6,
      beWaiter7,
      beWaiter8,
      beWaiter9
    ]).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3007).
% [waiter,agent,time]
% HoldsAt(BeWaiter0(waiter),time) ->
% Terminates(Greet(waiter,agent),
%            BeWaiter0(waiter),
%            time).
holds_at(beWaiter0(Waiter), Time) ->
    terminates_at(greet(Waiter, Agent),
                  beWaiter0(Waiter),
                  Time).


% [waiter,agent,time]
% HoldsAt(BeWaiter0(waiter),time) ->
% Initiates(Greet(waiter,agent),
%           BeWaiter1(waiter),
%           time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3014).
holds_at(beWaiter0(Waiter), Time) ->
    initiates_at(greet(Waiter, Agent),
                 beWaiter1(Waiter),
                 Time).


% [waiter,agent,food,time]
% HoldsAt(BeWaiter1(waiter),time) ->
% Terminates(Order(agent,waiter,food),
%            BeWaiter1(waiter),
%            time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3020).
holds_at(beWaiter1(Waiter), Time) ->
    terminates_at(order(Agent, Waiter, Food),
                  beWaiter1(Waiter),
                  Time).


% [waiter,agent,food,time]
% HoldsAt(BeWaiter1(waiter),time) ->
% Initiates(Order(agent,waiter,food),
%           BeWaiter2(waiter),
%           time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3026).
holds_at(beWaiter1(Waiter), Time) ->
    initiates_at(order(Agent, Waiter, Food),
                 beWaiter2(Waiter),
                 Time).


% [restaurant,waiter,time]
% WaiterOf(restaurant)=waiter &
% HoldsAt(BeWaiter2(waiter),time) ->
% Happens(WalkThroughDoor12(waiter,KitchenDoorOf(restaurant)),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3032).
waiterOf(Restaurant)=Waiter, holds_at(beWaiter2(Waiter), Time) ->
    happens_at(walkThroughDoor12(Waiter, kitchenDoorOf(Restaurant)),
               Time).


% [restaurant,waiter,door,time]
% HoldsAt(BeWaiter2(waiter),time) &
% WaiterOf(restaurant)=waiter &
% KitchenDoorOf(restaurant)=door ->
% Terminates(WalkThroughDoor12(waiter,door),
%            BeWaiter2(waiter),
%            time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3037).
holds_at(beWaiter2(Waiter), Time), waiterOf(Restaurant)=Waiter, kitchenDoorOf(Restaurant)=Door ->
    terminates_at(walkThroughDoor12(Waiter, Door),
                  beWaiter2(Waiter),
                  Time).


% [restaurant,waiter,door,time]
% HoldsAt(BeWaiter2(waiter),time) &
% WaiterOf(restaurant)=waiter &
% KitchenDoorOf(restaurant)=door ->
% Initiates(WalkThroughDoor12(waiter,door),
%           BeWaiter3(waiter),
%           time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3045).
holds_at(beWaiter2(Waiter), Time), waiterOf(Restaurant)=Waiter, kitchenDoorOf(Restaurant)=Door ->
    initiates_at(walkThroughDoor12(Waiter, Door),
                 beWaiter3(Waiter),
                 Time).


% [restaurant,food,time]
% HoldsAt(BeWaiter3(WaiterOf(restaurant)),time) &
% ({agent} HoldsAt(KnowOrder(WaiterOf(restaurant),agent,food),time)) ->
% Happens(Order(WaiterOf(restaurant),CookOf(restaurant),food),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3053).
holds_at(beWaiter3(waiterOf(Restaurant)), Time), exists([Agent], holds_at(knowOrder(waiterOf(Restaurant), Agent, Food), Time)) ->
    happens_at(order(waiterOf(Restaurant),
                     cookOf(Restaurant),
                     Food),
               Time).


% [restaurant,waiter,cook,food,time]
% WaiterOf(restaurant)=waiter &
% CookOf(restaurant)=cook &
% HoldsAt(BeWaiter3(waiter),time) ->
% Terminates(Order(waiter,cook,food),
%            BeWaiter3(waiter),
%            time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3058).
waiterOf(Restaurant)=Waiter, cookOf(Restaurant)=Cook, holds_at(beWaiter3(Waiter), Time) ->
    terminates_at(order(Waiter, Cook, Food),
                  beWaiter3(Waiter),
                  Time).


% [restaurant,waiter,cook,food,time]
% WaiterOf(restaurant)=waiter &
% CookOf(restaurant)=cook &
% HoldsAt(BeWaiter3(waiter),time) ->
% Initiates(Order(waiter,cook,food),
%           BeWaiter4(waiter),
%           time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3066).
waiterOf(Restaurant)=Waiter, cookOf(Restaurant)=Cook, holds_at(beWaiter3(Waiter), Time) ->
    initiates_at(order(Waiter, Cook, Food),
                 beWaiter4(Waiter),
                 Time).


% [waiter,food,time]
% HoldsAt(BeWaiter4(waiter),time) &
% ({agent} HoldsAt(KnowOrder(waiter,agent,food),time)) &
% HoldsAt(FoodPrepared(food),time) ->
% Happens(PickUp(waiter,food),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3074).
holds_at(beWaiter4(Waiter), Time), exists([Agent], holds_at(knowOrder(Waiter, Agent, Food), Time)), holds_at(foodPrepared(Food), Time) ->
    happens_at(pickUp(Waiter, Food), Time).


% [waiter,food,time]
% HoldsAt(BeWaiter4(waiter),time) &
% ({agent} HoldsAt(KnowOrder(waiter,agent,food),time)) ->
% Terminates(PickUp(waiter,food),
%            BeWaiter4(waiter),
%            time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3080).
holds_at(beWaiter4(Waiter), Time), exists([Agent], holds_at(knowOrder(Waiter, Agent, Food), Time)) ->
    terminates_at(pickUp(Waiter, Food),
                  beWaiter4(Waiter),
                  Time).


% [waiter,food,time]
% HoldsAt(BeWaiter4(waiter),time) &
% ({agent} HoldsAt(KnowOrder(waiter,agent,food),time)) ->
% Initiates(PickUp(waiter,food),
%           BeWaiter5(waiter),
%           time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3087).
holds_at(beWaiter4(Waiter), Time), exists([Agent], holds_at(knowOrder(Waiter, Agent, Food), Time)) ->
    initiates_at(pickUp(Waiter, Food),
                 beWaiter5(Waiter),
                 Time).


% [restaurant,waiter,time]
% WaiterOf(restaurant)=waiter &
% HoldsAt(BeWaiter5(waiter),time) ->
% Happens(WalkThroughDoor21(waiter,KitchenDoorOf(restaurant)),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3094).
waiterOf(Restaurant)=Waiter, holds_at(beWaiter5(Waiter), Time) ->
    happens_at(walkThroughDoor21(Waiter, kitchenDoorOf(Restaurant)),
               Time).


% [restaurant,waiter,door,time]
% HoldsAt(BeWaiter5(waiter),time) &
% WaiterOf(restaurant)=waiter &
% KitchenDoorOf(restaurant)=door ->
% Terminates(WalkThroughDoor21(waiter,door),
%            BeWaiter5(waiter),
%            time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3099).
holds_at(beWaiter5(Waiter), Time), waiterOf(Restaurant)=Waiter, kitchenDoorOf(Restaurant)=Door ->
    terminates_at(walkThroughDoor21(Waiter, Door),
                  beWaiter5(Waiter),
                  Time).


% [restaurant,waiter,door,time]
% HoldsAt(BeWaiter5(waiter),time) &
% WaiterOf(restaurant)=waiter &
% KitchenDoorOf(restaurant)=door ->
% Initiates(WalkThroughDoor21(waiter,door),
%           BeWaiter6(waiter),
%           time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3107).
holds_at(beWaiter5(Waiter), Time), waiterOf(Restaurant)=Waiter, kitchenDoorOf(Restaurant)=Door ->
    initiates_at(walkThroughDoor21(Waiter, Door),
                 beWaiter6(Waiter),
                 Time).


% [restaurant,waiter,table,food,time]
% WaiterOf(restaurant)=waiter &
% TableOf(restaurant)=table &
% HoldsAt(BeWaiter6(waiter),time) &
% HoldsAt(Holding(waiter,food),time) ->
% Happens(PlaceOn(waiter,food,table),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3115).
waiterOf(Restaurant)=Waiter, tableOf(Restaurant)=Table, holds_at(beWaiter6(Waiter), Time), holds_at(holding(Waiter, Food), Time) ->
    happens_at(placeOn(Waiter, Food, Table), Time).


% [waiter,food,table,time]
% HoldsAt(BeWaiter6(waiter),time) ->
% Terminates(PlaceOn(waiter,food,table),
%            BeWaiter6(waiter),
%            time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3122).
holds_at(beWaiter6(Waiter), Time) ->
    terminates_at(placeOn(Waiter, Food, Table),
                  beWaiter6(Waiter),
                  Time).


% [waiter,food,table,time]
% HoldsAt(BeWaiter6(waiter),time) ->
% Initiates(PlaceOn(waiter,food,table),
%           BeWaiter7(waiter),
%           time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3128).
holds_at(beWaiter6(Waiter), Time) ->
    initiates_at(placeOn(Waiter, Food, Table),
                 beWaiter7(Waiter),
                 Time).


% [waiter,agent,bill,time]
% HoldsAt(BeWaiter7(waiter),time) ->
% Terminates(Request(agent,waiter,bill),
%            BeWaiter7(waiter),
%            time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3134).
holds_at(beWaiter7(Waiter), Time) ->
    terminates_at(request(Agent, Waiter, Bill),
                  beWaiter7(Waiter),
                  Time).


% [waiter,agent,bill,time]
% HoldsAt(BeWaiter7(waiter),time) ->
% Initiates(Request(agent,waiter,bill),
%           BeWaiter8(waiter),
%           time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3140).
holds_at(beWaiter7(Waiter), Time) ->
    initiates_at(request(Agent, Waiter, Bill),
                 beWaiter8(Waiter),
                 Time).


% [restaurant,waiter,bill,time]
% WaiterOf(restaurant)=waiter &
% BillOf(restaurant)=bill &
% HoldsAt(BeWaiter8(waiter),time) ->
% Happens(PickUp(waiter,bill),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3146).
waiterOf(Restaurant)=Waiter, billOf(Restaurant)=Bill, holds_at(beWaiter8(Waiter), Time) ->
    happens_at(pickUp(Waiter, Bill), Time).


% [waiter,bill,time]
% HoldsAt(BeWaiter8(waiter),time) ->
% Terminates(PickUp(waiter,bill),
%            BeWaiter8(waiter),
%            time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3152).
holds_at(beWaiter8(Waiter), Time) ->
    terminates_at(pickUp(Waiter, Bill),
                  beWaiter8(Waiter),
                  Time).


% [waiter,bill,time]
% HoldsAt(BeWaiter8(waiter),time) ->
% Initiates(PickUp(waiter,bill),
%           BeWaiter9(waiter),
%           time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3158).
holds_at(beWaiter8(Waiter), Time) ->
    initiates_at(pickUp(Waiter, Bill),
                 beWaiter9(Waiter),
                 Time).


% [restaurant,waiter,bill,table,time]
% WaiterOf(restaurant)=waiter &
% BillOf(restaurant)=bill &
% TableOf(restaurant)=table &
% HoldsAt(BeWaiter9(waiter),time) ->
% Happens(PlaceOn(waiter,bill,table),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3164).
waiterOf(Restaurant)=Waiter, billOf(Restaurant)=Bill, tableOf(Restaurant)=Table, holds_at(beWaiter9(Waiter), Time) ->
    happens_at(placeOn(Waiter, Bill, Table), Time).


% [waiter,bill,table,time]
% HoldsAt(BeWaiter9(waiter),time) ->
% Terminates(PlaceOn(waiter,bill,table),
%            BeWaiter9(waiter),
%            time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3171).
holds_at(beWaiter9(Waiter), Time) ->
    terminates_at(placeOn(Waiter, Bill, Table),
                  beWaiter9(Waiter),
                  Time).


% [waiter,bill,table,time]
% HoldsAt(BeWaiter9(waiter),time) ->
% Initiates(PlaceOn(waiter,bill,table),
%           BeWaiter0(waiter),
%           time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3177).
holds_at(beWaiter9(Waiter), Time) ->
    initiates_at(placeOn(Waiter, Bill, Table),
                 beWaiter0(Waiter),
                 Time).

% fluent BeCook0(cook)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3181).
fluent(beCook0(cook)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3184).
% fluent BeCook1(cook)
fluent(beCook1(cook)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3186).
% xor BeCook0, BeCook1
xor([beCook0,beCook1]).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3188).
% [cook,agent,food,time]
% HoldsAt(BeCook0(cook),time) ->
% Terminates(Order(agent,cook,food),
%            BeCook0(cook),
%            time).
holds_at(beCook0(Cook), Time) ->
    terminates_at(order(Agent, Cook, Food),
                  beCook0(Cook),
                  Time).


% [cook,agent,food,time]
% HoldsAt(BeCook0(cook),time) ->
% Initiates(Order(agent,cook,food),
%           BeCook1(cook),
%           time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3195).
holds_at(beCook0(Cook), Time) ->
    initiates_at(order(Agent, Cook, Food),
                 beCook1(Cook),
                 Time).

% event FoodPrepare(agent,food)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3199).
event(foodPrepare(agent,food)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3202).
% fluent FoodPrepared(food)
fluent(foodPrepared(food)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3204).
% [agent,food,time]
% Initiates(FoodPrepare(agent,food),
%           FoodPrepared(food),
%           time).
initiates_at(foodPrepare(Agent,Food),
	     foodPrepared(Food),
	     Time).


% [agent,food,time]
% Happens(FoodPrepare(agent,food),time) ->
% {location}% 
% HoldsAt(At(agent,location),time) &
% HoldsAt(At(food,location),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3210).
exists([Location],  (happens_at(foodPrepare(Agent, Food), Time)->holds_at(at_loc(Agent, Location), Time), holds_at(at_loc(Food, Location), Time))).


% [cook,agent,food,time]
% HoldsAt(BeCook1(cook),time) &
% HoldsAt(KnowOrder(cook,agent,food),time) ->
% Happens(FoodPrepare(cook,food),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3216).
holds_at(beCook1(Cook), Time), holds_at(knowOrder(Cook, Agent, Food), Time) ->
    happens_at(foodPrepare(Cook, Food), Time).


% [cook,food,time]
% HoldsAt(BeCook1(cook),time) ->
% Terminates(FoodPrepare(cook,food),
%            BeCook1(cook),
%            time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3221).
holds_at(beCook1(Cook), Time) ->
    terminates_at(foodPrepare(Cook, Food),
                  beCook1(Cook),
                  Time).


% [cook,food,time]
% HoldsAt(BeCook1(cook),time) ->
% Initiates(FoodPrepare(cook,food),
%           BeCook0(cook),
%           time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3227).
holds_at(beCook1(Cook), Time) ->
    initiates_at(foodPrepare(Cook, Food),
                 beCook0(Cook),
                 Time).

% event Pay(agent,agent)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3231).
event(pay(agent,agent)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3234).
% event Tip(agent,agent)
event(tip(agent,agent)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3236).
% [agent,physobj,time]
% Happens(LieOn(agent,physobj),time) ->
% {room}% 
%  HoldsAt(At(agent,room),time) &
%  HoldsAt(At(physobj,room),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3238).
exists([Room],  (happens_at(lieOn(Agent, Physobj), Time)->holds_at(at_loc(Agent, Room), Time), holds_at(at_loc(Physobj, Room), Time))).


% [agent,physobj,time]
% Happens(SitOn(agent,physobj),time) ->
% {room}% 
%  HoldsAt(At(agent,room),time) &
%  HoldsAt(At(physobj,room),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3243).
exists([Room],  (happens_at(sitOn(Agent, Physobj), Time)->holds_at(at_loc(Agent, Room), Time), holds_at(at_loc(Physobj, Room), Time))).

% event LieOn(agent,physobj)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3247).
event(lieOn(agent,physobj)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3250).
% event SitOn(agent,physobj)
event(sitOn(agent,physobj)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3252).
% event RiseFrom(agent,physobj)
event(riseFrom(agent,physobj)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3254).
% fluent LyingOn(agent,physobj)
fluent(lyingOn(agent,physobj)).

% fluent SittingOn(agent,physobj)
fluent(sittingOn(agent,physobj)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3256).
% fluent Standing(agent)
fluent(standing(agent)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3258).
% fluent Lying(agent)
fluent(lying(agent)).

% fluent Sitting(agent)
fluent(sitting(agent)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3260).
% noninertial Lying
:- call_pel_directive(noninertial(lying)).

% noninertial Sitting
:- call_pel_directive(noninertial(sitting)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3263).
% xor Lying, Sitting, Standing
xor([lying,sitting,standing]).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3265).
% [agent,physobj,time]
% HoldsAt(LyingOn(agent,physobj),time) ->
% HoldsAt(Lying(agent),time).
holds_at(lyingOn(Agent, Physobj), Time) ->
    holds_at(lying(Agent), Time).


% [agent,physobj,time]
% HoldsAt(SittingOn(agent,physobj),time) ->
% HoldsAt(Sitting(agent),time).
holds_at(sittingOn(Agent, Physobj), Time) ->
    holds_at(sitting(Agent), Time).


% [agent,physobj1,physobj2,time]
% HoldsAt(LyingOn(agent,physobj1),time) &
% HoldsAt(LyingOn(agent,physobj2),time) ->
% physobj1=physobj2.
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3274).
holds_at(lyingOn(Agent, Physobj1), Time), holds_at(lyingOn(Agent, Physobj2), Time) ->
    Physobj1=Physobj2.


% [agent,physobj1,physobj2,time]
% HoldsAt(SittingOn(agent,physobj1),time) &
% HoldsAt(SittingOn(agent,physobj2),time) ->
% physobj1=physobj2.
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3279).
holds_at(sittingOn(Agent, Physobj1), Time), holds_at(sittingOn(Agent, Physobj2), Time) ->
    Physobj1=Physobj2.


% [agent,physobj,time]
% HoldsAt(Standing(agent),time) ->
% Initiates(LieOn(agent,physobj),
%           LyingOn(agent,physobj),
%           time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3284).
holds_at(standing(Agent), Time) ->
    initiates_at(lieOn(Agent, Physobj),
                 lyingOn(Agent, Physobj),
                 Time).


% [agent,physobj,time]
% Terminates(LieOn(agent,physobj),
%            Standing(agent),
%            time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3290).
terminates_at(lieOn(Agent,Physobj),
	      standing(Agent),
	      Time).


% [agent,physobj,time]
% HoldsAt(Standing(agent),time) ->
% Initiates(SitOn(agent,physobj),
%           SittingOn(agent,physobj),
%           time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3295).
holds_at(standing(Agent), Time) ->
    initiates_at(sitOn(Agent, Physobj),
                 sittingOn(Agent, Physobj),
                 Time).


% [agent,physobj,time]
% Terminates(SitOn(agent,physobj),
%            Standing(agent),
%            time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3301).
terminates_at(sitOn(Agent,Physobj),
	      standing(Agent),
	      Time).


% [agent,physobj,time]
% (HoldsAt(SittingOn(agent,physobj),time) |
%  HoldsAt(LyingOn(agent,physobj),time)) ->
% Initiates(RiseFrom(agent,physobj),
%           Standing(agent),
%           time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3306).
holds_at(sittingOn(Agent, Physobj), Time);holds_at(lyingOn(Agent, Physobj), Time) ->
    initiates_at(riseFrom(Agent, Physobj),
                 standing(Agent),
                 Time).


% [agent,physobj,time]
% HoldsAt(LyingOn(agent,physobj),time) ->
% Terminates(RiseFrom(agent,physobj),
%            LyingOn(agent,physobj),
%            time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3313).
holds_at(lyingOn(Agent, Physobj), Time) ->
    terminates_at(riseFrom(Agent, Physobj),
                  lyingOn(Agent, Physobj),
                  Time).


% [agent,physobj,time]
% HoldsAt(SittingOn(agent,physobj),time) ->
% Terminates(RiseFrom(agent,physobj),
%            SittingOn(agent,physobj),
%            time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3319).
holds_at(sittingOn(Agent, Physobj), Time) ->
    terminates_at(riseFrom(Agent, Physobj),
                  sittingOn(Agent, Physobj),
                  Time).

% event Greet(agent,agent)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3323).
event(greet(agent,agent)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3326).
% event SayGoodbye(agent,agent)
event(sayGoodbye(agent,agent)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3328).
% [agent1,agent2,time]
% Happens(Greet(agent1,agent2),time) ->
% {location}% 
% HoldsAt(At(agent1,location),time) &
% HoldsAt(At(agent2,location),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3330).
exists([Location],  (happens_at(greet(Agent1, Agent2), Time)->holds_at(at_loc(Agent1, Location), Time), holds_at(at_loc(Agent2, Location), Time))).


% [agent1,agent2,time]
% Happens(SayGoodbye(agent1,agent2),time) ->
% {location}% 
% HoldsAt(At(agent1,location),time) &
% HoldsAt(At(agent2,location),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3335).
exists([Location],  (happens_at(sayGoodbye(Agent1, Agent2), Time)->holds_at(at_loc(Agent1, Location), Time), holds_at(at_loc(Agent2, Location), Time))).

% event Order(agent,agent,physobj)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3339).
event(order(agent,agent,physobj)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3342).
% fluent KnowOrder(agent,agent,physobj)
fluent(knowOrder(agent,agent,physobj)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3344).
% [agent1,agent2,physobj,time]
% Initiates(Order(agent1,agent2,physobj),
%           KnowOrder(agent2,agent1,physobj),
%           time).
initiates_at(order(Agent1,Agent2,Physobj),
	     knowOrder(Agent2,Agent1,Physobj),
	     Time).


% [agent1,agent2,physobj,time]
% Happens(Order(agent1,agent2,physobj),time) ->
% {location}% 
% HoldsAt(At(agent1,location),time) &
% HoldsAt(At(agent2,location),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3350).
exists([Location],  (happens_at(order(Agent1, Agent2, Physobj), Time)->holds_at(at_loc(Agent1, Location), Time), holds_at(at_loc(Agent2, Location), Time))).

% event Request(agent,agent,physobj)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3354).
event(request(agent,agent,physobj)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3357).
% fluent KnowRequest(agent,agent,physobj)
fluent(knowRequest(agent,agent,physobj)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3359).
% [agent1,agent2,physobj,time]
% Initiates(Request(agent1,agent2,physobj),
%           KnowRequest(agent2,agent1,physobj),
%           time).
initiates_at(request(Agent1,Agent2,Physobj),
	     knowRequest(Agent2,Agent1,Physobj),
	     Time).


% [agent1,agent2,physobj,time]
% Happens(Request(agent1,agent2,physobj),time) ->
% {location}% 
% HoldsAt(At(agent1,location),time) &
% HoldsAt(At(agent2,location),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3365).
exists([Location],  (happens_at(request(Agent1, Agent2, Physobj), Time)->holds_at(at_loc(Agent1, Location), Time), holds_at(at_loc(Agent2, Location), Time))).


%; End of file.
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%; FILE: ecnet/Diving.e
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;
%; Copyright (c) 2005 IBM Corporation and others.
%; All rights reserved. This program and the accompanying materials
%; are made available under the terms of the Common Public License v1.0
%; which accompanies this distribution, and is available at
%; http://www.eclipse.org/legal/cpl-v10.html
%;
%; Contributors:
%; IBM - Initial implementation
%;
%; scuba diving
%;

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3391).
% sort object
sort(object).

% sort agent: object
subsort(agent,object).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3393).
% sort diver: agent
subsort(diver,agent).

% sort depth: integer
subsort(depth,integer).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3395).
% sort boat: object
subsort(boat,object).
%; reference line, anchor line, shotline, SMB line, ...

% sort line: object
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3397).
subsort(line,object).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3400).
% sort equipment: object
subsort(equipment,object).

% sort weight: equipment
subsort(weight,equipment).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3402).
% sort fin: equipment
subsort(fin,equipment).

% sort airtank: equipment
subsort(airtank,equipment).
%; buoyancy compensator (BC)
%; buoyancy control device (BCD)

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3407).
% sort computer: equipment
subsort(computer,equipment).

% sort bc: equipment
subsort(bc,equipment).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3410).
% fluent AtDepth(object,depth)
fluent(atDepth(object,depth)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3412).
% [object,depth1,depth2,time]
% HoldsAt(AtDepth(object,depth1),time) &
% HoldsAt(AtDepth(object,depth2),time) ->
% depth1 = depth2.
holds_at(atDepth(Object, Depth1), Time), holds_at(atDepth(Object, Depth2), Time) ->
    Depth1=Depth2.

% event Ascend(diver,depth)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3416).
event(ascend(diver,depth)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3419).
% event Descend(diver,depth)
event(descend(diver,depth)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3421).
% [diver,depth1,depth2,time]
% HoldsAt(AtDepth(diver,depth1),time) &
% Happens(Descend(diver,depth2),time) ->
% depth2>depth1.
holds_at(atDepth(Diver, Depth1), Time), happens_at(descend(Diver, Depth2), Time) ->
    Depth2>Depth1.


% [diver,depth1,depth2,time]
% HoldsAt(AtDepth(diver,depth1),time) &
% Happens(Ascend(diver,depth2),time) ->
% depth2<depth1.
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3427).
holds_at(atDepth(Diver, Depth1), Time), happens_at(ascend(Diver, Depth2), Time) ->
    Depth2<Depth1.


% [diver,depth,time]
% Initiates(Descend(diver,depth),AtDepth(diver,depth),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3432).
initiates_at(descend(Diver,Depth),
	     atDepth(Diver,Depth),
	     Time).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3434).
% [diver,depth1,depth2,time]
% HoldsAt(AtDepth(diver,depth1),time) ->
% Terminates(Descend(diver,depth2),AtDepth(diver,depth1),time).
holds_at(atDepth(Diver, Depth1), Time) ->
    terminates_at(descend(Diver, Depth2),
                  atDepth(Diver, Depth1),
                  Time).


% [diver,depth,time]
% Initiates(Ascend(diver,depth),AtDepth(diver,depth),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3439).
initiates_at(ascend(Diver,Depth),
	     atDepth(Diver,Depth),
	     Time).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3441).
% [diver,depth1,depth2,time]
% HoldsAt(AtDepth(diver,depth1),time) ->
% Terminates(Ascend(diver,depth2),AtDepth(diver,depth1),time).
holds_at(atDepth(Diver, Depth1), Time) ->
    terminates_at(ascend(Diver, Depth2),
                  atDepth(Diver, Depth1),
                  Time).

% fluent Wearing(diver,equipment)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3444).
fluent(wearing(diver,equipment)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3447).
% event PutOn(diver,equipment)
event(putOn(diver,equipment)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3449).
% event TakeOff(diver,equipment)
event(takeOff(diver,equipment)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3451).
% event Lose(diver,equipment)
event(lose(diver,equipment)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3453).
% [diver,equipment,depth,time]
% Releases(PutOn(diver,equipment),AtDepth(equipment,depth),time).
releases_at(putOn(Diver,Equipment),
	    atDepth(Equipment,Depth),
	    Time).


% [diver,equipment,time]
% Releases(PutOn(diver,equipment),UnderWater(equipment),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3457).
releases_at(putOn(Diver,Equipment),
	    underWater(Equipment),
	    Time).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3459).
% [diver,equipment,time]
% Happens(PutOn(diver,equipment),time) ->
% !{diver1} HoldsAt(Wearing(diver1,equipment),time).
happens_at(putOn(Diver, Equipment), Time) ->
    not(exists([Diver1],
               holds_at(wearing(Diver1, Equipment), Time))).


% [diver,depth,equipment,time]
% HoldsAt(Wearing(diver,equipment),time) ->
% (HoldsAt(AtDepth(diver,depth),time) <->
%  HoldsAt(AtDepth(equipment,depth),time)).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3464).
holds_at(wearing(Diver, Equipment), Time) ->
    <->(holds_at(atDepth(Diver, Depth), Time),
        holds_at(atDepth(Equipment, Depth), Time)).


% [diver,depth,object,time]
% HoldsAt(Holding(diver,object),time) ->
% (HoldsAt(AtDepth(diver,depth),time) <->
%  HoldsAt(AtDepth(object,depth),time)).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3469).
holds_at(holding(Diver, Object), Time) ->
    <->(holds_at(atDepth(Diver, Depth), Time),
        holds_at(atDepth(Object, Depth), Time)).


% [diver,equipment,time]
% HoldsAt(Wearing(diver,equipment),time) ->
% (HoldsAt(UnderWater(diver),time) <->
%  HoldsAt(UnderWater(equipment),time)).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3474).
holds_at(wearing(Diver, Equipment), Time) ->
    <->(holds_at(underWater(Diver), Time),
        holds_at(underWater(Equipment), Time)).


% [diver,object,time]
% HoldsAt(Holding(diver,object),time) ->
% (HoldsAt(UnderWater(diver),time) <->
%  HoldsAt(UnderWater(object),time)).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3479).
holds_at(holding(Diver, Object), Time) ->
    <->(holds_at(underWater(Diver), Time),
        holds_at(underWater(Object), Time)).


% [diver,depth,equipment,time]
% HoldsAt(AtDepth(diver,depth),time) &
% HoldsAt(Wearing(diver,equipment),time) ->
% Initiates(TakeOff(diver,equipment),AtDepth(equipment,depth),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3484).
holds_at(atDepth(Diver, Depth), Time), holds_at(wearing(Diver, Equipment), Time) ->
    initiates_at(takeOff(Diver, Equipment),
                 atDepth(Equipment, Depth),
                 Time).


% [diver,depth,equipment,time]
% !HoldsAt(AtDepth(diver,depth),time) &
% HoldsAt(Wearing(diver,equipment),time) ->
% Terminates(TakeOff(diver,equipment),AtDepth(equipment,depth),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3489).
holds_at(not(atDepth(Diver, Depth)), Time), holds_at(wearing(Diver, Equipment), Time) ->
    terminates_at(takeOff(Diver, Equipment),
                  atDepth(Equipment, Depth),
                  Time).


% [diver,equipment,time]
% HoldsAt(UnderWater(diver),time) ->
% Initiates(TakeOff(diver,equipment),UnderWater(equipment),time).
holds_at(underWater(Diver), Time) ->
    initiates_at(takeOff(Diver, Equipment),
                 underWater(Equipment),
                 Time).


% [diver,equipment,time]
% !HoldsAt(UnderWater(diver),time) ->
% Terminates(TakeOff(diver,equipment),UnderWater(equipment),time).
holds_at(not(underWater(Diver)), Time) ->
    terminates_at(takeOff(Diver, Equipment),
                  underWater(Equipment),
                  Time).


% [diver,equipment,depth,time]
% HoldsAt(AtDepth(diver,depth),time) &
% HoldsAt(Wearing(diver,equipment),time) ->
% Initiates(Lose(diver,equipment),AtDepth(equipment,depth),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3502).
holds_at(atDepth(Diver, Depth), Time), holds_at(wearing(Diver, Equipment), Time) ->
    initiates_at(lose(Diver, Equipment),
                 atDepth(Equipment, Depth),
                 Time).


% [diver,equipment,depth,time]
% !HoldsAt(AtDepth(diver,depth),time) &
% HoldsAt(Wearing(diver,equipment),time) ->
% Terminates(Lose(diver,equipment),AtDepth(equipment,depth),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3507).
holds_at(not(atDepth(Diver, Depth)), Time), holds_at(wearing(Diver, Equipment), Time) ->
    terminates_at(lose(Diver, Equipment),
                  atDepth(Equipment, Depth),
                  Time).


% [diver,equipment,time]
% HoldsAt(UnderWater(diver),time) ->
% Initiates(Lose(diver,equipment),UnderWater(equipment),time).
holds_at(underWater(Diver), Time) ->
    initiates_at(lose(Diver, Equipment),
                 underWater(Equipment),
                 Time).


% [diver,equipment,time]
% !HoldsAt(UnderWater(diver),time) ->
% Terminates(Lose(diver,equipment),UnderWater(equipment),time).
holds_at(not(underWater(Diver)), Time) ->
    terminates_at(lose(Diver, Equipment),
                  underWater(Equipment),
                  Time).

% fluent Holding(diver,object)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3518).
fluent(holding(diver,object)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3521).
% [diver1,diver2,time]
% HoldsAt(Holding(diver1,diver2),time) ->
% !HoldsAt(Holding(diver2,diver1),time).
holds_at(holding(Diver1, Diver2), Time) ->
    holds_at(not(holding(Diver2, Diver1)), Time).

% event Grab(diver,object)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3524).
event(grab(diver,object)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3527).
% event LetGoOf(diver,object)
event(letGoOf(diver,object)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3529).
% [diver,object,time]
% Initiates(Grab(diver,object),Holding(diver,object),time).
initiates_at(grab(Diver,Object),
	     holding(Diver,Object),
	     Time).


% [diver,object,time]
% Terminates(LetGoOf(diver,object),Holding(diver,object),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3533).
terminates_at(letGoOf(Diver,Object),
	      holding(Diver,Object),
	      Time).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3535).
% [diver,object,depth,time]
% Releases(Grab(diver,object),AtDepth(object,depth),time).
releases_at(grab(Diver,Object),
	    atDepth(Object,Depth),
	    Time).


% [diver,object,time]
% Releases(Grab(diver,object),UnderWater(object),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3539).
releases_at(grab(Diver,Object),
	    underWater(Object),
	    Time).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3541).
% [diver,object,depth,time]
% HoldsAt(AtDepth(diver,depth),time) &
% HoldsAt(Holding(diver,object),time) ->
% Initiates(LetGoOf(diver,object),AtDepth(object,depth),time).
holds_at(atDepth(Diver, Depth), Time), holds_at(holding(Diver, Object), Time) ->
    initiates_at(letGoOf(Diver, Object),
                 atDepth(Object, Depth),
                 Time).


% [diver,object,depth,time]
% !HoldsAt(AtDepth(diver,depth),time) &
% HoldsAt(Holding(diver,object),time) ->
% Terminates(LetGoOf(diver,object),AtDepth(object,depth),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3547).
holds_at(not(atDepth(Diver, Depth)), Time), holds_at(holding(Diver, Object), Time) ->
    terminates_at(letGoOf(Diver, Object),
                  atDepth(Object, Depth),
                  Time).


% [diver,object,time]
% HoldsAt(UnderWater(diver),time) ->
% Initiates(LetGoOf(diver,object),UnderWater(object),time).
holds_at(underWater(Diver), Time) ->
    initiates_at(letGoOf(Diver, Object),
                 underWater(Object),
                 Time).


% [diver,object,time]
% !HoldsAt(UnderWater(diver),time) ->
% Terminates(LetGoOf(diver,object),UnderWater(object),time).
holds_at(not(underWater(Diver)), Time) ->
    terminates_at(letGoOf(Diver, Object),
                  underWater(Object),
                  Time).


% [diver,equipment,time]
% Initiates(PutOn(diver,equipment),Wearing(diver,equipment),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3560).
initiates_at(putOn(Diver,Equipment),
	     wearing(Diver,Equipment),
	     Time).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3562).
% [diver,equipment,time]
% Happens(PutOn(diver,equipment),time) ->
% !HoldsAt(UnderWater(diver),time).
happens_at(putOn(Diver, Equipment), Time) ->
    holds_at(not(underWater(Diver)), Time).


% [diver,equipment,time]
% Terminates(TakeOff(diver,equipment),Wearing(diver,equipment),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3567).
terminates_at(takeOff(Diver,Equipment),
	      wearing(Diver,Equipment),
	      Time).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3569).
% [diver,equipment,time]
% Terminates(Lose(diver,equipment),Wearing(diver,equipment),time).
terminates_at(lose(Diver,Equipment),
	      wearing(Diver,Equipment),
	      Time).

% fluent Vertical(diver)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3571).
fluent(vertical(diver)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3574).
% fluent HorizontalDown(diver)
fluent(horizontalDown(diver)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3576).
% fluent Inverted(diver)
fluent(inverted(diver)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3578).
% fluent HorizontalUp(diver)
fluent(horizontalUp(diver)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3580).
% xor Vertical, HorizontalDown, Inverted, HorizontalUp
xor([vertical,horizontalDown,inverted,horizontalUp]).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3582).
% event RotatePitch(diver)
event(rotatePitch(diver)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3584).
% [diver,time]
% HoldsAt(Vertical(diver),time) ->
% Initiates(RotatePitch(diver),HorizontalDown(diver),time).
holds_at(vertical(Diver), Time) ->
    initiates_at(rotatePitch(Diver),
                 horizontalDown(Diver),
                 Time).


% [diver,time]
% HoldsAt(HorizontalDown(diver),time) ->
% Initiates(RotatePitch(diver),Inverted(diver),time).
holds_at(horizontalDown(Diver), Time) ->
    initiates_at(rotatePitch(Diver), inverted(Diver), Time).


% [diver,time]
% HoldsAt(HorizontalDown(diver),time) ->
% Terminates(RotatePitch(diver),HorizontalDown(diver),time).
holds_at(horizontalDown(Diver), Time) ->
    terminates_at(rotatePitch(Diver),
                  horizontalDown(Diver),
                  Time).


% [diver,time]
% HoldsAt(Inverted(diver),time) ->
% Initiates(RotatePitch(diver),HorizontalUp(diver),time).
holds_at(inverted(Diver), Time) ->
    initiates_at(rotatePitch(Diver),
                 horizontalUp(Diver),
                 Time).


% [diver,time]
% HoldsAt(Inverted(diver),time) ->
% Terminates(RotatePitch(diver),Inverted(diver),time).
holds_at(inverted(Diver), Time) ->
    terminates_at(rotatePitch(Diver), inverted(Diver), Time).


% [diver,time]
% HoldsAt(HorizontalUp(diver),time) ->
% Initiates(RotatePitch(diver),Vertical(diver),time).
holds_at(horizontalUp(Diver), Time) ->
    initiates_at(rotatePitch(Diver), vertical(Diver), Time).


% [diver,time]
% HoldsAt(HorizontalUp(diver),time) ->
% Terminates(RotatePitch(diver),HorizontalUp(diver),time).
holds_at(horizontalUp(Diver), Time) ->
    terminates_at(rotatePitch(Diver),
                  horizontalUp(Diver),
                  Time).

% event RotateYaw(diver)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3611).
event(rotateYaw(diver)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3614).
%; try taking out Holding condition here
% [diver,time]
% Happens(Ascend1(diver),time) &
% !Happens(RapidAscendToSurface(diver),time) &
% !({diver1} HoldsAt(Holding(diver,diver1),time)) ->
% Happens(RotateYaw(diver),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3616).
happens_at(ascend1(Diver), Time), not(happens_at(rapidAscendToSurface(Diver), Time)), not(exists([Diver1], holds_at(holding(Diver, Diver1), Time))) ->
    happens_at(rotateYaw(Diver), Time).

% fluent UnderWater(object)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3620).
fluent(underWater(object)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3623).
% [object,depth,time]
% depth>% 0 &
% HoldsAt(AtDepth(object,depth),time) ->
% HoldsAt(UnderWater(object),time).
Depth>0, holds_at(atDepth(Object, Depth), Time) ->
    holds_at(underWater(Object), Time).

% event EnterWater(object)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3627).
event(enterWater(object)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3630).
% event Surface(object)
event(surface(object)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3632).
% [object,time]
% Initiates(EnterWater(object),UnderWater(object),time).
initiates_at(enterWater(Object),
	     underWater(Object),
	     Time).


% [diver,time]
% Happens(EnterWater(diver),time) ->
% !{diver1} HoldsAt(Holding(diver1,diver),time).
happens_at(enterWater(Diver), Time) ->
    not(exists([Diver1],
               holds_at(holding(Diver1, Diver), Time))).


% [object,depth,time]
% depth=% 0 ->
% Initiates(EnterWater(object),AtDepth(object,depth),time).
Depth=0 ->
    initiates_at(enterWater(Object),
                 atDepth(Object, Depth),
                 Time).


% [object,time]
% Terminates(Surface(object),UnderWater(object),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3644).
terminates_at(surface(Object),
	      underWater(Object),
	      Time).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3646).
% [diver,time]
% Terminates(Surface(diver),PositivelyBuoyant(diver),time).
terminates_at(surface(Diver),
	      positivelyBuoyant(Diver),
	      Time).


% [diver,time]
% Terminates(Surface(diver),NegativelyBuoyant(diver),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3650).
terminates_at(surface(Diver),
	      negativelyBuoyant(Diver),
	      Time).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3652).
% [diver,time]
% Terminates(Surface(diver),NeutrallyBuoyant(diver),time).
terminates_at(surface(Diver),
	      neutrallyBuoyant(Diver),
	      Time).


% [object,depth,time]
% Terminates(Surface(object),AtDepth(object,depth),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3656).
terminates_at(surface(Object),
	      atDepth(Object,Depth),
	      Time).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3658).
% [diver,time]
 % Happens(EnterWater(diver),time) ->
% HoldsAt(Vertical(diver),time).
happens_at(enterWater(Diver), Time) ->
    holds_at(vertical(Diver), Time).

% fluent StandingOn(diver,boat)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3660).
fluent(standingOn(diver,boat)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3663).
% event StandOn(diver,boat)
event(standOn(diver,boat)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3665).
% [diver,boat,time]
% Terminates(EnterWater(diver),StandingOn(diver,boat),time).
terminates_at(enterWater(Diver),
	      standingOn(Diver,Boat),
	      Time).


% [diver,boat,time]
% Initiates(StandOn(diver,boat),StandingOn(diver,boat),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3669).
initiates_at(standOn(Diver,Boat),
	     standingOn(Diver,Boat),
	     Time).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3671).
% fluent PositivelyBuoyant(diver)
fluent(positivelyBuoyant(diver)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3673).
% fluent NeutrallyBuoyant(diver)
fluent(neutrallyBuoyant(diver)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3675).
% fluent NegativelyBuoyant(diver)
fluent(negativelyBuoyant(diver)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3677).
% mutex PositivelyBuoyant, NeutrallyBuoyant, NegativelyBuoyant
:- call_pel_directive(mutex(positivelyBuoyant)).
:- call_pel_directive(mutex(neutrallyBuoyant)).
:- call_pel_directive(mutex(negativelyBuoyant)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3679).
% [diver,time]
% HoldsAt(PositivelyBuoyant(diver),time) ->
% HoldsAt(UnderWater(diver),time).
holds_at(positivelyBuoyant(Diver), Time) ->
    holds_at(underWater(Diver), Time).


% [diver,time]
% HoldsAt(NeutrallyBuoyant(diver),time) ->
% HoldsAt(UnderWater(diver),time).
holds_at(neutrallyBuoyant(Diver), Time) ->
    holds_at(underWater(Diver), Time).


% [diver,time]
% HoldsAt(NegativelyBuoyant(diver),time) ->
% HoldsAt(UnderWater(diver),time).
holds_at(negativelyBuoyant(Diver), Time) ->
    holds_at(underWater(Diver), Time).

% event PressDeflateButton(diver,bc)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3690).
event(pressDeflateButton(diver,bc)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3693).
% event PressDumpButton(diver,bc)
event(pressDumpButton(diver,bc)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3695).
% event PressInflateButton(diver,bc)
event(pressInflateButton(diver,bc)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3697).
% [diver,bc,time]
% Happens(PressDeflateButton(diver,bc),time) ->
% HoldsAt(Vertical(diver),time) &
% HoldsAt(UnderWater(bc),time).
happens_at(pressDeflateButton(Diver, Bc), Time) ->
    holds_at(vertical(Diver), Time),
    holds_at(underWater(Bc), Time).


% [diver,bc,time]
% Happens(PressDumpButton(diver,bc),time) ->
% HoldsAt(Vertical(diver),time) &
% HoldsAt(UnderWater(bc),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3703).
happens_at(pressDumpButton(Diver, Bc), Time) ->
    holds_at(vertical(Diver), Time),
    holds_at(underWater(Bc), Time).


% [diver,bc,time]
 % Happens(PressDumpButton(diver,bc),time) ->
% HoldsAt(UncontrolledBuoyancy(diver),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3706).
happens_at(pressDumpButton(Diver, Bc), Time) ->
    holds_at(uncontrolledBuoyancy(Diver), Time).


% [diver,bc,time]
% HoldsAt(Wearing(diver,bc),time) ->
% Initiates(PressDeflateButton(diver,bc),NegativelyBuoyant(diver),time).
holds_at(wearing(Diver, Bc), Time) ->
    initiates_at(pressDeflateButton(Diver, Bc),
                 negativelyBuoyant(Diver),
                 Time).


% [diver,bc,time]
% HoldsAt(Wearing(diver,bc),time) ->
% Terminates(PressDeflateButton(diver,bc),NeutrallyBuoyant(diver),time).
holds_at(wearing(Diver, Bc), Time) ->
    terminates_at(pressDeflateButton(Diver, Bc),
                  neutrallyBuoyant(Diver),
                  Time).


% [diver,bc,time]
% HoldsAt(Wearing(diver,bc),time) ->
% Terminates(PressDeflateButton(diver,bc),PositivelyBuoyant(diver),time).
holds_at(wearing(Diver, Bc), Time) ->
    terminates_at(pressDeflateButton(Diver, Bc),
                  positivelyBuoyant(Diver),
                  Time).


% [diver,bc,time]
% HoldsAt(Wearing(diver,bc),time) ->
% Initiates(PressDumpButton(diver,bc),NegativelyBuoyant(diver),time).
holds_at(wearing(Diver, Bc), Time) ->
    initiates_at(pressDumpButton(Diver, Bc),
                 negativelyBuoyant(Diver),
                 Time).


% [diver,bc,time]
% HoldsAt(Wearing(diver,bc),time) ->
% Terminates(PressDumpButton(diver,bc),NeutrallyBuoyant(diver),time).
holds_at(wearing(Diver, Bc), Time) ->
    terminates_at(pressDumpButton(Diver, Bc),
                  neutrallyBuoyant(Diver),
                  Time).


% [diver,bc,time]
% HoldsAt(Wearing(diver,bc),time) ->
% Terminates(PressDumpButton(diver,bc),PositivelyBuoyant(diver),time).
holds_at(wearing(Diver, Bc), Time) ->
    terminates_at(pressDumpButton(Diver, Bc),
                  positivelyBuoyant(Diver),
                  Time).


% [diver,bc,time]
% HoldsAt(Wearing(diver,bc),time) ->
% Initiates(PressInflateButton(diver,bc),NeutrallyBuoyant(diver),time).
holds_at(wearing(Diver, Bc), Time) ->
    initiates_at(pressInflateButton(Diver, Bc),
                 neutrallyBuoyant(Diver),
                 Time).


% [diver,bc,time]
% HoldsAt(Wearing(diver,bc),time) ->
% Terminates(PressInflateButton(diver,bc),PositivelyBuoyant(diver),time).
holds_at(wearing(Diver, Bc), Time) ->
    terminates_at(pressInflateButton(Diver, Bc),
                  positivelyBuoyant(Diver),
                  Time).


% [diver,bc,time]
% HoldsAt(Wearing(diver,bc),time) ->
% Terminates(PressInflateButton(diver,bc),NegativelyBuoyant(diver),time).
holds_at(wearing(Diver, Bc), Time) ->
    terminates_at(pressInflateButton(Diver, Bc),
                  negativelyBuoyant(Diver),
                  Time).


% [diver,weight,time]
% HoldsAt(Wearing(diver,weight),time) ->
% Initiates(TakeOff(diver,weight),PositivelyBuoyant(diver),time).
holds_at(wearing(Diver, Weight), Time) ->
    initiates_at(takeOff(Diver, Weight),
                 positivelyBuoyant(Diver),
                 Time).


% [diver,weight,time]
% HoldsAt(Wearing(diver,weight),time) ->
% Terminates(TakeOff(diver,weight),NegativelyBuoyant(diver),time).
holds_at(wearing(Diver, Weight), Time) ->
    terminates_at(takeOff(Diver, Weight),
                  negativelyBuoyant(Diver),
                  Time).


% [diver,weight,time]
% HoldsAt(Wearing(diver,weight),time) ->
% Terminates(TakeOff(diver,weight),NeutrallyBuoyant(diver),time).
holds_at(wearing(Diver, Weight), Time) ->
    terminates_at(takeOff(Diver, Weight),
                  neutrallyBuoyant(Diver),
                  Time).

% fluent UncontrolledBuoyancy(diver)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3757).
fluent(uncontrolledBuoyancy(diver)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3760).
% event LoseBuoyancyControl(diver)
event(loseBuoyancyControl(diver)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3762).
% predicate IsInexperiencedDiver(diver)
predicate(isInexperiencedDiver(diver)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3764).
% [diver,time]
% Happens(LoseBuoyancyControl(diver),time) ->
% IsInexperiencedDiver(diver).
happens_at(loseBuoyancyControl(Diver), Time) ->
    isInexperiencedDiver(Diver).


% [diver,time]
% Initiates(LoseBuoyancyControl(diver),UncontrolledBuoyancy(diver),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3769).
initiates_at(loseBuoyancyControl(Diver),
	     uncontrolledBuoyancy(Diver),
	     Time).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3771).
% [diver,time]
% Initiates(LoseBuoyancyControl(diver),PositivelyBuoyant(diver),time).
initiates_at(loseBuoyancyControl(Diver),
	     positivelyBuoyant(Diver),
	     Time).


% [diver,time]
% Terminates(LoseBuoyancyControl(diver),NegativelyBuoyant(diver),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3775).
terminates_at(loseBuoyancyControl(Diver),
	      negativelyBuoyant(Diver),
	      Time).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3777).
% [diver,time]
% Terminates(LoseBuoyancyControl(diver),NeutrallyBuoyant(diver),time).
terminates_at(loseBuoyancyControl(Diver),
	      neutrallyBuoyant(Diver),
	      Time).


%; determining fluent

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3781).
% fluent AscendDescendAmount(diver,depth)
fluent(ascendDescendAmount(diver,depth)).

% noninertial AscendDescendAmount
:- call_pel_directive(noninertial(ascendDescendAmount)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3784).
% [diver,depth1,depth2,time]
% HoldsAt(AscendDescendAmount(diver,depth1),time) &
% HoldsAt(AscendDescendAmount(diver,depth2),time) ->
% depth1=depth2.
holds_at(ascendDescendAmount(Diver, Depth1), Time), holds_at(ascendDescendAmount(Diver, Depth2), Time) ->
    Depth1=Depth2.


% [diver,depth,time]
% Happens(Descend(diver,depth),time) ->
% HoldsAt(NegativelyBuoyant(diver),time) &
% ({depth1}
%  HoldsAt(AscendDescendAmount(diver,depth1),time) &
%  HoldsAt(AtDepth(diver,depth-depth1),time)).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3790).
happens_at(descend(Diver, Depth), Time) ->
    holds_at(negativelyBuoyant(Diver), Time),
    exists([Depth1],
            (holds_at(ascendDescendAmount(Diver, Depth1), Time), holds_at(atDepth(Diver, Depth-Depth1), Time))).

% event KickUp(diver)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3795).
event(kickUp(diver)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3798).
% [diver,depth,time]
% Happens(Ascend(diver,depth),time) ->
% (HoldsAt(PositivelyBuoyant(diver),time) |
%  (HoldsAt(NeutrallyBuoyant(diver),time) & Happens(KickUp(diver),time))) &
% ({depth1}
%  HoldsAt(AscendDescendAmount(diver,depth1),time) &
%  HoldsAt(AtDepth(diver,depth+depth1),time)).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3798).
happens_at(ascend(Diver, Depth), Time) ->
    (   holds_at(positivelyBuoyant(Diver), Time)
    ;   holds_at(neutrallyBuoyant(Diver), Time),
        happens_at(kickUp(Diver), Time)
    ),
    exists([Depth1],
            (holds_at(ascendDescendAmount(Diver, Depth1), Time), holds_at(atDepth(Diver, Depth+Depth1), Time))).


% [diver,time]
% Happens(KickUp(diver),time) ->
% HoldsAt(Vertical(diver),time).
happens_at(kickUp(Diver), Time) ->
    holds_at(vertical(Diver), Time).

% event SwimAround(diver)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3809).
event(swimAround(diver)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3812).
% [diver,time]
% Happens(SwimAround(diver),time) ->
% HoldsAt(HorizontalDown(diver),time).
happens_at(swimAround(Diver), Time) ->
    holds_at(horizontalDown(Diver), Time).


%; signaling

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3818).
% event SignalDescend(diver,diver)
event(signalDescend(diver,diver)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3820).
% event SignalOutOfTime(diver,diver)
event(signalOutOfTime(diver,diver)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3822).
% event SignalAscend(diver,diver)
event(signalAscend(diver,diver)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3824).
%;[diver1,diver2,time]
%;Happens(SignalAscend(diver1,diver2),time) ->
%;Happens(SignalOutOfTime(diver1,diver2),time-1).
%;[diver1,diver2,time]
%;Happens(SignalDescend(diver1,diver2),time) ->
%;HoldsAt(See(diver1,diver2),time) &
%;HoldsAt(See(diver2,diver1),time).
%;[diver1,diver2,time]
%;Happens(SignalOutOfTime(diver1,diver2),time) ->
%;HoldsAt(See(diver1,diver2),time) &
%;HoldsAt(See(diver2,diver1),time).
%;[diver1,diver2,time]
%;Happens(SignalAscend(diver1,diver2),time) ->
%;HoldsAt(See(diver1,diver2),time) &
%;HoldsAt(See(diver2,diver1),time).
%;event LookAt(agent,object)
%;fluent See(agent,object)
%;[agent,object,time]
%;Initiates(LookAt(agent,object),See(agent,object),time).
%;[agent,object1,object2,time]
%;object1!=object2 ->
%;Terminates(LookAt(agent,object1),
%;           See(agent,object2),
%;           time).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3856).
% event Descend1(diver)
event(descend1(diver)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3858).
% event Ascend1(diver)
event(ascend1(diver)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3860).
%;[diver,object,time]
%;Terminates(Descend1(diver),See(diver,object),time).
%;[diver,object,time]
%;Terminates(Ascend1(diver),See(diver,object),time).
%;[diver,object,time]
%;Terminates(RotateYaw(diver),See(diver,object),time).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3869).
% event RapidAscendToSurface(diver)
event(rapidAscendToSurface(diver)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3871).
% [diver,time]
% Happens(Descend1(diver),time) <->
% ({depth} Happens(Descend(diver,depth),time)).
happens_at(descend1(Diver), Time) <->
    exists([Depth],
           happens_at(descend(Diver, Depth), Time)).


% [diver,time]
% Happens(Ascend1(diver),time) <->
% ({depth} Happens(Ascend(diver,depth),time)).
happens_at(ascend1(Diver), Time) <->
    exists([Depth],
           happens_at(ascend(Diver, Depth), Time)).


% [diver,time]
% Happens(RapidAscendToSurface(diver),time) ->
% Happens(Ascend(diver,0),time).
happens_at(rapidAscendToSurface(Diver), Time) ->
    happens_at(ascend(Diver, 0), Time).

% event AscendLine(diver,line)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3882).
event(ascendLine(diver,line)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3885).
% [diver,line,time]
% Happens(AscendLine(diver,line),time) ->
% Happens(Ascend1(diver),time).
happens_at(ascendLine(Diver, Line), Time) ->
    happens_at(ascend1(Diver), Time).

% fluent Disoriented(diver)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3888).
fluent(disoriented(diver)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3891).
% event BecomeDisoriented(diver)
event(becomeDisoriented(diver)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3893).
% event BecomeReoriented(diver)
event(becomeReoriented(diver)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3895).
% [diver,time]
% Initiates(BecomeDisoriented(diver),Disoriented(diver),time).
initiates_at(becomeDisoriented(Diver),
	     disoriented(Diver),
	     Time).


% [diver,time]
% Terminates(BecomeReoriented(diver),Disoriented(diver),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3899).
terminates_at(becomeReoriented(Diver),
	      disoriented(Diver),
	      Time).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3901).
% fluent DisturbedSilt()
fluent(disturbedSilt()).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3903).
% event DisturbSilt(diver)
event(disturbSilt(diver)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3905).
% [diver,time]
% Initiates(DisturbSilt(diver),DisturbedSilt(),time).
initiates_at(disturbSilt(Diver),disturbedSilt(),Time).


% [diver,time]
% Happens(BecomeDisoriented(diver),time) ->
% (!HoldsAt(DisturbedSilt(),time-1) &
%  HoldsAt(DisturbedSilt(),time)).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3909).
happens_at(becomeDisoriented(Diver), Time) ->
    holds_at(not(disturbedSilt()), Time-1),
    holds_at(disturbedSilt(), Time).

% event Panic(diver)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3912).
event(panic(diver)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3915).
% [diver,time]
 % Happens(Panic(diver),time) ->
% HoldsAt(Disoriented(diver),time) |
% HoldsAt(UncontrolledBuoyancy(diver),time) |
% ({equipment} Happens(Lose(diver,equipment),time-1)) |
% Happens(Vomit(diver),time-1).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3915).
happens_at(panic(Diver), Time) ->
    (   holds_at(disoriented(Diver), Time)
    ;   holds_at(uncontrolledBuoyancy(Diver), Time)
    ;   exists([Equipment],
               happens_at(lose(Diver, Equipment), Time-1))
    ;   happens_at(vomit(Diver), Time-1)
    ).

% event Vomit(diver)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3920).
event(vomit(diver)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3923).
%; conditions

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3925).
% fluent Unconscious(diver)
fluent(unconscious(diver)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3927).
% event GoUnconscious(diver)
event(goUnconscious(diver)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3929).
% event RegainConsciousness(diver)
event(regainConsciousness(diver)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3931).
% [diver,time]
% Initiates(GoUnconscious(diver),Unconscious(diver),time).
initiates_at(goUnconscious(Diver),
	     unconscious(Diver),
	     Time).


% [diver,time]
% Terminates(RegainConsciousness(diver),Unconscious(diver),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3935).
terminates_at(regainConsciousness(Diver),
	      unconscious(Diver),
	      Time).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3937).
% [diver,time]
% Happens(GoUnconscious(diver),time) ->
% Happens(RapidAscendToSurface(diver),time).
happens_at(goUnconscious(Diver), Time) ->
    happens_at(rapidAscendToSurface(Diver), Time).

% fluent HasEarPain(diver)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3940).
fluent(hasEarPain(diver)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3943).
% event StartEarPain(diver)
event(startEarPain(diver)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3945).
% [diver,time]
 % Initiates(StartEarPain(diver),HasEarPain(diver),time).
initiates_at(startEarPain(Diver),
	     hasEarPain(Diver),
	     Time).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3947).
% fluent HasRupturedEardrum(diver)
fluent(hasRupturedEardrum(diver)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3949).
% event RuptureEardrum(diver)
event(ruptureEardrum(diver)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3951).
% [diver,time]
% Initiates(RuptureEardrum(diver),HasRupturedEardrum(diver),time).
initiates_at(ruptureEardrum(Diver),
	     hasRupturedEardrum(Diver),
	     Time).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3953).
% fluent ConditionOK(diver)
fluent(conditionOK(diver)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3955).
% fluent HasDecompressionIllness(diver)
fluent(hasDecompressionIllness(diver)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3957).
% event StartDecompressionIllness(diver)
event(startDecompressionIllness(diver)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3959).
% [diver,time]
% Initiates(StartDecompressionIllness(diver),
%           HasDecompressionIllness(diver),
%           time).
initiates_at(startDecompressionIllness(Diver),
	     hasDecompressionIllness(Diver),
	     Time).

% fluent SignalingDecompress(computer,diver)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3963).
fluent(signalingDecompress(computer,diver)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3966).
% fluent SignalingLowOnAir(computer,airtank,diver)
fluent(signalingLowOnAir(computer,airtank,diver)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3968).
% [computer,airtank,diver,time]
% HoldsAt(SignalingLowOnAir(computer,airtank,diver),time) ->
% HoldsAt(LowOnAir(airtank),time).
holds_at(signalingLowOnAir(Computer, Airtank, Diver), Time) ->
    holds_at(lowOnAir(Airtank), Time).


% [computer,diver,time]
% HoldsAt(SignalingDecompress(computer,diver),time) ->
% !{time1} time1<time & Happens(Decompress(diver),time1).
holds_at(signalingDecompress(Computer, Diver), Time) ->
    not(exists([Time1],
                (Time1<Time, happens_at(decompress(Diver), Time1)))).

% event Decompress(diver)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3975).
event(decompress(diver)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3978).
% event EqualizeEars(diver)
event(equalizeEars(diver)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3980).
% [diver,time]
% (Happens(Descend1(diver),time) | Happens(Ascend1(diver),time)) &
% !Happens(EqualizeEars(diver),time) ->
% Happens(StartEarPain(diver),time) &
% Happens(RuptureEardrum(diver),time).
(happens_at(descend1(Diver), Time);happens_at(ascend1(Diver), Time)), not(happens_at(equalizeEars(Diver), Time)) ->
    happens_at(startEarPain(Diver), Time),
    happens_at(ruptureEardrum(Diver), Time).


% [diver,time]
% Happens(Ascend1(diver),time) &
% !Happens(Decompress(diver),time) ->
% Happens(StartDecompressionIllness(diver),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3987).
happens_at(ascend1(Diver), Time), not(happens_at(decompress(Diver), Time)) ->
    happens_at(startDecompressionIllness(Diver), Time).


% [diver1,diver2,time]
% HoldsAt(Holding(diver1,diver2),time) &
% Happens(Ascend1(diver1),time) &
% !Happens(Decompress(diver2),time) ->
% Happens(StartDecompressionIllness(diver2),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3992).
holds_at(holding(Diver1, Diver2), Time), happens_at(ascend1(Diver1), Time), not(happens_at(decompress(Diver2), Time)) ->
    happens_at(startDecompressionIllness(Diver2), Time).


% [diver,time]
% Happens(Decompress(diver),time) ->
% ({depth} depth>0 & HoldsAt(AtDepth(diver,depth),time)) &
% !HoldsAt(UncontrolledBuoyancy(diver),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',3998).
happens_at(decompress(Diver), Time) ->
    exists([Depth],
            (Depth>0, holds_at(atDepth(Diver, Depth), Time))),
    holds_at(not(uncontrolledBuoyancy(Diver)), Time).

% fluent HasHeadache(diver)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4001).
fluent(hasHeadache(diver)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4004).
% [diver,time]
% HoldsAt(ConditionOK(diver),time) ->
% !HoldsAt(Unconscious(diver),time) &
% !HoldsAt(HasEarPain(diver),time) &
% !HoldsAt(HasRupturedEardrum(diver),time) &
% !HoldsAt(HasDecompressionIllness(diver),time) &
% !HoldsAt(HasHeadache(diver),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4004).
holds_at(conditionOK(Diver), Time) ->
    holds_at(not(unconscious(Diver)), Time),
    holds_at(not(hasEarPain(Diver)), Time),
    holds_at(not(hasRupturedEardrum(Diver)), Time),
    holds_at(not(hasDecompressionIllness(Diver)), Time),
    holds_at(not(hasHeadache(Diver)), Time).

% event BeAirlifted(diver)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4011).
event(beAirlifted(diver)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4014).
% event TakeInWater(diver)
event(takeInWater(diver)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4016).
% fluent LowOnAir(airtank)
fluent(lowOnAir(airtank)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4018).
% event BecomeLowOnAir(airtank)
event(becomeLowOnAir(airtank)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4020).
% [airtank,time]
% Initiates(BecomeLowOnAir(airtank),LowOnAir(airtank),time).
initiates_at(becomeLowOnAir(Airtank),
	     lowOnAir(Airtank),
	     Time).


%; initial state
% [diver]
 % HoldsAt(ConditionOK(diver),0).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4024).
holds_at(conditionOK(Diver),0).


% [diver]
 % HoldsAt(Vertical(diver),0).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4024).
holds_at(vertical(Diver),0).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4026).
% !HoldsAt(DisturbedSilt(),0).
holds_at(not(disturbedSilt()),0).


% [diver]
 % !HoldsAt(UncontrolledBuoyancy(diver),0).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4026).
holds_at(not(uncontrolledBuoyancy(Diver)),0).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4028).
% [diver]
 % !HoldsAt(Disoriented(diver),0).
holds_at(not(disoriented(Diver)),0).


% [diver]
 % !HoldsAt(PositivelyBuoyant(diver),0) &
%         !HoldsAt(NeutrallyBuoyant(diver),0) &
%         !HoldsAt(NegativelyBuoyant(diver),0).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4028).
holds_at(not(positivelyBuoyant(Diver)), 0),
holds_at(not(neutrallyBuoyant(Diver)), 0),
holds_at(not(negativelyBuoyant(Diver)), 0).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4032).
% [diver,object]
 % !HoldsAt(Wearing(diver,object),0).
holds_at(not(wearing(Diver,Object)),0).


% [diver,object]
 % !HoldsAt(Holding(diver,object),0).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4032).
holds_at(not(holding(Diver,Object)),0).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4034).
% [diver1,diver2]
 % !HoldsAt(Separated(diver1,diver2),0).
holds_at(not(separated(Diver1,Diver2)),0).


%;[agent,object] !HoldsAt(See(agent,object),0).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4037).
% fluent Separated(diver,diver)
fluent(separated(diver,diver)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4039).
% [diver1,diver2,time]
% HoldsAt(Separated(diver1,diver2),time) ->
% HoldsAt(Separated(diver2,diver1),time).
holds_at(separated(Diver1, Diver2), Time) ->
    holds_at(separated(Diver2, Diver1), Time).

% event BecomeSeparated(diver,diver)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4042).
event(becomeSeparated(diver,diver)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4045).
% event BeReunitedWith(diver,diver)
event(beReunitedWith(diver,diver)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4047).
% [diver1,diver2,time]
% Initiates(BecomeSeparated(diver1,diver2),Separated(diver1,diver2),time).
initiates_at(becomeSeparated(Diver1,Diver2),
	     separated(Diver1,Diver2),
	     Time).


% [diver1,diver2,time]
% Initiates(BecomeSeparated(diver1,diver2),Separated(diver2,diver1),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4051).
initiates_at(becomeSeparated(Diver1,Diver2),
	     separated(Diver2,Diver1),
	     Time).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4053).
% [diver1,diver2,time]
% Terminates(BeReunitedWith(diver1,diver2),Separated(diver1,diver2),time).
terminates_at(beReunitedWith(Diver1,Diver2),
	      separated(Diver1,Diver2),
	      Time).


% [diver1,diver2,time]
% Terminates(BeReunitedWith(diver1,diver2),Separated(diver2,diver1),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4057).
terminates_at(beReunitedWith(Diver1,Diver2),
	      separated(Diver2,Diver1),
	      Time).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4059).
%; End of file.
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%; FILE: ecnet/Dress.e
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;
%; Copyright (c) 2005 IBM Corporation and others.
%; All rights reserved. This program and the accompanying materials
%; are made available under the terms of the Common Public License v1.0
%; which accompanies this distribution, and is available at
%; http://www.eclipse.org/legal/cpl-v10.html
%;
%; Contributors:
%; IBM - Initial implementation
%;
%; Dress
%; (cf Sleep)
%;

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4081).
% event PutOn(agent,clothing)
event(putOn(agent,clothing)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4083).
% event TakeOff(agent,clothing)
event(takeOff(agent,clothing)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4085).
% fluent Wearing(agent,clothing)
fluent(wearing(agent,clothing)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4087).
% [agent,clothing,time]
% Initiates(PutOn(agent,clothing),
%           Wearing(agent,clothing),
%           time).
initiates_at(putOn(Agent,Clothing),
	     wearing(Agent,Clothing),
	     Time).


% [agent,clothing,time]
% Happens(PutOn(agent,clothing),time) ->
% !HoldsAt(Wearing(agent,clothing),time) &
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4093).
% {location}%  HoldsAt(At(agent,location),time) &
%            HoldsAt(At(clothing,location),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4095).
exists([Location],  (happens_at(putOn(Agent, Clothing), Time)->holds_at(not(wearing(Agent, Clothing)), Time), holds_at(at_loc(Agent, Location), Time), holds_at(at_loc(Clothing, Location), Time))).


% [agent,clothing,time]
% Terminates(TakeOff(agent,clothing),
%            Wearing(agent,clothing),
%            time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4099).
terminates_at(takeOff(Agent,Clothing),
	      wearing(Agent,Clothing),
	      Time).


% [agent,clothing,time]
% Happens(TakeOff(agent,clothing),time) ->
% HoldsAt(Wearing(agent,clothing),time).
happens_at(takeOff(Agent, Clothing), Time) ->
    holds_at(wearing(Agent, Clothing), Time).


% [agent,clothing,location,time]
% Releases(PutOn(agent,clothing),At(clothing,location),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4108).
releases_at(putOn(Agent,Clothing),
	    at_loc(Clothing,Location),
	    Time).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4110).
% [agent,clothing,location,time]
% HoldsAt(Wearing(agent,clothing),time) &
% HoldsAt(At(agent,location),time) ->
% HoldsAt(At(clothing,location),time).
holds_at(wearing(Agent, Clothing), Time), holds_at(at_loc(Agent, Location), Time) ->
    holds_at(at_loc(Clothing, Location), Time).


%;[agent,clothing,location1,location2,time]
%;HoldsAt(At(agent,location1),time) &
%;location1 != location2 ->
%;Terminates(TakeOff(agent,clothing),At(clothing,location2),time).
% [agent,clothing,location,time]
% HoldsAt(At(agent,location),time) ->
% Initiates(TakeOff(agent,clothing),At(clothing,location),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4120).
holds_at(at_loc(Agent, Location), Time) ->
    initiates_at(takeOff(Agent, Clothing),
                 at_loc(Clothing, Location),
                 Time).


%; End of file.
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%; FILE: ecnet/HungerNeed.e
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;
%; Copyright (c) 2005 IBM Corporation and others.
%; All rights reserved. This program and the accompanying materials
%; are made available under the terms of the Common Public License v1.0
%; which accompanies this distribution, and is available at
%; http://www.eclipse.org/legal/cpl-v10.html
%;
%; Contributors:
%; IBM - Initial implementation
%;
%; hunger need
%;

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4145).
% fluent Hungry(agent)
fluent(hungry(agent)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4147).
% fluent Satiated(agent)
fluent(satiated(agent)).

% noninertial Satiated
:- call_pel_directive(noninertial(satiated)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4150).
% [agent,time]
 % HoldsAt(Hungry(agent),time) <-> !HoldsAt(Satiated(agent),time).
holds_at(hungry(Agent), Time) <->
    holds_at(not(satiated(Agent)), Time).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4152).
% event Eat(agent,food)
event(eat(agent,food)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4154).
% [agent,food,time]
% Happens(Eat(agent,food),time) ->
% {location}% 
% HoldsAt(At(agent,location),time) &
% HoldsAt(At(food,location),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4156).
exists([Location],  (happens_at(eat(Agent, Food), Time)->holds_at(at_loc(Agent, Location), Time), holds_at(at_loc(Food, Location), Time))).


% [agent,food,time]
% Terminates(Eat(agent,food),Hungry(agent),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4161).
terminates_at(eat(Agent,Food),
	      hungry(Agent),
	      Time).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4163).
%; End of file.
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%; FILE: ecnet/Restaurant.e
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;
%; Copyright (c) 2005 IBM Corporation and others.
%; All rights reserved. This program and the accompanying materials
%; are made available under the terms of the Common Public License v1.0
%; which accompanies this distribution, and is available at
%; http://www.eclipse.org/legal/cpl-v10.html
%;
%; Contributors:
%; IBM - Initial implementation
%;

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4181).
% sort restaurant: script
subsort(restaurant,script).

% sort waiter: agent
subsort(waiter,agent).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4183).
% sort cook: agent
subsort(cook,agent).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4185).
% function BillOf(restaurant): bill
function(billOf(restaurant),bill).

% function CookOf(restaurant): cook
function(cookOf(restaurant),cook).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4187).
% function TableOf(restaurant): table
function(tableOf(restaurant),table).

% function WaiterOf(restaurant): waiter
function(waiterOf(restaurant),waiter).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4189).
% function KitchenDoorOf(restaurant): door
function(kitchenDoorOf(restaurant),door).
%; awaiting customer/waiter has set down bill on customer's table

% fluent BeWaiter0(waiter)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4191).
fluent(beWaiter0(waiter)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4194).
%; awaiting customer order

% fluent BeWaiter1(waiter)
fluent(beWaiter1(waiter)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4197).
%; has customer order

% fluent BeWaiter2(waiter)
fluent(beWaiter2(waiter)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4200).
%; in kitchen

% fluent BeWaiter3(waiter)
fluent(beWaiter3(waiter)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4203).
%; awaiting preparation of order

% fluent BeWaiter4(waiter)
fluent(beWaiter4(waiter)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4206).
%; has order

% fluent BeWaiter5(waiter)
fluent(beWaiter5(waiter)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4209).
%; back in dining room

% fluent BeWaiter6(waiter)
fluent(beWaiter6(waiter)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4212).
%; order delivered to customer (can ask if all is OK)

% fluent BeWaiter7(waiter)
fluent(beWaiter7(waiter)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4215).
%; customer has requested bill

% fluent BeWaiter8(waiter)
fluent(beWaiter8(waiter)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4218).
%; waiter is holding bill

% fluent BeWaiter9(waiter)
fluent(beWaiter9(waiter)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4221).
% xor BeWaiter0, BeWaiter1, BeWaiter2, BeWaiter3, BeWaiter4, BeWaiter5, BeWaiter6, BeWaiter7, BeWaiter8, BeWaiter9
xor([ beWaiter0,
      beWaiter1,
      beWaiter2,
      beWaiter3,
      beWaiter4,
      beWaiter5,
      beWaiter6,
      beWaiter7,
      beWaiter8,
      beWaiter9
    ]).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4223).
% [waiter,agent,time]
% HoldsAt(BeWaiter0(waiter),time) ->
% Terminates(Greet(waiter,agent),
%            BeWaiter0(waiter),
%            time).
holds_at(beWaiter0(Waiter), Time) ->
    terminates_at(greet(Waiter, Agent),
                  beWaiter0(Waiter),
                  Time).


% [waiter,agent,time]
% HoldsAt(BeWaiter0(waiter),time) ->
% Initiates(Greet(waiter,agent),
%           BeWaiter1(waiter),
%           time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4230).
holds_at(beWaiter0(Waiter), Time) ->
    initiates_at(greet(Waiter, Agent),
                 beWaiter1(Waiter),
                 Time).


% [waiter,agent,food,time]
% HoldsAt(BeWaiter1(waiter),time) ->
% Terminates(Order(agent,waiter,food),
%            BeWaiter1(waiter),
%            time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4236).
holds_at(beWaiter1(Waiter), Time) ->
    terminates_at(order(Agent, Waiter, Food),
                  beWaiter1(Waiter),
                  Time).


% [waiter,agent,food,time]
% HoldsAt(BeWaiter1(waiter),time) ->
% Initiates(Order(agent,waiter,food),
%           BeWaiter2(waiter),
%           time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4242).
holds_at(beWaiter1(Waiter), Time) ->
    initiates_at(order(Agent, Waiter, Food),
                 beWaiter2(Waiter),
                 Time).


% [restaurant,waiter,time]
% WaiterOf(restaurant)=waiter &
% HoldsAt(BeWaiter2(waiter),time) ->
% Happens(WalkThroughDoor12(waiter,KitchenDoorOf(restaurant)),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4248).
waiterOf(Restaurant)=Waiter, holds_at(beWaiter2(Waiter), Time) ->
    happens_at(walkThroughDoor12(Waiter, kitchenDoorOf(Restaurant)),
               Time).


% [restaurant,waiter,door,time]
% HoldsAt(BeWaiter2(waiter),time) &
% WaiterOf(restaurant)=waiter &
% KitchenDoorOf(restaurant)=door ->
% Terminates(WalkThroughDoor12(waiter,door),
%            BeWaiter2(waiter),
%            time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4253).
holds_at(beWaiter2(Waiter), Time), waiterOf(Restaurant)=Waiter, kitchenDoorOf(Restaurant)=Door ->
    terminates_at(walkThroughDoor12(Waiter, Door),
                  beWaiter2(Waiter),
                  Time).


% [restaurant,waiter,door,time]
% HoldsAt(BeWaiter2(waiter),time) &
% WaiterOf(restaurant)=waiter &
% KitchenDoorOf(restaurant)=door ->
% Initiates(WalkThroughDoor12(waiter,door),
%           BeWaiter3(waiter),
%           time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4261).
holds_at(beWaiter2(Waiter), Time), waiterOf(Restaurant)=Waiter, kitchenDoorOf(Restaurant)=Door ->
    initiates_at(walkThroughDoor12(Waiter, Door),
                 beWaiter3(Waiter),
                 Time).


% [restaurant,food,time]
% HoldsAt(BeWaiter3(WaiterOf(restaurant)),time) &
% ({agent} HoldsAt(KnowOrder(WaiterOf(restaurant),agent,food),time)) ->
% Happens(Order(WaiterOf(restaurant),CookOf(restaurant),food),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4269).
holds_at(beWaiter3(waiterOf(Restaurant)), Time), exists([Agent], holds_at(knowOrder(waiterOf(Restaurant), Agent, Food), Time)) ->
    happens_at(order(waiterOf(Restaurant),
                     cookOf(Restaurant),
                     Food),
               Time).


% [restaurant,waiter,cook,food,time]
% WaiterOf(restaurant)=waiter &
% CookOf(restaurant)=cook &
% HoldsAt(BeWaiter3(waiter),time) ->
% Terminates(Order(waiter,cook,food),
%            BeWaiter3(waiter),
%            time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4274).
waiterOf(Restaurant)=Waiter, cookOf(Restaurant)=Cook, holds_at(beWaiter3(Waiter), Time) ->
    terminates_at(order(Waiter, Cook, Food),
                  beWaiter3(Waiter),
                  Time).


% [restaurant,waiter,cook,food,time]
% WaiterOf(restaurant)=waiter &
% CookOf(restaurant)=cook &
% HoldsAt(BeWaiter3(waiter),time) ->
% Initiates(Order(waiter,cook,food),
%           BeWaiter4(waiter),
%           time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4282).
waiterOf(Restaurant)=Waiter, cookOf(Restaurant)=Cook, holds_at(beWaiter3(Waiter), Time) ->
    initiates_at(order(Waiter, Cook, Food),
                 beWaiter4(Waiter),
                 Time).


% [waiter,food,time]
% HoldsAt(BeWaiter4(waiter),time) &
% ({agent} HoldsAt(KnowOrder(waiter,agent,food),time)) &
% HoldsAt(FoodPrepared(food),time) ->
% Happens(PickUp(waiter,food),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4290).
holds_at(beWaiter4(Waiter), Time), exists([Agent], holds_at(knowOrder(Waiter, Agent, Food), Time)), holds_at(foodPrepared(Food), Time) ->
    happens_at(pickUp(Waiter, Food), Time).


% [waiter,food,time]
% HoldsAt(BeWaiter4(waiter),time) &
% ({agent} HoldsAt(KnowOrder(waiter,agent,food),time)) ->
% Terminates(PickUp(waiter,food),
%            BeWaiter4(waiter),
%            time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4296).
holds_at(beWaiter4(Waiter), Time), exists([Agent], holds_at(knowOrder(Waiter, Agent, Food), Time)) ->
    terminates_at(pickUp(Waiter, Food),
                  beWaiter4(Waiter),
                  Time).


% [waiter,food,time]
% HoldsAt(BeWaiter4(waiter),time) &
% ({agent} HoldsAt(KnowOrder(waiter,agent,food),time)) ->
% Initiates(PickUp(waiter,food),
%           BeWaiter5(waiter),
%           time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4303).
holds_at(beWaiter4(Waiter), Time), exists([Agent], holds_at(knowOrder(Waiter, Agent, Food), Time)) ->
    initiates_at(pickUp(Waiter, Food),
                 beWaiter5(Waiter),
                 Time).


% [restaurant,waiter,time]
% WaiterOf(restaurant)=waiter &
% HoldsAt(BeWaiter5(waiter),time) ->
% Happens(WalkThroughDoor21(waiter,KitchenDoorOf(restaurant)),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4310).
waiterOf(Restaurant)=Waiter, holds_at(beWaiter5(Waiter), Time) ->
    happens_at(walkThroughDoor21(Waiter, kitchenDoorOf(Restaurant)),
               Time).


% [restaurant,waiter,door,time]
% HoldsAt(BeWaiter5(waiter),time) &
% WaiterOf(restaurant)=waiter &
% KitchenDoorOf(restaurant)=door ->
% Terminates(WalkThroughDoor21(waiter,door),
%            BeWaiter5(waiter),
%            time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4315).
holds_at(beWaiter5(Waiter), Time), waiterOf(Restaurant)=Waiter, kitchenDoorOf(Restaurant)=Door ->
    terminates_at(walkThroughDoor21(Waiter, Door),
                  beWaiter5(Waiter),
                  Time).


% [restaurant,waiter,door,time]
% HoldsAt(BeWaiter5(waiter),time) &
% WaiterOf(restaurant)=waiter &
% KitchenDoorOf(restaurant)=door ->
% Initiates(WalkThroughDoor21(waiter,door),
%           BeWaiter6(waiter),
%           time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4323).
holds_at(beWaiter5(Waiter), Time), waiterOf(Restaurant)=Waiter, kitchenDoorOf(Restaurant)=Door ->
    initiates_at(walkThroughDoor21(Waiter, Door),
                 beWaiter6(Waiter),
                 Time).


% [restaurant,waiter,table,food,time]
% WaiterOf(restaurant)=waiter &
% TableOf(restaurant)=table &
% HoldsAt(BeWaiter6(waiter),time) &
% HoldsAt(Holding(waiter,food),time) ->
% Happens(PlaceOn(waiter,food,table),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4331).
waiterOf(Restaurant)=Waiter, tableOf(Restaurant)=Table, holds_at(beWaiter6(Waiter), Time), holds_at(holding(Waiter, Food), Time) ->
    happens_at(placeOn(Waiter, Food, Table), Time).


% [waiter,food,table,time]
% HoldsAt(BeWaiter6(waiter),time) ->
% Terminates(PlaceOn(waiter,food,table),
%            BeWaiter6(waiter),
%            time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4338).
holds_at(beWaiter6(Waiter), Time) ->
    terminates_at(placeOn(Waiter, Food, Table),
                  beWaiter6(Waiter),
                  Time).


% [waiter,food,table,time]
% HoldsAt(BeWaiter6(waiter),time) ->
% Initiates(PlaceOn(waiter,food,table),
%           BeWaiter7(waiter),
%           time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4344).
holds_at(beWaiter6(Waiter), Time) ->
    initiates_at(placeOn(Waiter, Food, Table),
                 beWaiter7(Waiter),
                 Time).


% [waiter,agent,bill,time]
% HoldsAt(BeWaiter7(waiter),time) ->
% Terminates(Request(agent,waiter,bill),
%            BeWaiter7(waiter),
%            time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4350).
holds_at(beWaiter7(Waiter), Time) ->
    terminates_at(request(Agent, Waiter, Bill),
                  beWaiter7(Waiter),
                  Time).


% [waiter,agent,bill,time]
% HoldsAt(BeWaiter7(waiter),time) ->
% Initiates(Request(agent,waiter,bill),
%           BeWaiter8(waiter),
%           time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4356).
holds_at(beWaiter7(Waiter), Time) ->
    initiates_at(request(Agent, Waiter, Bill),
                 beWaiter8(Waiter),
                 Time).


% [restaurant,waiter,bill,time]
% WaiterOf(restaurant)=waiter &
% BillOf(restaurant)=bill &
% HoldsAt(BeWaiter8(waiter),time) ->
% Happens(PickUp(waiter,bill),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4362).
waiterOf(Restaurant)=Waiter, billOf(Restaurant)=Bill, holds_at(beWaiter8(Waiter), Time) ->
    happens_at(pickUp(Waiter, Bill), Time).


% [waiter,bill,time]
% HoldsAt(BeWaiter8(waiter),time) ->
% Terminates(PickUp(waiter,bill),
%            BeWaiter8(waiter),
%            time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4368).
holds_at(beWaiter8(Waiter), Time) ->
    terminates_at(pickUp(Waiter, Bill),
                  beWaiter8(Waiter),
                  Time).


% [waiter,bill,time]
% HoldsAt(BeWaiter8(waiter),time) ->
% Initiates(PickUp(waiter,bill),
%           BeWaiter9(waiter),
%           time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4374).
holds_at(beWaiter8(Waiter), Time) ->
    initiates_at(pickUp(Waiter, Bill),
                 beWaiter9(Waiter),
                 Time).


% [restaurant,waiter,bill,table,time]
% WaiterOf(restaurant)=waiter &
% BillOf(restaurant)=bill &
% TableOf(restaurant)=table &
% HoldsAt(BeWaiter9(waiter),time) ->
% Happens(PlaceOn(waiter,bill,table),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4380).
waiterOf(Restaurant)=Waiter, billOf(Restaurant)=Bill, tableOf(Restaurant)=Table, holds_at(beWaiter9(Waiter), Time) ->
    happens_at(placeOn(Waiter, Bill, Table), Time).


% [waiter,bill,table,time]
% HoldsAt(BeWaiter9(waiter),time) ->
% Terminates(PlaceOn(waiter,bill,table),
%            BeWaiter9(waiter),
%            time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4387).
holds_at(beWaiter9(Waiter), Time) ->
    terminates_at(placeOn(Waiter, Bill, Table),
                  beWaiter9(Waiter),
                  Time).


% [waiter,bill,table,time]
% HoldsAt(BeWaiter9(waiter),time) ->
% Initiates(PlaceOn(waiter,bill,table),
%           BeWaiter0(waiter),
%           time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4393).
holds_at(beWaiter9(Waiter), Time) ->
    initiates_at(placeOn(Waiter, Bill, Table),
                 beWaiter0(Waiter),
                 Time).


%; awaiting next waiter order

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4399).
% fluent BeCook0(cook)
fluent(beCook0(cook)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4401).
%; waiter order received

% fluent BeCook1(cook)
fluent(beCook1(cook)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4404).
% xor BeCook0, BeCook1
xor([beCook0,beCook1]).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4406).
% [cook,agent,food,time]
% HoldsAt(BeCook0(cook),time) ->
% Terminates(Order(agent,cook,food),
%            BeCook0(cook),
%            time).
holds_at(beCook0(Cook), Time) ->
    terminates_at(order(Agent, Cook, Food),
                  beCook0(Cook),
                  Time).


% [cook,agent,food,time]
% HoldsAt(BeCook0(cook),time) ->
% Initiates(Order(agent,cook,food),
%           BeCook1(cook),
%           time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4413).
holds_at(beCook0(Cook), Time) ->
    initiates_at(order(Agent, Cook, Food),
                 beCook1(Cook),
                 Time).

% event FoodPrepare(agent,food)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4417).
event(foodPrepare(agent,food)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4420).
% fluent FoodPrepared(food)
fluent(foodPrepared(food)).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4422).
% [agent,food,time]
% Initiates(FoodPrepare(agent,food),
%           FoodPrepared(food),
%           time).
initiates_at(foodPrepare(Agent,Food),
	     foodPrepared(Food),
	     Time).


% [agent,food,time]
% Happens(FoodPrepare(agent,food),time) ->
% {location}% 
% HoldsAt(At(agent,location),time) &
% HoldsAt(At(food,location),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4428).
exists([Location],  (happens_at(foodPrepare(Agent, Food), Time)->holds_at(at_loc(Agent, Location), Time), holds_at(at_loc(Food, Location), Time))).


% [cook,agent,food,time]
% HoldsAt(BeCook1(cook),time) &
% HoldsAt(KnowOrder(cook,agent,food),time) ->
% Happens(FoodPrepare(cook,food),time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4434).
holds_at(beCook1(Cook), Time), holds_at(knowOrder(Cook, Agent, Food), Time) ->
    happens_at(foodPrepare(Cook, Food), Time).


% [cook,food,time]
% HoldsAt(BeCook1(cook),time) ->
% Terminates(FoodPrepare(cook,food),
%            BeCook1(cook),
%            time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4439).
holds_at(beCook1(Cook), Time) ->
    terminates_at(foodPrepare(Cook, Food),
                  beCook1(Cook),
                  Time).


% [cook,food,time]
% HoldsAt(BeCook1(cook),time) ->
% Initiates(FoodPrepare(cook,food),
%           BeCook0(cook),
%           time).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4445).
holds_at(beCook1(Cook), Time) ->
    initiates_at(foodPrepare(Cook, Food),
                 beCook0(Cook),
                 Time).


%; End of file.
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%; FILE: ecnet/EatingInAHouse.e
%; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;
%; Copyright (c) 2005 IBM Corporation and others.
%; All rights reserved. This program and the accompanying materials
%; are made available under the terms of the Common Public License v1.0
%; which accompanies this distribution, and is available at
%; http://www.eclipse.org/legal/cpl-v10.html
%;
%; Contributors:
%; IBM - Initial implementation
%;
%; @article{Mueller:2004c,
%;   author = "Erik T. Mueller",
%;   year = "2004",
%;   title = "Understanding script-based stories using commonsense reasoning",
%;   journal = "Cognitive Systems Research",
%;   volume = "5",
%;   number = "4",
%;   pages = "307--340",
%; }
%;

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4479).
% option modeldiff on
:- call_pel_directive(option(modeldiff, on)).

% option encoding 3
:- call_pel_directive(option(encoding, 3)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4481).
% option renaming off
:- call_pel_directive(option(renaming, off)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4483).
% ignore Love, ThreatenedBy
:- call_pel_directive(ignore(love)).
:- call_pel_directive(ignore(threatenedBy)).

% ignore LookOutOnto, Floor, BuildingOf, SkyOf, GroundOf
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4483).
:- call_pel_directive(ignore(lookOutOnto)).
:- call_pel_directive(ignore(floor)).
:- call_pel_directive(ignore(buildingOf)).
:- call_pel_directive(ignore(skyOf)).
:- call_pel_directive(ignore(groundOf)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4485).
% ignore Inside
:- call_pel_directive(ignore(inside)).

% ignore Near, WalkFrom, WalkFromTo, RunFromTo
:- call_pel_directive(ignore(near)).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4485).
:- call_pel_directive(ignore(walkFrom)).
:- call_pel_directive(ignore(walkFromTo)).
:- call_pel_directive(ignore(runFromTo)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4487).
% ignore BillOf, CookOf, TableOf, WaiterOf, KitchenDoorOf
:- call_pel_directive(ignore(billOf)).
:- call_pel_directive(ignore(cookOf)).
:- call_pel_directive(ignore(tableOf)).
:- call_pel_directive(ignore(waiterOf)).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4487).
:- call_pel_directive(ignore(kitchenDoorOf)).

% ignore BeWaiter0, BeWaiter1, BeWaiter2, BeWaiter3, BeWaiter4
:- call_pel_directive(ignore(beWaiter0)).
:- call_pel_directive(ignore(beWaiter1)).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4487).
:- call_pel_directive(ignore(beWaiter2)).
:- call_pel_directive(ignore(beWaiter3)).
:- call_pel_directive(ignore(beWaiter4)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4489).
% ignore BeWaiter5, BeWaiter6, BeWaiter7, BeWaiter8, BeWaiter9
:- call_pel_directive(ignore(beWaiter5)).
:- call_pel_directive(ignore(beWaiter6)).
:- call_pel_directive(ignore(beWaiter7)).
:- call_pel_directive(ignore(beWaiter8)).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4489).
:- call_pel_directive(ignore(beWaiter9)).

% ignore BeCook0, BeCook1
:- call_pel_directive(ignore(beCook0)).
:- call_pel_directive(ignore(beCook1)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4491).
% ignore InviteIn, InvitedIn, IntendToWalkIn, IntentionToWalkIn
:- call_pel_directive(ignore(inviteIn)).
:- call_pel_directive(ignore(invitedIn)).
:- call_pel_directive(ignore(intendToWalkIn)).
:- call_pel_directive(ignore(intentionToWalkIn)).

% ignore ActOnIntentionToWalkIn, Greet, SayGoodbye, CryForJoy
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4491).
:- call_pel_directive(ignore(actOnIntentionToWalkIn)).
:- call_pel_directive(ignore(greet)).
:- call_pel_directive(ignore(sayGoodbye)).
:- call_pel_directive(ignore(cryForJoy)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4493).
% ignore Threaten, ReleaseFromThreat, ThreatenedBy
:- call_pel_directive(ignore(threaten)).
:- call_pel_directive(ignore(releaseFromThreat)).
:- call_pel_directive(ignore(threatenedBy)).

% ignore Order, KnowOrder, Request, KnowRequest
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4493).
:- call_pel_directive(ignore(order)).
:- call_pel_directive(ignore(knowOrder)).
:- call_pel_directive(ignore(request)).
:- call_pel_directive(ignore(knowRequest)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4495).
% ignore PutInside, TakeOutOf
:- call_pel_directive(ignore(putInside)).
:- call_pel_directive(ignore(takeOutOf)).

% ignore SayPleaseToMeet, Move
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4495).
:- call_pel_directive(ignore(sayPleaseToMeet)).
:- call_pel_directive(ignore(move)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4498).
% load foundations/Root.e
:- call_pel_directive(load('foundations/Root.e')).

% load foundations/EC.e
:- call_pel_directive(load('foundations/EC.e')).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4500).
% load answers/Mueller2003/Ontology.e
:- call_pel_directive(load('answers/Mueller2003/Ontology.e')).

% load answers/Mueller2004c/RTSpaceM.e
:- call_pel_directive(load('answers/Mueller2004c/RTSpaceM.e')).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4502).
% load answers/Mueller2004c/OTSpaceM.e
:- call_pel_directive(load('answers/Mueller2004c/OTSpaceM.e')).

% load answers/Mueller2004c/HungerNeed.e
:- call_pel_directive(load('answers/Mueller2004c/HungerNeed.e')).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4504).
% load answers/Mueller2004c/Restaurant.e
:- call_pel_directive(load('answers/Mueller2004c/Restaurant.e')).

% load answers/Mueller2003/Sleep.e
:- call_pel_directive(load('answers/Mueller2003/Sleep.e')).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4506).
% load answers/Mueller2003/SpeechAct.e
:- call_pel_directive(load('answers/Mueller2003/SpeechAct.e')).

% load answers/Mueller2004c/Dress.e
:- call_pel_directive(load('answers/Mueller2004c/Dress.e')).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4509).
% room Upstairs1
t(room,upstairs1).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4511).
% staircase Staircase1
t(staircase,staircase1).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4513).
% room Hallway1
t(room,hallway1).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4515).
% Side1(Staircase1)=Hallway1.
side1(staircase1)=hallway1.


% Side2(Staircase1)=Upstairs1.
side2(staircase1)=upstairs1.

% door DiningRoomDoor1
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4517).
t(door,diningRoomDoor1).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4520).
% room DiningRoom1
t(room,diningRoom1).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4522).
% Side1(DiningRoomDoor1)=Hallway1.
side1(diningRoomDoor1)=hallway1.


% Side2(DiningRoomDoor1)=DiningRoom1.
side2(diningRoomDoor1)=diningRoom1.

% door KitchenDoor1
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4524).
t(door,kitchenDoor1).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4527).
% room Kitchen1
t(room,kitchen1).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4529).
% Side1(KitchenDoor1)=DiningRoom1.
side1(kitchenDoor1)=diningRoom1.


% Side2(KitchenDoor1)=Kitchen1.
side2(kitchenDoor1)=kitchen1.

% agent Eater1
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4531).
t(agent,eater1).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4534).
% agent Eater2
t(agent,eater2).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4536).
% clothing Clothing1
t(clothing,clothing1).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4538).
% clothing Clothing2
t(clothing,clothing2).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4540).
% chair Chair1
t(chair,chair1).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4542).
% chair Chair2
t(chair,chair2).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4544).
% food Food1
t(food,food1).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4546).
% agent Cook1
t(agent,cook1).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4548).
% table Table1
t(table,table1).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4550).
% content Content1
t(content,content1).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4552).
% content Content2
t(content,content2).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4554).
% outside DummyOutside1
t(outside,dummyOutside1).
%; prune

% sort ona, onb
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4556).
sort(ona).
sort(onb).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4558).
% fluent! On(ona,onb)
fluent(on(ona,onb)).

% event! PlaceOn(agent,ona,onb)
event(placeOn(agent,ona,onb)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4560).
% event! TakeOffOf(agent,ona,onb)
event(takeOffOf(agent,ona,onb)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4562).
% sort ordera, orderb, orderc
sort(ordera).
sort(orderb).
sort(orderc).

% event! Order(ordera,orderb,orderc)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4562).
event(order(ordera,orderb,orderc)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4564).
% fluent! KnowOrder(orderb,ordera,orderc)
fluent(knowOrder(orderb,ordera,orderc)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4566).
% sort requesta, requestb, requestc
sort(requesta).
sort(requestb).
sort(requestc).

% event! Request(requesta,requestb,requestc)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4566).
event(request(requesta,requestb,requestc)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4568).
% fluent! KnowRequest(requestb,requesta,requestc)
fluent(knowRequest(requestb,requesta,requestc)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4570).
% sort holda, holdb, holdc
sort(holda).
sort(holdb).
sort(holdc).

% event! TakeOffOf(holda,holdb,holdc)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4570).
event(takeOffOf(holda,holdb,holdc)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4572).
% event! PickUp(holda,holdb)
event(pickUp(holda,holdb)).

% event! LetGoOf(holda,holdb)
event(letGoOf(holda,holdb)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4574).
% event! Hold(holda,holdb)
event(hold(holda,holdb)).

% fluent! Holding(holda,holdb)
fluent(holding(holda,holdb)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4577).
% sort sita, sitb
sort(sita).
sort(sitb).

% event! LieOn(sita,sitb)
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4577).
event(lieOn(sita,sitb)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4579).
% event! SitOn(sita,sitb)
event(sitOn(sita,sitb)).

% event! RiseFrom(sita,sitb)
event(riseFrom(sita,sitb)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4581).
% fluent! LyingOn(sita,sitb)
fluent(lyingOn(sita,sitb)).

% fluent! SittingOn(sita,sitb)
fluent(sittingOn(sita,sitb)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4584).
% ona! Food1
t(ona,food1).

% onb! Table1
t(onb,table1).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4586).
% holda! Cook1
t(holda,cook1).

% holdb! Food1
t(holdb,food1).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4588).
% holdc! Table1
t(holdc,table1).

% sita! Eater1
t(sita,eater1).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4590).
% sitb! Chair1
t(sitb,chair1).
%; initial situation
% [agent]
 % HoldsAt(Dressed(agent),0).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4592).
holds_at(dressed(Agent),0).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4594).
% [agent]
 % HoldsAt(Awake(agent),0).
holds_at(awake(Agent),0).


% [agent]
 % HoldsAt(Sleep3(agent),0).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4594).
holds_at(sleep3(Agent),0).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4596).
% [agent]
 % HoldsAt(Standing(agent),0).
holds_at(standing(Agent),0).


% [agent]
 % HoldsAt(Standing(agent),0).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4596).
holds_at(standing(Agent),0).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4598).
% [agent,object]
 % !HoldsAt(Holding(agent,object),0).
holds_at(not(holding(Agent,Object)),0).


% [food]
 % HoldsAt(At(food,Kitchen1),0).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4598).
holds_at(at_loc(Food,kitchen1),0).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4600).
% [food]
 % !HoldsAt(FoodPrepared(food),0).
holds_at(not(foodPrepared(Food)),0).


% [agent]
 % HoldsAt(Hungry(agent),0).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4600).
holds_at(hungry(Agent),0).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4602).
% [door]
 % HoldsAt(DoorIsOpen(door),0).
holds_at(doorIsOpen(Door),0).


% [clothing]
 % HoldsAt(At(clothing,Upstairs1),0).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4602).
holds_at(at_loc(Clothing,upstairs1),0).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4604).
% [chair]
 % HoldsAt(At(chair,DiningRoom1),0).
holds_at(at_loc(Chair,diningRoom1),0).


% HoldsAt(At(Cook1,Kitchen1),0).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4604).
holds_at(at_loc(cook1,kitchen1),0).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4606).
% HoldsAt(At(Table1,DiningRoom1),0).
holds_at(at_loc(table1,diningRoom1),0).


% [agent,clothing]
 % !HoldsAt(Wearing(agent,clothing),0).
:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4606).
holds_at(not(wearing(Agent,Clothing)),0).


%; narrative


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4610).
% HoldsAt(At(Cook1,Kitchen1),0).
holds_at(at_loc(cook1,kitchen1),0).


% HoldsAt(At(Eater1,Upstairs1),0).
holds_at(at_loc(eater1,upstairs1),0).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4612).
% HoldsAt(At(Eater2,Upstairs1),0).
holds_at(at_loc(eater2,upstairs1),0).


% Happens(FoodPrepare(Cook1,Food1),0).
happens_at(foodPrepare(cook1,food1),0).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4614).
% Happens(PutOn(Eater1,Clothing1),1).
happens_at(putOn(eater1,clothing1),1).


% Happens(PutOn(Eater2,Clothing2),2).
happens_at(putOn(eater2,clothing2),2).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4616).
% Happens(WalkDownStaircase(Eater1,Staircase1),3).
happens_at(walkDownStaircase(eater1,staircase1),3).


% Happens(WalkDownStaircase(Eater2,Staircase1),4).
happens_at(walkDownStaircase(eater2,staircase1),4).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4618).
% Happens(WalkThroughDoor12(Eater1,DiningRoomDoor1),5).
happens_at(walkThroughDoor12(eater1,diningRoomDoor1),5).


% Happens(WalkThroughDoor12(Eater2,DiningRoomDoor1),6).
happens_at(walkThroughDoor12(eater2,diningRoomDoor1),6).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4620).
% Happens(SitOn(Eater1,Chair1),7).
happens_at(sitOn(eater1,chair1),7).


% Happens(SitOn(Eater2,Chair2),8).
happens_at(sitOn(eater2,chair2),8).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4622).
% Happens(PickUp(Cook1, Food1),9).
happens_at(pickUp(cook1,food1),9).


% Happens(WalkThroughDoor21(Cook1, KitchenDoor1),10).
happens_at(walkThroughDoor21(cook1,kitchenDoor1),10).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4624).
% Happens(PlaceOn(Cook1, Food1, Table1),11).
happens_at(placeOn(cook1,food1,table1),11).


% Happens(WalkThroughDoor12(Cook1, KitchenDoor1),12).
happens_at(walkThroughDoor12(cook1,kitchenDoor1),12).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4626).
% Happens(Eat(Eater1,Food1),13).
happens_at(eat(eater1,food1),13).


% Happens(Eat(Eater2,Food1),14).
happens_at(eat(eater2,food1),14).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4628).
% Happens(Converse(Eater1,Eater2),15).
happens_at(converse(eater1,eater2),15).


% Happens(TalkAbout(Eater1,Content1),16).
happens_at(talkAbout(eater1,content1),16).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4630).
% Happens(TalkAbout(Eater2,Content2),17).
happens_at(talkAbout(eater2,content2),17).


% Happens(RiseFrom(Eater1,Chair1),18).
happens_at(riseFrom(eater1,chair1),18).


:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4632).
% Happens(RiseFrom(Eater2,Chair2),19).
happens_at(riseFrom(eater2,chair2),19).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4634).
% range time 0 20
:- call_pel_directive(range(time, 0, 20)).

% range offset 0 0
:- call_pel_directive(range(offset, 0, 0)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4636).
% range diameter 0 0
:- call_pel_directive(range(diameter, 0, 0)).

:-was_s_l('/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.e',4638).
% completion Happens
:- call_pel_directive(completion(happens_at)).
%; End of file.
:- call_pel_directive(translate(ending,
                                '/pack/logicmoo_ec/test/ec_planner/ectest/ec_reader_test_ecnet.pel')).
